<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring-IOC原理(一)</title>
    <url>/archives/81aeb1f/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Spring中最重要的就属<code>IOC</code>了，不论是在面试中，还是在一些中间件与Spring的继承中，都离不开<code>IOC</code>，下面就来瞧瞧<code>IOC</code>是个什么东西，他是怎么一个加载流程，先大致粗略的了解一下！</p>
<h2 id="一、下载Spring源码"><a href="#一、下载Spring源码" class="headerlink" title="一、下载Spring源码"></a>一、<a href="https://gitee.com/li-huibin/spring-framework-5.2.16.-release">下载Spring源码</a></h2><h2 id="二、编译Spring源码"><a href="#二、编译Spring源码" class="headerlink" title="二、编译Spring源码"></a>二、编译Spring源码</h2><p>在编译的时候有些包是需要从外网下载的，有条件的可以科学上网，这样可以加快编译速度。如果不管怎么编译都是报错，或者下载包总是失败，可以留言我，我可以提供一点有限的帮助。</p>
<h2 id="三、创建demo模块"><a href="#三、创建demo模块" class="headerlink" title="三、创建demo模块"></a>三、创建demo模块</h2><p><img src="/archives/81aeb1f/image-20210813193225670.png" alt="创建demo模块"></p>
<blockquote>
<p><strong>注意：</strong> 一定要选择<code>Gradle</code>，别选错了，因为从<code>Spring5</code>开始，使用的是<code>Gradle</code>来构建整个项目的</p>
</blockquote>
<p><img src="/archives/81aeb1f/image-20210813193542786.png" alt="创建demo模块-2"></p>
<p>这里因为我已经事先创建过了模块，所以上面会有一个报错。然后点<code>Finish</code>完成创建。</p>
<p>创建完毕之后，在初始化模块的目录结构，我的目录结构是如下结构：</p>
<p><img src="/archives/81aeb1f/image-20210813193846621.png" alt="demo模块目录结构"></p>
<p>这里我创建了三个类<code>ApplicationMain</code>启动类、<code>TestIOC</code>接口、实现<code>TestIOC</code>接口的<code>TestIOCImpl</code>实现类。</p>
<p><code>TestIOC.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestIOC</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloIOC</span><span class="params">(String say)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>TestIOCImpl.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.TestIOC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIOCImpl</span> <span class="keyword">implements</span> <span class="title">TestIOC</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloIOC</span><span class="params">(String say)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;====&gt; &quot;</span> + say);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationMain.java</code>启动类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.impl.TestIOCImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1 mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lhb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br><span class="line">		TestIOCImpl bean = applicationContext.getBean(TestIOCImpl.class);</span><br><span class="line">		bean.helloIOC(<span class="string">&quot;hello spring ioc&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、IOC主流程分析"><a href="#四、IOC主流程分析" class="headerlink" title="四、IOC主流程分析"></a>四、<code>IOC</code>主流程分析</h2><p>首先，肯定是要从整个程序的入口开始分析的，下面就从<code>ApplicationMain</code>中的<code>main</code>方法开始。从上图中我们可以看到在<code>ApplicationMain</code>类中的<code>main</code>方法中手动创建了一个<code>AnnotationConfigApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br></pre></td></tr></table></figure>

<p>嗯？？what.<code>AnnotationConfigApplicationContext</code>是一个什么东西。。为什么要创建这个东西；那么就带着这个疑问点到他的源码里看一看。<code>Ctrl</code>+鼠标左键走起。</p>
<p><img src="/archives/81aeb1f/image-20210813200002798.png" alt="AnnotationConfigApplicationContext.java"></p>
<p>这两个名叫<code>Juergen Hoeller和Chris Beams</code>的作者给写了一大片注释，大概意思就是<code>AnnotationConfigApplicationContext</code>是整个引用的上下文，可以用他来获取容器中的Bean，和注册Bean等；<code>AnnotationConfigApplicationContext</code>实现会这继承了Spring框架中大部分的基础能力，一切Spring的动作，都是从这个类开始进行的，并且整个过程也都是这个类来进行接管的；所以它也是比较强大；总之大部分容器中的和Bean的操作都可以通过<code>AnnotationConfigApplicationContext</code>来操作。</p>
<p><img src="/archives/81aeb1f/image-20210813201436746.png" alt="AnnotationConfigApplicationContext关系图"></p>
<p>从上面的<code>AnnotationConfigApplicatioinContext</code>类关系图中可以看出，这个类其实比较复杂的。好了这个类先聊到这里，接下来我们看到<code>AnnotationConfigApplicationContext</code>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext, deriving bean definitions</span></span><br><span class="line"><span class="comment"> * from the given component classes and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> componentClasses one or more component classes &amp;mdash; for example,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	 * 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	 * DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	 * 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	 * 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	 * 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">this</span>();</span><br><span class="line">	<span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	 * 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	 * 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	 * 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	register(componentClasses);</span><br><span class="line">	<span class="comment">/** 刷新 */</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中调用了三个方法，下面一一说一下这三个方法都干了什么</p>
<blockquote>
<p><strong><code>this()</code>：</strong>这个方法调用了本类的无参数构造函数，其实在调用<code>AnnotationConfigApplicationContext</code>的无参数构造方法之前，先调用的父类的构造方法。在这些方法中主要是做了一些初始化的操作，比如初始化我们的容器<code>beanDefinitionMap</code>，初始化资源读取器<code>AnnotationBeanDefinitionReader</code>和资源扫描器<code>BeanDefinitionScanner</code>等</p>
<p><strong><code>register(componentClasses)</code>：</strong> 这个方法很重要；在这个方法中会扫描所有的Bean，并且会把扫描出来的Bean定义进行注册；Spring还会在这里把带有<code>@Configuration</code>注解的类进行标记为<code>Full</code>配置类，不带<code>@Configuration</code>注解的类但是有<code>@Component</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportSource</code>、<code>@Server</code>等注解的类标记为<code>Lite</code>配置类，然后被标记为<code>Full</code>的配置类会进行<code>CGLIB</code>代理增强处理。</p>
<blockquote>
<p><em><strong>Spring的循环依赖也是在这个过程中解决的，后面会详细看这个方法</strong></em>    </p>
</blockquote>
<p><strong><code>refresh()</code>：</strong> 这个方法很重要，几乎Spring所有的启动动作都会在这个方法来完成的。在这里会准备Bean工厂，为Bean工厂设置一些依赖到的接口，也会添加后置处理器，注册类的后置处理器，注册Bean工厂后置处理器，解析<code>@Import</code>、<code>@Component</code>注解、注册Bean后置处理器、初始化事件、实例化Bean等操作、发布初始化完成事件等操作；这个方法后面也会详细看</p>
</blockquote>
<p>下面通过一个图来回顾总结一下整个流程：</p>
<p><img src="/archives/81aeb1f/IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="Spring-IOC原理"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建博客详细教程</title>
    <url>/archives/8eb04e19/</url>
    <content><![CDATA[<p>经历了两天的折腾，终于搭建好了个人博客。由于第一次搭建个人博客，所以在搭建过程中也遇到了很多的问题。现在特意整理一下整个搭建过程以及中间遇到的问题。</p>
<h4 id="一、软件准备"><a href="#一、软件准备" class="headerlink" title="一、软件准备"></a>一、软件准备</h4><ul>
<li><a href="https://git-scm.com/downloads">安装Git</a></li>
</ul>
<p><img src="/archives/8eb04e19/image-20210727204933786-16274456504351.png" alt="image-20210727204933786"></p>
<p>根据系统需求下载对应的版本，这里下载windows版本</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/download/">安装Node.js</a></li>
<li>安装Hexo</li>
</ul>
<p>默认已经安装以上两个软件，接下来安装Hexo。在任意文件夹中打开<code>CMD</code>窗口执行如下指令安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>等待大概一分钟安装完毕，执行<code>hexo -v</code> 如果出现版本信息，说明安装成功。</p>
<h4 id="二、创建git远程仓库"><a href="#二、创建git远程仓库" class="headerlink" title="二、创建git远程仓库"></a>二、创建git远程仓库</h4><p>1、如果还没有github账号，需要先注册账号。如果不会注册直接百度就可以，类似的教程百度有很多；这里默认都注册过了github。接下来登录github创建仓库：如下图</p>
<p><img src="/archives/8eb04e19/image-20210727221144333.png" alt="image-20210727221144333"></p>
<blockquote>
<p><strong>特别需要注意的是 第一步中仓库名称必须是Ower.github.io 格式，其中Ower是用户名。如果不是这个格式的话，后面使用hexo生成的静态页面会识别不了</strong></p>
</blockquote>
<p>2、以上步骤完成之后，在电脑本地创建一个文件夹，存放我们的本地blog。</p>
<p><img src="/archives/8eb04e19/image-20210727222117448.png" alt="image-20210727222117448"></p>
<p>3、打开CMD命令窗口，并且cd到blog文件中执行初始化blog工程指令<code>hexo init</code></p>
<p><img src="/archives/8eb04e19/image-20210727223759193.png" alt="image-20210727223759193"></p>
<p>完毕之后目录结构如下：</p>
<p><img src="/archives/8eb04e19/image-20210727223938616.png" alt="image-20210727223938616"></p>
<blockquote>
<p>想要详细了解目录结构可以查看hexo官网 <a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p>
</blockquote>
<p>4、配置blog工程中的<code>_config.yml</code>文件</p>
<p><img src="/archives/8eb04e19/image-20210727224818946.png" alt="image-20210727224818946"></p>
<p><img src="/archives/8eb04e19/image-20210727225056195.png" alt="image-20210727225056195"></p>
<p>这里主要是设置上图中圈中的三个地方，这里解释一下三个代表什么:</p>
<ul>
<li><code>url</code>: 表示将来访问仓库博客的地址，其格式为”https://仓库名称”</li>
<li><code>theme</code>: 表示博客要使用的主题，默认使用<code>landscape</code>，如果是不想使用默认主题，可以到<a href="https://hexo.io/themes/">hexo官网</a>找自己喜欢的主题。当然如果自己有web相关基础的话也可以自己参照<a href="https://hexo.io/zh-cn/docs/themes">hexo官网自定义主题</a></li>
<li><code>type</code>: 表示博客将来要发布到哪个服务器，这里我们选择发布到<code>git</code></li>
<li><code>repo</code>: 表示发布到<code>git</code>中的哪个仓库里，这里我们是发布到上面创建的仓库中<code>https://github.com/li-huibin/li-huibin.github.io</code></li>
</ul>
<blockquote>
<p>注意这里设置的repo 地址是仓库地址，而不是https://仓库名称。应该是如下图红框中的地址，这里不能设置错了，否则会访问不到博客</p>
<p><img src="/archives/8eb04e19/image-20210727230856137.png" alt="image-20210727230856137"></p>
</blockquote>
<ul>
<li><code>branch</code>: 表示发布到仓库的哪个分支，默认<code>master</code></li>
</ul>
<p>到此为止，个人博客基本搭建完毕。接下来在<code>cmd</code>中编译工程，然后启动本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo generate</span><br><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo server</span><br></pre></td></tr></table></figure>

<p><img src="/archives/8eb04e19/image-20210727231758842.png" alt="image-20210727231758842"></p>
<p>本地服务启动后，hexo默认地址是<a href="http://localhost:4000/">http://localhost:4000</a> 。我们访问这个地址就可以看到本地的博客服务了</p>
<p><img src="/archives/8eb04e19/image-20210727231930894.png" alt="image-20210727231930894"></p>
<p>5、将本地博客发布到git仓库</p>
<p>执行如下指令将我们的本地博客发布到刚刚创建的远程git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo deploy</span><br></pre></td></tr></table></figure>

<p>然后，就可以直接在浏览器中访问<code>https://li-huibin.github.io</code>来访问博客了。到此为止博客搭建完毕。</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo静态页面图片不显示问题</title>
    <url>/archives/e4419141/</url>
    <content><![CDATA[<p>hexo静态页面图片不显示一般有几个原因：</p>
<p>1、<code>_config.yml</code>中没有设置<code>post_asset_folder: true</code>；这个设置默认是false</p>
<p>2、没有安装插件 asset-image</p>
<p>如果在运行工程之前上面两个步骤都没有操作过，则首先需要在<code>_config.yml</code>中设置<code>post_asset_folder:true</code> 。然后在cmd中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>由于国内网络环境，可能需要多下载几次才可以下载成功，要耐心等待。或者有条件的可以翻墙下载。</p>
<p>以上操作完毕之后重新发布工程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>页面效果如下：</p>
<p><img src="/archives/e4419141/image-20210728134047043.png"></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>invokeBeanDefinitionRegistryPostProcessors方法解析</title>
    <url>/archives/8d05e930/</url>
    <content><![CDATA[<p>在上一篇<a href="/archives/e74be873">《Spring-IOC原理之invokeBeanFactoryPostProcessor详解》</a>中我们提到了一个方法<code>invokeBeanDefinitionRegistryPostProcessors()</code>。也说了这个方法最终会调用<code>ConfigurationClassPostProcessor</code>类中的<code>postProcessBeanDefinitionRegistry</code>方法。并且在这个方法中会解析<code>@Import</code>、<code>@Component</code>等注解和创建<code>CGLIB</code>动态代理。那么这一篇我们来详细看一下这个调用链中的方法。</p>
<p>先找到<code>refresh()</code>方法中的<code>invokeBeanFactoryPostProcessors()</code>，然后找到方法中的<code>invokeBeanDefinitionRegistryPostProcessors</code>方法。</p>
<p><img src="/archives/8d05e930/image-20210828140340723.png" alt="PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors"></p>
<p>然后<code>Ctrl+鼠标左键</code>进入到该方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">		<span class="comment">/** 这里调用ConfigutationClassPostProcessor处理beanDefinitionMap中的bean定义 */</span></span><br><span class="line">		postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环遍历了传进来的<code>postProcessors</code>，不过<code>postProcessors</code>中只有一个类是<code>ConfigurationClassPostProcessor</code>。然后调用<code>postProcessBeanDefinitionRegistry</code>。</p>
<p><img src="/archives/8d05e930/image-20210828141408341.png" alt="Debug-invokeBeanDefinitionRegistryPostProcessors"></p>
<blockquote>
<p>这里还有一个点，就是<code>postProcessBeanDefinitionRegistry</code>方法，这个方法是<code>BeanDefinitionRegistryPostProcessor</code>接口中的方法，所以要想看方法内的实现逻辑只能找实现类中该方法的实现逻辑；通过上面的调试图片我们可以知道，<code>postProcessor</code>是<code>ConfigurationClassPostProcessor</code>类型，而<code>ConfigurationClassPostProcessor</code>切好也实现了<code>BeanDefinitionRegistryPostProcessors</code>接口，当然也实现了这个接口中的方法。所以这里我们只要去<code>ConfigurationClassPostProcessor</code>类中去找方法即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 这里会解析配置类的一些注解，例如<span class="doctag">@Configutation</span>、<span class="doctag">@Component</span>、<span class="doctag">@Import</span>等配置注解 */</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>postProcessBeanDefinitionRegistry</code>方法中，我们直接看到最后一行，调用了<code>processConfigBeanDefinitions(registry)</code>，这个方法主要是解析<code>@Component</code>、<code>@Import</code>等配置注解。<a href="/archives/79103379">想要了解<code>processConfigBeanDefinitioins</code>中具体流程可以查看这一篇。</a></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>processConfigBeanDefinitions方法解析</title>
    <url>/archives/79103379/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/archives/ccff2b22/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是Java中最常用的设计模式之一。在我们悉知的Spring中源码中的bean创建就是使用了工厂模式；这种类型的设计模式属于创建型模式，他提供一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>日志记录器：记录磁盘信息、业务事件、访问服务器信息等，让用户来选择日志记录到哪里。</li>
<li>连接服务器使用不同的协议，<code>POP3</code>、<code>IMAP</code>、<code>HTTP</code>三个协议可以用同一个接口来实现。</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>当一个调用者想创建对象时，只需要知道对象名字即可</li>
<li>扩展性高，如果需要增加新的类品，只需要新增一个工厂类即可</li>
<li>隐藏产品的具体实现，让调用者只关心接口</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>每次新增一个产品都需要新增一个产品工厂类，增加了系统复杂度。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>工厂模式在Spring源码中的应用解析：</p>
<p>我们知道在Spring中，如果我们想要通过容器去创建一个bean就需要调用一下代码来实现bean创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br><span class="line">TestIOCImpl bean = applicationContext.getBean(TestIOCImpl.class);</span><br></pre></td></tr></table></figure>

<p>其实<code>ApplicationContext</code>创建bean就是使用到了工厂模式。在上面的代码中，我们并没有显式的通过<code>new</code>去创建一个<code>TestIOCImpl</code>,通过调用<code>applicationContext.getBean()</code>传入一个bean的class来实例化；具体创建过程则交给了<code>ApplicationContext</code>去实现了。</p>
<p>首先来看看<code>ApplicationContext</code>整体的继承关系，也就是工厂模式的继承关系</p>
<p><img src="/archives/ccff2b22/image-20210810151313670.png" alt="ApplicationContext.java"></p>
<p><code>ApplicationContext</code>接口继承了一个最顶层的工厂类<code>BeanFactory</code>，来继续看看<code>BeanFactory</code>中有些什么方法呢。</p>
<p><img src="/archives/ccff2b22/image-20210810151723712.png" alt="BeanFactory.java"></p>
<p>看到这里是不是就会有点想法，我们在上面的代码中调用的<code>getBean(Class class)</code>是不是就是调用的这里的方法呢？具体实现那肯定就是在子类中去实现的喽。因为我们一开始的代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br></pre></td></tr></table></figure>

<p>创建的<code>ApplicationContext</code>接口实现类其实是<code>AnnotationConfigApplicationContext</code>类型，那么在<code>AnnotationConfigApplicationContext</code>类中是不是也实现了<code>getBean</code>的一些方法？实际上spring并没有在<code>AnnotationConfigApplicationContext</code>中去实现这些方法，而是通过一个抽象类<code>AbstractApplicationContext</code>来实现了<code>ApplicationContext</code>接口中的<code>getBean</code>一系列方法。这样做的目的也是为了提高后期的扩展性，毕竟spring这么强大，扩展性肯定是必须要很强的。</p>
<p><img src="/archives/ccff2b22/image-20210810152406751.png" alt="AnnotationConfigApplicationContext.java关系图"></p>
<p><code>AbstractApplicationContext</code>中实现<code>getBean</code>系列方法的代码：</p>
<p><img src="/archives/ccff2b22/image-20210810153412546.png" alt="getBean(...)代码实现"></p>
<p>以上就是在Spring中创建Bean所用到的工厂设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(二)</title>
    <url>/archives/49651b9e/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博文<a href="/archives/81aeb1f/">《Spring-IOC原理(一)》</a>中已经基本上了解了一下<code>Spring IOC</code>的大致运行流程。也知道了这个流程都是从<code>AnnotationConfigApplicationContext</code>构造方法中发起的，那么本篇博文就从<code>AnnotationConfigApplicationContext</code>构造方法中详细探究一下<code>Spring IOC</code>详细的加载过程；回顾一下<code>AnnotationConfigApplicationContext</code>构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	* 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	* DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	* 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	* 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	* 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	* 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	* 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	* 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">/** 刷新 */</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、this-方法详解"><a href="#一、this-方法详解" class="headerlink" title="一、this()方法详解"></a>一、<code>this()</code>方法详解</h2><p>在以上的构造方法中，首先是调用的本类的无参构造方法<code>this()</code>，<code>ctrl+鼠标左键</code>点进入看看这个构造方法里都干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 这里会隐式调用父类构造函数，来初始化DefaultListableBeanFactory */</span></span><br><span class="line">    <span class="comment">/** 1、 用来读取Bean配置信息，该配置信息是使用注解配置的 */</span></span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">/** 用来扫描 1中读取到的Bean，这里会扫描配置有<span class="doctag">@AutoWired</span>、<span class="doctag">@Value</span>等注解*/</span></span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AnnotationConfigApplicationContext</code>无参构造方法中创建了<code>this.reader</code>是一个<code>AnnotatedBeanDefinitionReader</code>类型和<code>this.scanner</code>是一个<code>ClassPathBeanDefinitionScanner</code>类型。</p>
<blockquote>
<p><strong><code>this.reader</code>：</strong> 注解bean定义读取器，主要作用是读取被注解标记的bean</p>
<p><strong><code>this.scanner</code>：</strong> 扫描器，如果使用注解的方式不会使用到这个扫描器；只有在外部通过<code>.scan(...)</code>方法时才会调到，常规方法时不会用到的。</p>
</blockquote>
<p>因为这里主要是用的注解的方式进行调试的，所以<code>this.scanner</code>也不会使用到，这里也就不去研究。接下来只研究<code>this.reader</code>。</p>
<p>因为<code>AnnotationConfigApplicationContext</code>类是继承了父类<code>GenericApplicationContext</code>的。如下类关系图</p>
<p><img src="/archives/49651b9e/image-20210817105837171.png" alt="AnnotationConfigApplicationContext类关系图"></p>
<p>所以在<code>AnnotationConfigApplicationContext</code>构造方法执行之前，首先会执行<code>GenericApplicationContetxt</code>类的默认构造方法，来看看<code>GenericApplicationContetxt</code>的构造方法里干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里创建了一个bean工厂，该bean工厂在后面进行bean初始化的时候会用到；其实这个<code>beanFactory</code>就是我们所说的容器</p>
</blockquote>
<p>等到<code>GenericApplicationContext()</code>执行完毕之后，接下来才会执行我们的<code>AnnotationConfigApplicationContext()</code>构造方法中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 1、 用来读取Bean配置信息，该配置信息是使用注解配置的 */</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>继续点进入，发现有调了<code>AnnotatedBeanDefinitionReader</code>的构造方法。继续跟进，what!!! 怎么还停留在构造方法中,嵌套这么复杂……想一想这不是设计模式中的门面方法么。看到了代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>

<h2 id="二、registerAnnotationConfigProcessors方法详解"><a href="#二、registerAnnotationConfigProcessors方法详解" class="headerlink" title="二、registerAnnotationConfigProcessors方法详解"></a>二、<code>registerAnnotationConfigProcessors</code>方法详解</h2><p>这回该是开始正式干活的方法了，点进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>。。。。此时一万只草泥马从眼前奔腾而过!!!既然已经到这里了，那我就在赌一把，继续点进入调用的方法中。</p>
<p>豁然开朗,终于看到了干活的方法了。好家伙小100行的方法，全是if判断。大致看一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 将ConfigurationClassPostProcessor分装成RootBeanDefinition注册到容器中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册CommonAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册EventListenerMethodProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册DefaultEventListenerFactory</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出在<code>registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)</code> 方法中主要将spring初始化要用到的后置处理器封装成了<code>RootBeanDefinition</code>并且将他们注册到<code>set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8)</code>中。主要包括</p>
<blockquote>
<ul>
<li><code>ConfigurationClassPostProcessor</code>：这个后置处理器后期会解析带有<code>@Configuration</code>、<code>@Import</code>、<code>@Component</code>、<code>@ComponentScan</code>等注解，在spring中给常重要</li>
<li><code>AutoWiredAnnotationBeanPostProcessor</code>：主要用来解析带有<code>@AutoWired</code>注解的属性，用来注入属性实例</li>
<li><code>CommonAnnotationBeanPostProcessor</code>：用来解析通用注解，比如<code>@Resource</code>、<code>@WebServiceRef</code>、<code>@EJB</code>注解。这三个注解都是定义在<code>javax.*</code>包下，属于java中的注解</li>
<li><code>PersistenceAnnotationBeanPostProcessor</code>：用来解析<code>@PersistenceUnit</code>、<code>@PersistenceContext</code>注解</li>
<li><code>EventListenerMethodProcessor</code>：用来解析<code>@EventListener</code>注解，</li>
<li><code>DefaultEventListenerFactory</code>：处理默认监听事件,当没有在程序中指定事件</li>
</ul>
</blockquote>
<h2 id="三、registerPostProcessor方法详解"><a href="#三、registerPostProcessor方法详解" class="headerlink" title="三、registerPostProcessor方法详解"></a>三、<code>registerPostProcessor</code>方法详解</h2><p>接下来继续看一下<code>registerPostProcessor(registry,def,beanName)</code>，点进入这个方法看看内部有什么实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title">registerPostProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记bean角色是spring内部定义，并非用户定义</span></span><br><span class="line">    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册bean定义，registry的实现类是DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法中主要设置了bean的角色和注册bean定义，</p>
</blockquote>
<h2 id="四、registerBeanDefinition方法详解"><a href="#四、registerBeanDefinition方法详解" class="headerlink" title="四、registerBeanDefinition方法详解"></a>四、<code>registerBeanDefinition</code>方法详解</h2><p>继续进入<code>registry.registerBeanDefinition(beanName, definition);</code>中，注意<code>registerBeanDefinition()</code>是接口中的方法，该方法中的实现是在接口实现类中，而<code>registry</code>的实现类是<code>DefaultListableBeanFactory</code>，所以最终我们要进入到<code>DefaultListableBeanFactory</code>类中的<code>registerBeanDefinition(beanName,definition)</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 先从beanDefinitionMap一级缓存中获取bean */</span></span><br><span class="line">	BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="comment">/** 如果一级缓存中有bean */</span></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/** 将bean设置到一级缓存 */</span></span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * beanDefinitionMap是Map&lt;String,BeanDefinition&gt;,这里把beanName作为key,beanDefinition作为value</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>整个方法中主要是将<code>registerAnnotationConfigProcessors(BeanDefinitionRegistry)</code>方法中注册的一些Bean后置处理器做了处理，将这些后置处理器注册成<code>BeanDefinition</code>对象并且将其放入<code>Map&lt;String,BeanDefinition&gt;</code>类型的<code>beanDefinitionMap</code>中。</p>
</blockquote>
<p>大概流程是：首先根据给定的<code>beanName</code>去<code>beanDefinitionMap</code>中拿bean定义，如果bean定义不为空。继续判断是否允许重复创建bean定义(如果允许重复创建bean定义，并且给定的bean定义名称已经在<code>beanDefinitionMap</code>中已经存在实例，则第二次创建的bean定义实例会覆盖第一次bean定义实例。可以通过<code>spring.main.allow-bean-definition-overriding</code>来指定是否允许覆盖);如果不允许重复创建bean定义即<code>allowBeanDefinitionOverriding=false</code>,会抛出<code>BeanDefinitionOverrideException</code>异常；如果允许重复创建bean定义即<code>allowReanDefinitionOverriding=true</code>；继续判断bean定义角色、bean定义类型，如果都通过，则将传入的bean定义实例放入<code>beanDefinitionMap</code>中；key为<code>beanName</code>,value为<code>BeanDefinition</code>实例对象；</p>
<p>如果从<code>beanDefinitionMap</code>中拿出的bean定义为空，即第一次进来，将传进来的bean定义放入<code>beanDefinitionMap</code>中，同时将<code>beanName</code>放入<code>beanDefinitionNames</code>中。然后判断从<code>beanDefinitionMap</code>拿出来的bean定义 不为空 或者 已经有实例的单例bean，则递归调用<code>resetBeanDefinition()</code>。</p>
<p>上面分析中说了，bean最后会保存在<code>beanDefinitionMap</code>中，<code>beanName</code>会保存在<code>beanDefinitionNames</code>中；<code>beanDefinitionMap</code>是一个Map，key是<code>beanName</code>,value是<code>BeanDefinition</code>；<code>beanDefinitionNames</code>是字符串列表。从这里我们可以看出<code>DefaultListableBeanFactory</code>就是我们常说的容器了。可以在这方法中打一个端点调试一下。</p>
<p><img src="/archives/49651b9e/image-20210817162318035.png" alt="端点调试"></p>
<p><strong><code>DefaultListableBeanFactory</code>中的<code>beanDefinitionMap</code>、<code>beanDefinitionNames</code>是很重要的，后面会经常看到他们的身影。</strong></p>
<p>这里只是简单的把创建bean所需要的基本信息放入到了工厂中，还没有进行真正的生产bean。上面我们提到注册了好多bean后置处理器，<strong>其中有一个很重要的bean是<code>ConfigurationClassPostProcessor</code> ，这个bean实现了一个接口<code>BeanDefinitionRegistryPostProcessor</code>接口，<code>BeanDefinitionRegistryPostProcessor</code>接口又继承了<code>BeanFactoryPostProcessor</code>接口；而<code>BeanFactoryPostProcessor</code>是Spring的扩展点之一，必须记住<code>ConfigurationClassPostProcessor</code>类的继承关系。</strong></p>
<p><img src="/archives/49651b9e/image-20210817163534229.png" alt="ConfigurationClassPostProcessor"></p>
<p>除了注册<code>ConfigurationClassPostProcessor</code>,还注册了<code>AutoWiredAnnotationBeanPostProcessor</code> bean，该bean实现了一个接口<code>MergedBeanDefinitionPostProcessor</code>，而<code>MergedBeanDefinitionPostProcessor</code>接口继承了<code>BeanPostProcessor</code>。**<code>BeanPostProcessor</code>也是Spring的一个扩展点之一，也是非常重要，需要记住。**</p>
<p><img src="/archives/49651b9e/image-20210817164936726.png" alt="AutoWiredAnnotationBeanPostProcessor类关系图"></p>
<p>到此，<code>this()</code>方法中的流程分析完毕。</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(三)</title>
    <url>/archives/37963bb5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博文《<a href="/archives/49651b9e/">Spring-IOC原理(二)</a>》中分析了<code>AnnotationConfigApplicationContext</code>构造方法中的<code>this()</code>方法，也知道了在这个方法中主要注册了一些<code>Spring</code>初始化必要的Bean，并且也创建了我们的容器对象。接下来继续看一下<code>AnnotationConfigApplicationContext</code>构造方法中的<code>register()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	 * 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	 * DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	 * 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	 * 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	 * 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	 * 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	 * 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	 * 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">/** 刷新 */</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、register方法分析"><a href="#一、register方法分析" class="headerlink" title="一、register方法分析"></a>一、<code>register</code>方法分析</h2><p>老办法，进入<code>register(componentClasses)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(componentClasses, <span class="string">&quot;At least one component class must be specified&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一个重写方法，在方法中又调用了<code>register(componentClasses)</code>;这次是调用<code>reader</code>中的<code>register</code>。先来看看<code>reader</code>是什么东西？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解bean定义读取器，主要作用是读取被注解标记的bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br></pre></td></tr></table></figure>

<p>看到这个，脑海中突然想到，我们在<code>this()</code>方法中不是初始化过一个<code>AnnotatedBeanDefinitionReader</code>吗！没错这个<code>reader</code>就是在<code>this()</code>中初始化完成创建的，几乎之后的用的<code>reader</code>，也是这个。既然知道它的来来龙去脉了，那就继续往下走，进到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.reader.register(componentClasses)</span><br></pre></td></tr></table></figure>

<p>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，依次遍历<code>componentClasses</code>，并将遍历出的类通过<code>registerBean</code>方法中。进入<code>registerBean(componentClasses)</code>方法中具体看看是怎么做的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又被<code>Spring</code>代码搞恶心了，这TM套了这么多层还没有进入。高手都是这样子写代码的吗？？后来才知道其实在<code>Spring</code>源码中，不管嵌套多少次，最终真正干活的方法只有是<code>doXXX()</code>的方法。好吧继续进到<code>doRegisterBean()</code>方法中。</p>
<h3 id="1-1、doRegisterBean方法分析"><a href="#1-1、doRegisterBean方法分析" class="headerlink" title="1.1、doRegisterBean方法分析"></a>1.1、<code>doRegisterBean</code>方法分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * AnnotatedGenericBeanDefinition一种数据结构，用来描述Bean的，这里的作用就是把传入的标记了注解的类转为</span></span><br><span class="line"><span class="comment">	 * AnnotatedGenericBeanDefinition数据结构，类里面有一个getMetadata方法，可以拿到类上面的注解信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断是否需要跳过注解，spring中有<span class="doctag">@Condition</span>注解，当不满足条件，这个Bean就不会被解析</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解析bean的作用域，如果没有设置的话，默认是单例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取bean名字</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为<span class="doctag">@Lazy</span>、<span class="doctag">@Primary</span>,<span class="doctag">@DependsOn</span>、<span class="doctag">@Role</span>、<span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 限定符处理，不是特指<span class="doctag">@Qualifier</span>注解，也有可能是<span class="doctag">@Primary</span>,或者<span class="doctag">@Lazy</span>，或者是其他，如果以常规方式去初始化spring</span></span><br><span class="line"><span class="comment">	 * ApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationMain.class);</span></span><br><span class="line"><span class="comment">	 * qualifier永远都是空的，包括上面的name和instanceSupplier都是同样的道理</span></span><br><span class="line"><span class="comment">	 * 但是spring提供了其他方式去注册bean，就可能传入了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 可以传入qualifier数组，所以这里循环处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 优先处理<span class="doctag">@Primary</span>注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 再处理<span class="doctag">@Lazy</span>注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 最后处理其他注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">			customizer.customize(abd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将AnnotatedGenericBeanDefinition和beanName封装到一个对象中BeanDefinitionHolder</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注册。最终调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，DefaultListableBeanFactory会维护一系列的信息</span></span><br><span class="line"><span class="comment">	 * 比如beanDefinitionNames,beanDefinitionMap。</span></span><br><span class="line"><span class="comment">	 * beanDefinitionNames是一个List&lt;String&gt; 用来存放bean的名字</span></span><br><span class="line"><span class="comment">	 * beanDefinitionMap是一个Map&lt;String,BeanDefinition&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细看一下上面代码。</p>
<h4 id="1-1-1、-初始化AnnotatedGenericBeanDefinition"><a href="#1-1-1、-初始化AnnotatedGenericBeanDefinition" class="headerlink" title="1.1.1、 初始化AnnotatedGenericBeanDefinition"></a>1.1.1、 初始化<code>AnnotatedGenericBeanDefinition</code></h4><p>首先是创建了一个<code>AnnotatedGenericBeanDefinition</code>，它其实可以看做是一种数据结构，里面会包含一些注解信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里创建<code>AnnotatedGenericBeanDefinition</code>的作用主要是吧传入的标记了注解的类封装为<code>AnnotatedGenericBeanDefinition</code>类型，然后可以通过<code>AnnotatedGenericBeanDefinition</code>中的<code>getMetadata()</code>方法来拿到类上面的注解信息。</p>
</blockquote>
<h4 id="1-1-2、shouldSkip-判断是否跳过"><a href="#1-1-2、shouldSkip-判断是否跳过" class="headerlink" title="1.1.2、shouldSkip()判断是否跳过"></a>1.1.2、<code>shouldSkip()</code>判断是否跳过</h4><p>接下类会判断是否需要跳过注解。在<code>Spring</code>中有一个<code>@Confition</code>注解，当不满足该注解表达式中条件时，这个Bean就不会被解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>shouldSkip()</code>方法中主要是解析带有<code>@Conditional</code>注解的类，如果没有注解这个注解，则直接返回false,否则会循环递归去解析带有该注解的类；并将所有带有该注解的类元信息拿到，并遍历渠道过滤条件，然后将过滤条件封装为<code>Condition</code>加入到<code>conditions</code>集合中；然后进行排序，之后会遍历我们刚刚保存的条件集合<code>conditions</code> ，通过<code>matchs()</code>方法匹配到符合过滤条件的bean,返回true</p>
</blockquote>
<h3 id="1-1-3、解析bean作用域"><a href="#1-1-3、解析bean作用域" class="headerlink" title="1.1.3、解析bean作用域"></a>1.1.3、解析bean作用域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析bean的作用域，如果没有设置的话，默认是单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里bean的作用域默认是单例，当然可以通过<code>@Scope(scopeName = &quot;&quot;)</code>注解来指定作用域,是<code>singleton</code>还是<code>prototype</code></p>
</blockquote>
<h3 id="1-1-4、解析通用注解"><a href="#1-1-4、解析通用注解" class="headerlink" title="1.1.4、解析通用注解"></a>1.1.4、解析通用注解</h3><p>通过<code>AnnotationConfigUtils.processCommonDefinitionAnnotations(abd)</code>来解析通用注解，例如<code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>、<code>@Role</code>、<code>@Description</code>注解。然后处理解析到的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可以传入qualifier数组，所以这里循环处理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 优先处理<span class="doctag">@Primary</span>注解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">            abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 再处理<span class="doctag">@Lazy</span>注解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">            abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 最后处理其他注解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述代码我们可以看出，其实<code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>、<code>@Role</code>、<code>@Description</code>在处理的时候是有优先级的，如果一个类中以上几个注解都标注了，那么优先级依次是：<code>@Primary</code> &gt; <code>@Lazy</code> &gt; 其他注解</p>
</blockquote>
<h3 id="1-1-5、通过registerBeanDefinition-注册spring需要的基础bean"><a href="#1-1-5、通过registerBeanDefinition-注册spring需要的基础bean" class="headerlink" title="1.1.5、通过registerBeanDefinition()注册spring需要的基础bean"></a>1.1.5、通过<code>registerBeanDefinition()</code>注册spring需要的基础bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册。最终调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，DefaultListableBeanFactory会维护一系列的信息</span></span><br><span class="line"><span class="comment"> * 比如beanDefinitionNames,beanDefinitionMap。</span></span><br><span class="line"><span class="comment"> * beanDefinitionNames是一个List&lt;String&gt; 用来存放bean的名字</span></span><br><span class="line"><span class="comment"> * beanDefinitionMap是一个Map&lt;String,BeanDefinition&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>

<p>最终通过调用<code>DefaultListableBeanFactory</code>类中的<code>registerBeanDefinition()</code>来完成基础bean的注册，这个方法的调用链很深，我们先点进到<code>registerBeanDefinition()</code>方法中看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取bean的名字</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注册bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果有别名，注册别名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>registerBeanDefinition()</code>方法中先获取了bean名字，然后通过调用<code>registry.registerBeanDefinition(beanName,beanDefinition)</code>来真正完成注册，这里的<code>registry</code>是<code>DefaultListableBeanFactory</code>实现子类，所以我们到<code>DefaultListableBeanFactory</code>类中找到<code>registerBeanDefinition()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                   <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 先从beanDefinitionMap一级缓存中获取bean */</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">/** 如果一级缓存中有bean */</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                            <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                            existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 将bean设置到一级缓存 */</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * beanDefinitionMap是Map&lt;String,BeanDefinition&gt;,这里把beanName作为key,beanDefinition作为value</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会判断<code>beanDefinitionMap</code>缓存中是否存在bean，第一次进来肯定是不存在的，所以第一次进来必定会进入else分支，在else分支中，为了避免重复创建，首先会通过<code>hasBeanCreationStarted()</code>来判断是否已经创建。第一次的话这里肯定也是没有创建，所以也不会进入到if中，来到else将<code>beanDefinition</code>放入<code>beanDefinitionMap</code>中，<code>beanName</code>放入<code>beanDefinitionNames</code>集合中。最后开看一些<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从代码中可以看出，<code>beanDefinitionMap</code>是一个Map，并且key是<code>beanName</code>，value是<code>BeanDefinition</code>，<code>beanDefinitionNames</code>是一个集合，并且是线程可见变量集合，用来保存<code>beanName</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(四)</title>
    <url>/archives/cdd5d4ba/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇博文《<a href="/archives/37963bb5/">Spring-IOC原理(三)</a>》中分析了<code>AnnotationConfigApplicationContext</code>构造函数中的前两个步骤，接下来我们分析最后一步，这最后一步也是整个过程的核心方法，几乎所有的操作都在这个最后的方法中完成。而且最后这个方法中调用链比较深，所以这次我们先大致捋一下最后方法中的所有大致流程，然后在逐个方法去解析其中的过程。下面我们就开始分析最后一个重要的方法<code>refresh()</code>。进入到<code>refresh()</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 刷新预处理，这里主要是保存了容器的启动时间、启动标志等信息；和主流程的关系不大</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里最终获取了ConfigurableListableBeanFactory，和主流程的关系也不大</span></span><br><span class="line"><span class="comment">		 * DefaultListableBeanFactory实现了ConfigurableListableBeanFactory</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="comment">/** 准备这个上下文要数用的bean工厂 ，这里会设置beanFactory忽略的依赖接口（一些Aware接口），注册一些bean工厂依赖的bean（BeanFactory、ApplicationContext</span></span><br><span class="line"><span class="comment">		 * ApplicationEventPublisher、ResourceLoader），以及一些默认的bean。</span></span><br><span class="line"><span class="comment">		 * 添加了两个后置处理器：ApplicationContextAwareProcessor、ApplicationListenerDetector</span></span><br><span class="line"><span class="comment">		 * 设置了bean表达式解析器等</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      <span class="comment">/** 注册上下文子类的后置处理器 */</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      <span class="comment">/** 实例化并调用所有已经注册的BeanFactoryPostProcessor，会解析<span class="doctag">@Import</span>、<span class="doctag">@Component</span>等注解 */</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      <span class="comment">/** 注册BeanPostProcessors后置处理器 */</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      <span class="comment">// 初始化国际化资源处理器。不是主线程代码</span></span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      <span class="comment">/** 初始化事件多播器，容器是使用自定义的广播器还是默认的时间广播器都是在这个方法中进行处理的 */</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      <span class="comment">/** 初始化特定容器中的指定bean，这个方法时空方法，用来扩展用。</span></span><br><span class="line"><span class="comment">			 * 该方法是模板方法，容器刷新的时候可以自定义逻辑，不同的spring容器有不同的实现</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      <span class="comment">/** 注册事件监听器 */</span></span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      <span class="comment">/** 实例化剩余的单例Bean(非懒加载)</span></span><br><span class="line"><span class="comment">			 * 比如invokeBeanFactoryPostProcessors(beanFactory)方法中根据各种注解解析出来的类，在这个时候才会被初始化</span></span><br><span class="line"><span class="comment">			 * 实例化的过程各种BeanPostProcessor开始起作用</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      <span class="comment">/** 最后发布相应的事件</span></span><br><span class="line"><span class="comment">			 * 清除上下文资源缓存</span></span><br><span class="line"><span class="comment">			 * 初始化上下文的生命周期处理器，并刷新(找出Spring容器中实现了Lifecycle接口的bean并执行start()方法)</span></span><br><span class="line"><span class="comment">			 * 发布ContextRefreshedEvent事件告诉对应的ApplicationListener进行响应操作</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一、prepareRefresh"><a href="#一、prepareRefresh" class="headerlink" title="一、prepareRefresh()"></a>一、<code>prepareRefresh()</code></h2><p>首先，会进行初始化前的准备工作，通过<code>prepareRefresh()</code>方法来保存了容器的启动时间、启动标志信息等。该方法中主要也是进行了启动前的一系列准备工作，和实际流程关系不太大。可以进入到<code>prepareRefresh()</code>方法中看一看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Switch to active.</span></span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">	<span class="comment">/** 在上下文环境中初始化任何占位符属性源。</span></span><br><span class="line"><span class="comment">	 * 如果一个类重写了initPropertySources()方法，比如设置了一个环境变量testProperty,</span></span><br><span class="line"><span class="comment">	 * 在容器启动的时候，会去环境变量中寻找testProperty，如果没有找到这个属性就会抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">	<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">	<span class="comment">/** 校验环境依赖的所有环境变量或者属性是否存在，是否可以解析，</span></span><br><span class="line"><span class="comment">	 * 这一步和上一步initPropertySources()相互配合使用，在initPropertySources()中设置了环境变量，</span></span><br><span class="line"><span class="comment">	 * 在这一步检测环境变量在配置文件中是否已经配置了。</span></span><br><span class="line"><span class="comment">	 * 例如：在initPropertySources()中配置了testProperty属性，那么在validateRequiredProperties()中</span></span><br><span class="line"><span class="comment">	 * 会检测环境变量是否真正有这个testProperty属性，是否可以解析这个属性，如果不存在这个testProperty属性，</span></span><br><span class="line"><span class="comment">	 * 那么会抛出MissingRequiredPropertiesException异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for the collection of early ApplicationEvents,to be published once the multicaster is available...</span></span><br><span class="line">	<span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">	<span class="comment">/** 创建早期多播器，一旦多播器可用就可以发送事件</span></span><br><span class="line"><span class="comment">	 * 所谓早期多播器就是：我们的事件监听器还没有注册到多播器上的时候，都是早期事件，早期事件不许要手动publishEvent发布，在</span></span><br><span class="line"><span class="comment">	 * RegisterListener中会自动发布</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中主要进行了三个操作：</p>
<ol>
<li><p>通过<code>initPropertySources()</code>初始化了属性源占位符，这个方法默认是空实现，如果一个类重写了<code>initPropertySources()</code>方法，比如设置了一个环境变量<code>test</code>，那么在容器启动的时候，spring会去环境变量中寻找<code>test</code>属性，如果没有找到这个属性就会抛出异常。</p>
</li>
<li><p>通过<code>getEnvironment().validateRequiredProperties()</code>检测环境依赖的所有环境变量或者属性是否存在，是否可以解析。这一步操作和上一步操作<code>initPropertySources()</code>是相互配合使用的，在<code>initPropertySources()</code>中设置了环境变量，在这一步会检测环境变量在配置文件中是否已经配置。</p>
<blockquote>
<p>例如：在<code>initPropertySources()</code>中配置了<code>test</code>属性，那么会在<code>validateRequiredProperties()</code>中检测环境变量是否真正有这个<code>test</code>属性，是否可以解析这个属性，如果不存在<code>test</code>属性，就会抛出<code>MissingRequiredPropertiesException</code>异常</p>
</blockquote>
</li>
</ol>
<p>​       这里还有一个小的知识点，就是在spring中我们可以怎么获取配置文件<code>application.yml</code>中配置的属性值。常用的有两种方式：①是         通过使用<code>@Value</code>，例如：在相应的字段上标注<code>@Value(&quot;$&#123;server.port&#125;&quot;)</code>就可以读取到服务的端口；②通过<code>@ConfigurationProperties</code>注解，在需要读取的实体类上标注该注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;student&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收配置信息的实体类 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml中的配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysgk</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是在使用<code>@ConfigurationProperties</code>注解时，需要配置一一个<code>prefix</code>前缀参数。</p>
</blockquote>
<p>③最后一个是通过注入<code>Environment</code>来获取我们想要的属性，<code>Environment</code>就是在<code>getEnvironment()</code>方法中初始化创建出来的，我们进如到<code>getEnvironment()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用方法<code>createEnvironment()</code>来完成创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>StandardEnvironment</code>是个什么东东，我们看一看它的类继承关系</p>
<p><img src="/archives/cdd5d4ba/image-20210824114741338.png" alt="StandardEnvironment类继承关系"></p>
<p>​      当然这里也只是初始化了<code>Evironment</code>，还没有进行配置属性装载，具体装载会在<code>prepareBeanFactory()</code>中完成</p>
<ol start="3">
<li><code>this.earlyApplicationEvents</code> 创建了早期多播器，一旦多播器被创建，就可以发送事件了。什么是多播器呢，所谓早期多播器就是：我们的事件监听器还没有注册到多播器上的时候，都是早期事件，早期事件是不需要手动publishEvent发布，在RegisterListener中自动完成</li>
</ol>
<h2 id="二、obtainFreshBeanFactory"><a href="#二、obtainFreshBeanFactory" class="headerlink" title="二、obtainFreshBeanFactory()"></a>二、<code>obtainFreshBeanFactory()</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>这个方法和主流程的关系也不大，这里只是获取了我们在之前创建好的<code>DefaultListableBeanFactory</code>，那这里为什么是<code>ConfigurableListableBeanFactory</code>类型呢，因为我们的<code>DefaultListableBeanFactory</code>是实现了<code>ConfigurableListableBeanFactory</code>的。</p>
<blockquote>
<p>再回顾一下<code>DefaultListableBeanFactory</code>是在哪里创建的。之前我们说过，在执行<code>AnnotationConfigApplicationContext</code>构造方法之前会首先执行其父类的构造方法，</p>
<p><img src="/archives/cdd5d4ba/image-20210824121207079.png" alt="GenericApplicationContext"></p>
<p>从上图可以看出，在父类构造方法中实例化了<code>beanFactory</code>，而<code>beanFactory</code>的类型是<code>DefaultListableBeanFactory</code></p>
</blockquote>
<h2 id="三、prepareBeanFactory-beanFactory"><a href="#三、prepareBeanFactory-beanFactory" class="headerlink" title="三、prepareBeanFactory(beanFactory)"></a>三、<code>prepareBeanFactory(beanFactory)</code></h2><p>在这个方法中主要是准备上下文要用的bean工厂，这里会设置beanFactory忽略的依赖接口(例如一下Aware接口)，注册一些bean工厂依赖的bean(<code>BeanFactory</code>、<code>ApplicationContext</code>、<code>ApplicationEventPublisher</code>、<code>ResourceLoader</code>等)，以及一些默认的bean。同时也添加了两个后置处理器：<code>ApplicationContextAwareProcessor</code>、<code>ApplicationListenerDetector</code>，设置了bean解析式等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">		<span class="comment">/** 告诉内部bean工厂使用上下文的类加载器等 */</span></span><br><span class="line">		beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">		beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">		<span class="comment">/** 添加一个后置处理器：ApplicationContextAwareProcessor，这个后置处理器实现了BeanPostProcessor接口 */</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以下接口忽略自动装配。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">		<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">		<span class="comment">/** 为beanFactory注册解析依赖的bean */</span></span><br><span class="line">		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">		beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">		<span class="comment">/** 为bean工厂注册一个早期的后置处理器，这个后置处理器是一个监听器（ApplicationListenerDetector） */</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">		<span class="comment">/** 如果存在LoadTimeWeaver，就将其注册为LoadTimeWeaverAwareProcessor后置处理器 */</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">			<span class="comment">/** 设置一个临时的类加载器 */</span></span><br><span class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register default environment beans.</span></span><br><span class="line">		<span class="comment">/** 注册默认环境的bean */</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要做了如下操作：</p>
<ol>
<li>设置了类加载器</li>
<li>设置<code>bean</code>表达式解析器</li>
<li>添加属性编辑器的支持</li>
<li>添加一个后置处理器：<code>ApplicationContextAwareProcessor</code>，此后置处理器实现了<code>BeanPostProcessor</code>接口</li>
<li>设置了一些忽略自动装配的接口</li>
<li>设置了一些允许自动装配的接口，并且进行了赋值操作</li>
<li>在容器中还没有XXX的bean的时候，为我们注册了<code>beanName</code>为XXX的singleton bean</li>
</ol>
</blockquote>
<h2 id="四、postProcessBeanFactory-beanFactory"><a href="#四、postProcessBeanFactory-beanFactory" class="headerlink" title="四、postProcessBeanFactory(beanFactory)"></a>四、<code>postProcessBeanFactory(beanFactory)</code></h2><p>这里的这个方法是空方法，spring没有去实现，主要是提供给要实现<code>BeanPostProcessor</code>的第三方框架使用的，如果要整合spring，那么就会要实现<code>postProcessBeanFactory()</code>方法。主要是在spring的<code>BeanFactory</code>准备工作完成之后做一些额外的定制化处理，一般会结合<code>BeanPostProcessor</code>接口实现类来使用，在该方法中还要设置一些忽略的自动装配类。例如<code>AbstractRefreshableWebApplicationContext</code>类中就实现了这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ServletContextAwareProcessor(<span class="keyword">this</span>.servletContext, <span class="keyword">this</span>.servletConfig));</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class="line"></span><br><span class="line">  WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">  WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="keyword">this</span>.servletContext, <span class="keyword">this</span>.servletConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述<code>AbstractRefreshableWebApplicationContext</code>类中的<code>postProcessBeanFactory()</code>方法中添加了一个<code>ServletContextAwareProcessor</code>后置处理器，那么在这个后置处理器中的<code>postProcessBeforeInitialization()</code>方法肯定也会有实现。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getServletContext() != <span class="keyword">null</span> &amp;&amp; bean <span class="keyword">instanceof</span> ServletContextAware) &#123;</span><br><span class="line">    ((ServletContextAware) bean).setServletContext(getServletContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getServletConfig() != <span class="keyword">null</span> &amp;&amp; bean <span class="keyword">instanceof</span> ServletConfigAware) &#123;</span><br><span class="line">    ((ServletConfigAware) bean).setServletConfig(getServletConfig());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、invokeBeanFactoryPostProcessors-beanFactory"><a href="#五、invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="五、invokeBeanFactoryPostProcessors(beanFactory)"></a>五、<code>invokeBeanFactoryPostProcessors(beanFactory)</code></h2><p>这里spring会实例化并调用所有已经注册的<code>BeanFactoryPostProcessor</code>，同时这里也会解析<code>@Import</code>、<code>@Component</code>等注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值</span></span><br><span class="line"><span class="comment">	 * 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里首先会通过<code>getBeanFactoryPostProcessors()</code>拿到当前应用上下文<code>beanFactoryPostProcessors</code>变量中的值，然后调用<code>invokeBeanFactoryPostProcessors()</code>实例化并调用所有已经注册的<code>BeanFactoryPostProcessor</code>。具体<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code>方法中的执行逻辑在之后的博文中详细讲解，因为这个方法中调用链比较深。这里只是简单了解大概流程。</p>
</blockquote>
<h2 id="六、registerBeanPostProcessors-beanFactory"><a href="#六、registerBeanPostProcessors-beanFactory" class="headerlink" title="六、registerBeanPostProcessors(beanFactory)"></a>六、<code>registerBeanPostProcessors(beanFactory)</code></h2><p>这里会注册BeanPostProcessors后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续进入到<code>PostProcessorRegistrationDelegate.registerBeanPostProcessors()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">	<span class="comment">/** 注册一个BeanPostProcessorChecker 当bean在BeanPostProcessor被实例化创建时期间，</span></span><br><span class="line"><span class="comment">	 * 即当有一个bean不符合所有BeanPostProcessors处理的条件时，会记录消息日志*/</span></span><br><span class="line">	<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">	<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">	<span class="comment">/** 将实现PriorityOrdered接口，Ordered接口和其他接口的BeanPostProcessors分离开来 */</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			priorityOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	<span class="comment">/** 首先，注册实现了PriorityOrdered接口的BeanProcessors */</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">	<span class="comment">/** 接下来，注册实现Ordered接口的BeanPostProcessors */</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		orderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">	<span class="comment">/** 注册剩余其他的BeanPostProcessors */</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		nonOrderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">	<span class="comment">/** 最后，再注册所有的内部BeanPostProcessors */</span></span><br><span class="line">	sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">	<span class="comment">/** 重新注册后处理器以将内部 bean 注册为 ApplicationListeners，将其移动到处理器链的末尾（用于获取代理等） */</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>先注册了一个<code>BeanPostProcessorChecker</code>后置处理器，该后置处理器的主要作用是，当bean在<code>BeanPostProcessor</code>被实例化创建时，会记录消息日志，</p>
</li>
<li><p>将实现了<code>PriorityOrdered</code>接口、<code>Ordered</code>接口和其他接口的<code>BeanPostProcessors</code>分离出来，用<code>priorityOrderedPostProcessors</code>集合来保存实现了<code>PriorityOrdered</code>接口的bean，将实现了<code>Ordered</code>接口的类名字保存到<code>orderedPostProcessorNames</code>缓存中，bean类型为<code>MergedBeanDefinitionPostProcessor</code>的bean保存到<code>internalPostProcessors</code>缓存中，除此之外的其他接口，将接口名保存到<code>nonOrderedPostProcessorNames</code>缓存中。</p>
</li>
<li><p>对所有实现了<code>PriorityOrdered</code>接口进行排序，将<code>priorityOrderedPostProcessors</code>缓存进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<p>然后将排好序的<code>priorityOrderedPostProcessors</code>缓存中的所有<code>BeanPostProcessor</code>进行注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 遍历postProcessors */</span></span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    <span class="comment">/** 将postProcessor添加到BeanFactory的beanPostProcessors缓存中 */</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对实现<code>Ordered</code>接口的所有类即<code>orderedPostProcessors</code>缓存进行排序，并进行注册，过程同第3步。</p>
</li>
<li><p>最后再对剩余的其他<code>BeanPostProcessor</code>即<code>internalPostProcessors</code>缓存中的bean进行排序和注册；过程同第3步。</p>
</li>
<li><p>注册了一个后置处理器<code>ApplicationListenerDetector</code>。</p>
</li>
</ol>
<h2 id="七、initMessageSource"><a href="#七、initMessageSource" class="headerlink" title="七、initMessageSource()"></a>七、<code>initMessageSource()</code></h2><p>这个方法中主要是初始化了一些国际化资源，和主流程相关不大，暂且不对<code>initMessageSource()</code>方法中的代码展开阅读，知道其大致功能就好。</p>
<h2 id="八、initApplicationEventMulticaster"><a href="#八、initApplicationEventMulticaster" class="headerlink" title="八、initApplicationEventMulticaster()"></a>八、<code>initApplicationEventMulticaster()</code></h2><p>初始化了事件多播器，容器是使用自定义的广播器还是默认的事件广播器都是在这个方法中进行处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用户可以在配置文件中为容器定义一个自定义的事件广播器，只要实现了ApplicationEventMulticaster接口就可以，</span></span><br><span class="line"><span class="comment">	 * Spring会通过反射机制将其注册成容器的事件广播器，如果灭有找到匹配的外部事件广播器，Spring自动使用默认的</span></span><br><span class="line"><span class="comment">	 * SimpleApplicationEventMulticaster作为事件广播器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">					<span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听器大致执行流程如下</p>
<p><img src="/archives/cdd5d4ba/image-20210824172318052.png" alt="监听器流程"></p>
<h2 id="九、onRefresh"><a href="#九、onRefresh" class="headerlink" title="九、onRefresh()"></a>九、<code>onRefresh()</code></h2><p>这个方法是一个空方法，没有任何实现，只是spring用来做扩展使用的，当容器刷新的时候可以重写这个方法，自定义业务逻辑代码；因为不同的spring容器可能会有不同的实现。</p>
<h2 id="十、registerListeners"><a href="#十、registerListeners" class="headerlink" title="十、registerListeners()"></a>十、<code>registerListeners()</code></h2><p>这个方法中注册了事件监听器，并且通过调用<code>ApplicationEventMulticaster</code>中的<code>multicastEvent</code>发布了早期事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">		<span class="comment">/** 首先，注册指定的静态监听器 */</span></span><br><span class="line">		<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">			getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">		<span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">		<span class="comment">/** 不在这里初始化FactoryBeans，需要让所有的常规bean处于未初始化的状态，让后置处理器去初始化他们 */</span></span><br><span class="line">		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">		<span class="comment">/** 使用注册好的多播器发布早期应用事件 */</span></span><br><span class="line">		Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">				<span class="comment">/** 调用ApplicationEventMulticaster中的multicastEvent发布事件 */</span></span><br><span class="line">				getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h2 id="十一、finishBeanFactoryInitialization-beanFactory"><a href="#十一、finishBeanFactoryInitialization-beanFactory" class="headerlink" title="十一、finishBeanFactoryInitialization(beanFactory)"></a>十一、<code>finishBeanFactoryInitialization(beanFactory)</code></h2><p>实例化所有剩余的单例Bean(非懒加载的bean)，比如：在<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法中根据各种注解解析出来的类(实现了<code>BeanFactoryPostProcessor</code>接口的bean、实现了<code>BeanPostProcessor</code>接口的bean)，在这个时候才会被初始化，在实例的过程中各种<code>BeanPostProcessor</code>才开始起作用。**<code>BeanPostProcessor</code>的触发也是在这个方法中**</p>
<p>大致看一下<code>finishBeanFactoryInitialization()</code>中的代码，具体逻辑在另外博文中具体详谈，这里调用链比较深，先了解一下大概即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">		<span class="comment">/** 初始化上下文属性转换器 */</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register a default embedded value resolver if no BeanFactoryPostProcessor</span></span><br><span class="line">		<span class="comment">// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">		<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">		<span class="comment">/** 如果在此之前没有注册过BeanFactoryPostProcessor后置处理器(像PropertySourcesPlaceholderConfigurer bean)，</span></span><br><span class="line"><span class="comment">		 * 则注册一个默认的嵌入值解析器，主要来解析注解属性值 */</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">			beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">		<span class="comment">/** 初始化 LoadTimeWeaverAware bean，目的是为了后面注册他们的转换器 */</span></span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">		<span class="comment">/** 停止使用临时的 ClassLoader来进行类型匹配 */</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">		<span class="comment">/** 冻结所有的bean定义， 说明注册的bean定义将不能被修改或任何进一步的处理 */</span></span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">		<span class="comment">/** 实例化剩余的单例Bean */</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>finishBeanFactoryInitialization()</code>方法中主要做了一下几步操作：</p>
<ol>
<li>初始化上下文属性转换器</li>
<li>注册属性解析器</li>
<li>初始化Aware的bean</li>
<li>冻结所有的bean定义，此时，注册的所有bean定义将不能被修改或任何的进一步操作</li>
<li>实例化剩余的单例Bean。<strong>这一步比较重要，会另外在写 博文单独解析这个方法</strong></li>
</ol>
</blockquote>
<h2 id="十二、finishRefresh"><a href="#十二、finishRefresh" class="headerlink" title="十二、finishRefresh()"></a>十二、<code>finishRefresh()</code></h2><p>最后发布相应的事件，在这方法中也会清除上下文资源缓存，初始化上下文周期处理器，并刷新。最后会发布<code>ContextRefreshedEvent</code>事件告诉对应的<code>ApplicationListener</code>进行相应的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">	<span class="comment">/** 清除上下文资源缓存（如扫描中的ASM元数据） */</span></span><br><span class="line">	clearResourceCaches();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">	<span class="comment">/** 为上下文初始化晟敏周期处理器 */</span></span><br><span class="line">	initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">	<span class="comment">/** 首先，将刷新完毕的事件传到生命周期处理器（触发isAutoStartup）方法返回true的SmartLifecycle的start()方法 */</span></span><br><span class="line">	getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Publish the final event.</span></span><br><span class="line">	<span class="comment">/** 推送上下刷新完毕事件到相应的监听器 */</span></span><br><span class="line">	publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">	LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理之invokeBeanFactoryPostProcessor详解</title>
    <url>/archives/e74be873/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前几篇的<code>Spring-IOC</code>原理系列博文中已经介绍了一下<code>Spring-IOC</code>大致流程。也大致了解了其中的流程，这次我们就来详细解读一下<code>refresh()</code>方法中的<code>invokeBeanFactoryPostProcessors()</code>方法。该方法会实例化和调用所有的<code>BeanFactoryPostProcessor</code>(包括其子类<code>BeanDefinitionRegistryPostProcess</code>)，所以该方法是很重要的。<a href="https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.drawio#R7F1Zc6rKFv4t9yFVOadqW8zDIzhkTkzM%2FHIKFZXEKYBG8%2BtvDzQC3SgmoMbt3vveo4DQdK9e8%2FrWkVgezE5ca9y7GrXt%2FpHAtWdHYuVIEBRRl8B%2F4JE5PiJqko6PdF2njY%2FxiwMN58sODnLB0YnTtr3Yhf5o1PedcfxgazQc2i0%2Fdsxy3dFn%2FLLOqB9%2F6tjq2tSBRsvq00efnLbfw0c1QV0cP7Wdbo88mVeC92tarfeuO5oMg%2BcdCWKFg3%2Fx6YFF7hUc8HpWe%2FQZOSRWj8SyOxr5%2BNNgVrb7cHLJtNXvW6dPD7MH606o3jvK%2FWl3PPyDb1Zb5yfhG7r20P%2F%2Brc8%2FX3ri08vl1%2Bir%2F2DOLX4y%2ByNIwc2nVn9ik3lQ%2BuAxZmcEngbXrT9y0RnlYwLf1QQTxaE%2F0UNKF%2F23qh2ZtSNdP6oqR7p2ZNSOqtKRqR1pHDpSOTL4o6p8pIEjCjoioWtqR2b5SCvDUyaHTulHGrisclRVj0zwqyr8oBtHmtTqW54Hf2qKR4aGbqaAn5q2NYRfwJXgMvhQcAew0hx5HTAz%2BI3wSMujYcfpTlzLd0bDMrxnfeT5dXfUsj0PvDBecn9OyAys%2Fhh%2B9Jxht28bkHDBXT57jm83xlYLnvoEOwwc6%2FmDPvjGg4%2BIvglVciVRjv9RySXBruJKnKJxsUuCdQguAG%2BDv5fDRRFrNbQUoun57ujdjpwJFomcIeMAhGt2Xavt2Iv7DEdDcH9zaru%2BA7aW0Xe6Q3B44LTbcALMjtPvx%2B5cA3%2Fg6IML%2B3YHz3EmQiU0B55mzyK7OCDcE3s0sH13Di4Jzv4RlGATzgnzkWR84HOx53lEkvBgL7Lh9eCYFfCZbnj3xWYBH4L9ssbe4WUxde%2BMXTtGPmSfLHjOn2BfGYhERaEJ%2Fx6hBV5suuCkpTfVlhKehATwp2MNnP6cXKJYA0h6wVPebL%2FpWs7Qg2xsNBwlz8fv5CHagvfRS9rYZ2zq4KW8MdhirLeKj7bVUjVRoG8znjT7TgvO1wjMa2xj4jt%2F62mdTktR2vTTXLvreL7tpjzluGJ3bNe122eD8cj1G3YfyKaRewqkD%2FwN146d%2Fgc%2BSw2H1nQXg%2BXwP8RBwnnGTxRrkbf84eTZM98etr30aTsBVDUOB0AG18VHOfTExEuVurYff%2FvjfxbH0P2O%2F8lp%2BJF1jU5eHgSQ%2BkiyNCmPYRMAem3A4snc4Y94%2BnIamN9zvJQxldZ8hK6pimXRjyBDT31OazQYT3z7rGM0PcCrj5dQNv3vmFDV%2F3Kdl%2BEE8dw0qkC7aUHPBmuT5kQ45S3SKv2P%2BeB3G4rHP9SGz2st7M%2Fv7pzjlmtbvo35x5rDaYqa3pJT6DllNP%2F8s8dMimzkktVuHxdE7lt86w2wwhal59upjwQs8ZiWkbSlgOXkle1bbcu38hOSv4HxZJufrRCnWomcQRo4uT5hywGrAx5fYbxF7C5eOKLsrtC6KsroESSZjxk9msRRNo%2Bs6rTJw6t52Dysl9AYFk9icu12124EXwGF9Ebd0dDqVxdHzcXRy9FoHMw2sFn8eTDd1sQfxdeCtmDXm3VvNHFb9pLrgvfwLRdQ9JLrAq8SfMmla%2BjafbAfpnEfVe7LIaQaoM3kZgm8OfRGTNiAgjye0fvQtTuu7fUWrC7hTYkcbqZuuxX7jV7jhNdB12s1XS9wx%2F3RtZIqx%2FbcH01lbDpOKMmMbacpBa0z8bXu375TM%2B47faf2nfpNp2mrFXeart6OvMDajtQuB2ac71ot3xiP%2B04LS2JwIyjnmDszZROLtLB1hlNAAdC7WrOgmj%2BPuUm91Rp%2BurcKPE%2BUjpa4q8gFR8v9VcFJtm%2FN7TaPBVlGzy0j%2Fhb7%2FE%2F65C5bSgX9oX%2FbXMzTak6Zrs8Flk3qtTkz1lotcOcWxVgJ%2FyLeW5nmqYLG4KhyUXoML%2B8rQ9UzMlRe2imOqufEUVP4Y4xp3SHXMLZXKnbf7lq%2BvSk2ufhFjFWUwWKl%2FxiaU798ywsM22XDW56OdC6fdIbhWVWONBMGOHEI0%2BRQwLJypIvoiI4CluCIAeOaMGApoRAljoAa5AO6jw5upTbTno5uV4MRVBgIVeFn%2FGOjEgZC0TUcDJz%2BOuIQ9QR1iHQ0L6SEKHUohVEHy5RKCoRhO4j7VlAQ2mmhybRcnz68dLrtmeM%2FB2fh55cjGPuVg28VOEkc%2BTInX4bgNZ%2BjXyK%2Fgl8XP0PfyO%2B2JV74jOIlZlals4PMUih4Qn3kILFBCC7BjiQuQUj4xYNfLWiJvlEiEC0m%2BRWeGepGiCjD1%2F6Bxb%2B3liCf1RTkd8sWlBiqZNbsFHAEcEKtGslyAddIiLmr6JSCrtHhvVjLfGk17X58oUhKRgssiw0YenpSh2sDU8pqovtBVjGGRIumRzaP5Er2JQ6JMikAwqyv4ClH0cwplmDgSrwk%2FmzHE8eNkNiYo07HswvZk5K0ek8GEawfidO1ZzPB9ESR1sFCxhhluuEP8xez9FR1liRbTQb9mmsN7NXO%2Buw6DTx%2BA%2B7j%2BHBa%2BHVc%2BOFCr1Z0tjjFCjXFOBcG6JhhdhvOszN5Vpoe1jMNyLIqdscZOtBOuiO3iCXJLfL20E9xAh%2FQ6k2FMDvE2gCDM%2FGNDcTRko9alYsH1e7qkSEHWrEhUgSzaY13DUqYxRWZUAGhtmKYaLoZhZf2YdJkwrJ0x4ulYZPIMbnP9q3W9ZdJii8Tz2CZ4TWbWadfF3Ijk75a41Oyany7FXWTaA67G%2FL%2BjyxnkPgkqhwlX2APlQRR43Q5%2BP%2BiqJnl59s2k1BS5n%2B5VM80jVJB8yjQzqwVQrT0Zk2t3Oe6LBrmOm6G7841g%2BOKQkkpaoeLtJUN1NRj6K67huooSUBsWcO207Z8Gx71aHlXgB4bzjiZHyCj4C3IzIjFrAapF5JLIi%2FzgqrIuqxK8Vg5WJOSIkb%2F0rJT1EuiwqucgO%2Bh0OvKS3qJ0xd%2FC1tjWrDSW%2BjBd%2FoeUw1q9ezWO%2F2DMqEItvfY4KA3F2jLBlaJgdlvAvMeuwcCVbwG82CZ9S9AXzfDEhst%2FMEloKjF6V%2B0xYOzOl8C67z4o8apStNKJLEiWuyha4BMaPKR5VJhJEOEVYRkxpi%2FYkKI68NegYpw8YuixTUJVsSWZddKRenBAl1s0%2FBdmJ6PnVVJZnxEsvbJIpSCaM9igdB17DiPhmxWlYRhlEjAR0FxHlzOBmxfvbnUtYfiQUblCBD1wlhGZW9mNTCWoV2rwlM4igQv1hbRnl9POUwTikU6hUX%2BhAz%2BuR0zoYJJX522GLzJShOKbJ%2BVJlT%2BcnaPZ1%2FMOPtkCxQ6%2B5XPpvvB6e9fb3PPfPNeHj9t8w8rXLTVEsW8kr6SKR9X1qL6Db1fIB1yTM1PS4m%2Fab7BwvZkKQ6uPAjl0CAoF4ByyBgORz5SGg0fDLM58e0MmXSJWplmUxZ0eqgxnTSn4oq0aWkFVY%2FMZ4D3hBJ2S8UA%2BTzS6aQv%2B3G4wButgyNkRnZL4iv3P3M06gOd5LsFNLFdh38Dr3B8C1XvJkdbMy4b1TQSsD8mVt8LJgoSxLpErliaKjOIfHEEKOCzOdTrrmwgIWCFbOTa1HqxFdW8645S0FWcVrrW1IGB%2Ffvv0pUuYBCZGXQLSD8H1UKjYkCKO9PQDwS7YZOvw0rA3Z%2F5TNoUJPNrmzNcvrmunZ083Bn3ZzfX%2F5UvjUbjP%2BP%2B%2Fu7MfLhPYwS%2FcOpNHgUvFWjqGSrLd4MsNNPY6mJ0kKzYjzlXYJILhoeBdnJtqxMbqcX87fOKCTaaY4QC%2FjicniTzMCFJQh4JzHwqKOWVpLNulfmcXDrNfVkYCbprDTGW6gXdTpj1C2hh0F4ATAZnDJt6kFqmywt3UkEq8dbnZ3Ut8mZobp9UtAg6FxBnpsriDuHOl6G8g7QXZvCEmec4biEisqxCP%2BjiGg3yFMjGaxEOogWhDHB%2FeAp5UjUxkiKP0h7xQ8EpHSUmGeVAHABuBSk%2FvHM4DPR0%2BAF5ZA2OjLmCTqFbLbyuOnyiWSFJREbsTYNcJeSW1dAGBD%2FRGblKrPFE0Mt0gWRBVdAmDW9ISbdqBBcNr0XqRm4708wUt7REDjmP%2F3jYewxPD0fuwOoXs%2Fk2VviX%2Ba3gTv4X%2BtOWvxE4zJjxLakhyxehiQMaJc%2F2Q0%2FSujb2Nw3%2FDdgB3%2FLGbe%2Ftaw%2BXlymD2jIeBn3tT%2BHI%2Bh70Hu%2Bge0wtw38ZnpZ1pR0vHuVPBviTr038vAc306bsmS3rhweHyA45RPpO6s78dXNOq4yRdPvAgk9TK022kg1U9liJKq340nZmqCWj%2B%2Bg1RAMaNFkXWntUOY7fcMuWW6jrbck8Pih0v1ihuzxLffE9VehSn5yjGpM2BNf2Jy68QceCg%2FnexGRDfqOyRBI42NGcqeBQAuk6taiSlZ%2BVMe9kfbwqXkqU%2BMkiX9IEKt9KFVglaCQrJf8CiQ1l%2BJA6elIsn6WOnlGNvyjrD9YaHKk58JXRL9qW17PbwSPXW8qVGUQkCTmaQbQsjye%2FChh2efsfJVHfrkhKSSNoOT%2BucX%2FwbJdky3B9XLu8SAjrO8N3%2FL3n%2B7B7hIHkd23q2J%2B2W2o7Vte1Bl5pCMt4wTNr4aw1%2Bxb4KdGpeoDG%2BwGdQ4zGTic8ZbcdePS%2F%2BA%2F61tx2PbTC5NDQmsa%2B%2B46PaPfsBryTDNQcQdbA8GSgA4OvYBVlYIsE%2Fwf0I%2FAJXcLDryq8Dl6imaW2a306I8AF79Q7ftySPUm%2F7HimYDW%2BvPvKy72pmVedm1fnRR8PBoJq2TdvJ09Nc3T13DpTdd3yhs7jzbw7u%2B402tfCybhSBa8hC7Xbm%2BnDdd0ZXHLyp%2FZcfnSv6t7r22n5Q7kZyrdvp9c1Xnx%2B5Frv9YvT%2Fvv564d%2F8jF7H3Tv3p77L0%2FPRgfd5eVRGWn%2Bef%2Fq6nXsPlWfZkL16fLmo9bpzWrClf7x2uidS1Nf8bj3Fj%2F026Py%2B1P5Q9ZrZx99UbqeXQ9u%2Br4vQQqT4dKB%2Fzv5fG486crstfIxeR2pn7Mh967cwlNmXZr2z98rZuNtqN3NZmN1UBG5ljF9nU8NdAfzXtAnp%2FWbzoBH93qVb9SPu9kXOlebf9VPLiu987H28MD1Pvsn3PP1RWdyevvxfIqffTG6aEnPref7vnEKOOOzd3uPfnpz7tW4gWV4zsU1OuBcX3INeTZ4li9fZsK7da65xuP13JS6X92GOOnaJy66bmw%2F9mrn4lvjzqhpN%2F3nuiE2Lk%2F7XudENO8U6fzlZt6Teu7Fy0VP6rSeJ9x8fOrdvWtvanuGbjAau9r8Qxx%2FzrxZ%2B3H0wl%2F0Dac7L0%2B01l33%2Fk1xxkJfU84eawPu7eEKvcT5%2FGHiNs8eempj%2BGjdvj30p4I4ejjl3r8aNfH9hZue3H7NxVoLPaBiXs3uT%2BXzeaNuN707uTcwXvS74Xm1czruo%2Ft1at7n2aDaa87OT09eW5Z76%2FlCpd67urpRh58Pr9O%2B1D3l3InzUm54%2FXeholT9jvlRfbnXbsp3F70L4Wo%2BsB30tGfxrvFx12%2BeaRPOPrEfW6Op9mCdvPW7XycnnerN%2BQw90%2Fw46z6%2Fqt3L0yttdnZvjt99GyxSU1IGpzO8tH6jOn2YXMr%2B47hd6fZeepfosHprPD%2BfSbZtXk27p5X258OFdF97xSd77vCk8WWb49MLc%2F4wfpQal8rVzPxwjA%2F18vrx7nN6U8bPl%2BYzVT65q87n80lVGnevn4faw7Mol1uG8jqVFXQ7r2x6audU8b3noXH3rr699XqNM%2FQoszV9f%2BvKdUF2Hqzm7KpzOR%2BcPuJfXcl3V9r9WOqUq%2Bbrhdx%2FMxqnr6Ygf%2BBNcPOk2PPzhuwO5Bu95788a5J55nev7%2BZvnx%2BN3nt5fGf17XHFfZOv77uvTvPy9b4yenq64ztu%2F%2FpkgG5SPX259tSXW925vRw1%2BNfyBd92X%2BqAbZ%2Fjp5RnU39wL4v9k9m0PJjXT67F18Hb46Aj%2BVeXvtA6UevD1%2BqjImoPd%2Fr0TvvUTd2pP4t2Qx5Nns%2BflOG7ZD0NJFEH06I%2BNc%2Bqp1Z3%2FtTvnmuvM2t6P%2FNOn2aW%2FPw%2BuWtJ8oVcaZwP1at6761rtQZv1kP75O0cML9W5XzqOebVDRqUhAjYVG3H0Men3H33ZfT5VdEGTu31pmlflGv1B9FxpuPP62lP%2F%2FrSZ19K7%2FpDql6Xy8%2FP9ufl5KvW8VsXtVO5y3mtOrrZuTZw766lx7On1sXYHr0Lmtj5%2BHi%2Bd16mbyZ3YgqmYStzs8nNpvrZGxrG81ur3HgyGuiLIbRv%2FMfpo2u%2FPDgPt9e1iefcSqbYFe5Pe8ZYOGlWXxuYO02EHv%2FMnwws%2Fv2kPn04HSmSXbutVF%2FwncST0fvL7ePp%2B5lVvahwdv2y7JvOU3N2cvV%2B2XG6yoV21vpyLm6%2F3CdLrF5w3avLO9%2B5epRGUq%2FV%2B2o%2BNar65NHyLzTMz2655vNA8DtijW%2B0B486nsTbhuG9dieti6%2B6dXqHWF%2BNm%2FT4h17l46M9BtQ%2B%2FvLUq8%2Bbp17IdM0bQ1I%2Fbq6kR%2Bf65mVqCdX58NWbNq99271X%2FJZ0MX1ym3fdjn3%2FPHg4nZRPa62HcxO%2F1s3oaoSFwUWjVrbbZmcm9Z%2Fk3q1abZp8xxv0evpo4N52Ze7Mu%2Fo4eT45uTf1rnVRnlXH08br88eDWuYF%2FlTTnsGOO7uZXt1xnZcT3j6zPm4NdVQfozE22qP%2BSeeu8nL9JvPdk1G75z1cCXOjVeabH%2FcXvapqVJyRcOm41ol4OxSuLm4r18Lpw%2Bnbw9lpxb1qq4%2BtB216wonz0cfsDN3TP%2B2c4Gl4cR%2BufPezdz2o3896yqsIxIzD%2Be81U206Tnf6PtG0qXAJqHzkTE4GzYFl8h%2FWq9F6A6RaG2m3L63KyyUQVWXu1RkFrPVEUl11cK58Nowz3jytKKZ7h57GfymS3rPfHkz%2Fo%2FNVexxd3p623p4718a99XHasMr26Yv9aBrNl5fGSXWuv79NzdnEerwY6rzePTNO5mj8NUd6vHq7OEef6x%2BXJ%2Fc9vODOuWOrwntdEYft67H%2B3m6XX40P37XvzS4amz7uf35WJNG9v%2FR7T2WOP%2BspV63H6nWnenJzfaE8%2B3xDRbdq80%2FufFQdOi91v41%2BO32eDOfVG6BpS86p3DIaY336cMO9ifO2WBteDNVO%2F%2FKkfyM%2B3gqVmY1%2B0rzS2vywNuvNuv6nXr26u5eeusKL1OmI7vjpq%2FOCRZf7amu3c%2BHqzp2%2FVdWB3Ze9vt%2B7kJ8E7kV6%2BJp8jJ1pvVVzxYF4MvY5Ra5fSC%2B%2BI508cHZfbJ%2BbL%2BhpboPvz2%2FeP98671gtePnA2oFd%2FZxf3DdGn%2Fc%2BOmCoTzcvptzuX3VeDTSCZs9Whx%2BKd8Z5r9WrT1V8ejuvTy%2Fkt%2BdZ7Z5r6%2BNae3j%2FOlEHZ1%2FK2cPwvmIPT%2B9HrSune%2FZ615nYhm4IsmqUn7EYmSnDZ6H1dVVvvV8MhOFNfVC3JoNG%2FaqlS%2B83D29a%2BeNJ94zX0d1QfLmovgAC7E8vWj3%2Fpnp9f%2F%2FsfgE17KxaRkNDmkfNeqnPv%2B6u6m%2BqPnUxs598IaIyyx2l83Y9f6288%2FfW%2BNq5PZnZ5VrDGV73rfNG5bHdcj74Sf1hLD0OuIfH%2B%2Buh9ea%2FuhfWi%2FDl39tvJ6en5Wvv%2FqJ1bU1H%2FGl13n9znecxJ83kq9r84u39pnz%2B2b95lS8%2By%2BN%2B9XxYf259fs2em%2B8fN8P3u%2FLoenxXk%2FWuo32evfFGwy6%2FcTcPj5pgaGPHmr%2FV7viXgdTW1bng3dofDv85uZHtviqNPl%2BG3blzozoC%2FzRTpo36iO98nZ8L1ZfrM12R%2Bbv78zOlBUR76%2F6aexSFadv2K3zn0Zopqgru9z6anVQG9489IPgHVvXr%2FfSsLTmj7qN5LVtX4qnybN9%2FNBSszPlXb5ihzG5lx64L6PP7401z3p%2BL1lXjpn0iNzqX92rrEesi71%2FV4fBG0p74y8HTO98dc42L1%2FqrU5ncX733nz5vJs%2FeQL68uPdfRlg9vOoNm5hJY6IS7sSLu9mrNsC69407e8Dq4Vur%2Bm6NT7sn7wOvI7dm%2Ffv7d5GTxpqna%2BfdycQYzxylXJcw%2FTpX%2Ffajcv58flJvax8XXs2sy0DXvEOka8rvnHddC2SAVx9d%2BR%2FX1d5d9cIatGZ81bu%2BeKu8TKrV7s0dp1Yfnypv7U7tTWp0W77J1fvtV%2B799r5Tfx13vYeG1W4OpeZUF2aVmlJ17bF%2BfTa4m95%2BWvXHZ8nGLPPVxSrNJd7kt60PoF053Jdz2rDPrt4eT05uRne6WHYuroTx9cR8f5UHzqvUuXv%2FVE5u7pzr%2B7bW6PFvr5%2BPo7nkzZ84LEhvJX6EWei88omeMLp%2Fx3LqXmzXeqejFzyPQKx8iZfPD6%2F3Neseb4%2FbroZF2tVnf%2FrxLnPyk%2F7ofj5Zsl%2B5s%2FkmOqfdGMr5iz9%2FmI3Utgc0wIYpqmZ%2FVD15PKlN396sEeB%2F9ce3mjF965zful%2Bzit91qsKrWD0XvuTbT%2FtxMG%2FcXAD5alTrgwvnrAXsH4v3Hi46xpviNvA6XzQGU0wAzfOGwknX72ODv7v7bAoS2GONid4FUv4ZGA%2Bj2Vn5pX45vvBlp8o%2FDl7uX09kH1FQbXxdbZk2z09NWf%2B8eL27xIzKu6nb9q2K2Uyr6tX1Lxl9OenPWuKzzk%2F7srawquxxZ9LuPE%2F12VRUZdt%2B63QeHa7qzir8V0t4VPzhvTR6mUx611%2BNk8vb6askdodAE3Qe22%2B2bgqtm8rZ%2BMXqnGgVbNlcyrr6OBxMB5PW%2BFQTz56m0%2FIJlm1nyq1yUb780h4fr05Hbu%2Bk9qz1Bnwn4InoIkz%2Fwul8OnBmtmzce3MHG3k3Q%2F3sRVCwisObX2dPX5d3zvjqRb24qIgjt3nVubg%2FqX%2Fevp5Wx6%2Bdp1bPaknm4PnSaM%2B8h0tr9vIgmK%2FPs5enh5rX6bbOurf647X78PD2fH79cv%2F%2BOetU672Z2mrX%2Fdbpa%2BWx%2FIZsk1q3Ntft4blxih7dbfdl8%2BtTa16pTqMHVJyHk25b6ZXHQkN5bQ7mmPV23KvLj5vKs1O%2FHz%2FfXTr9RtOxL8bP9zdvWrf19XzV8AyweE83n7OK1aw13q865vPT5Oada1%2FeVKd3JzePr%2FPRxcODKdbmd%2FPaZIbm0BRbtnE95h4b9bNT58L2h0BV6g8q2u1J88wG2wlopxreEReeU77zlQEWoGgD1U47XWQ91j7dk7eW9IR3y%2FRyoDy9nYy60r1hT2xXUOXP00rv6ux5rPVuTmbPEX3Qtx3%2F0nqq%2BOdSY6hjEe4%2FuZb9%2BiXWW3PuUkTXDj7rQGBylXfHOHP0svV5LZ1%2FcU8NTxwMgLUkTa7nnj55rV3fn1rNJ69cva%2FKz69T56IzeO2dP15JX64hPfDCTPiYnrTuxG73XhA%2F%2FRf1%2FXSqNf2y%2FjKqT5ThZX%2BG%2BerotmnP5blgXVmTk%2Fcb0xvclo3yy6VZN7TZ%2BOTFdG55vAsUbmiMHiWjZ9pD4%2BV93rye9pULNOirLqCi685Z4%2FrlvT9vcu3au8NVXtHPHqVbPIXW%2FfVZpzZSr86mH43%2BXf2hOXYrXUuonzunraeR%2BGyN6jdAYR7e3Fxw%2FlfnVRbfhzWsH70r6kS5fB72zj7Pn%2B%2Frc%2F5jeDat2lPvzuzXHl5dTRbH%2Frh7%2FvWKRXr%2F%2Bfyhcdad3ioj6%2BvFuLr%2FPOuWe27Nv3lqNXz58hkz2eqJj%2FmuezbAK2oECyZE%2FKtMZ2DU9xf4YxmgE84AdU6NOkyTXmsfOlrDowhMsD7yUHE09KqNfH80QP4xcMIM6wIj1cQd9Adcgh5meGPc4RW6TS3ypQM4QptcAr7HnXut9lAsOShXZNi2XdiZDOZfWb4F%2FgOPexB%2B2fJbIyA6ajBuUIN%2Bwv%2B6o9J42GU6dH9Y8fyNthFxn6lEfKhRCBOBdsCTY2v438HXiA%2BV7ZK%2F8aatr%2FrV2eX7zbD730XLFa%2FcPzyrV%2BVGfPQs0NyFgz1vaFHmyzPKdNmTJOTtZc8aRlk27BiwKMoZ16oEdMBUCSxe9UgTIhjRawAYRJBFZJRPa4apHJkwAINsXAKO47G6%2BYaogDT0QTiuJAZCBGguuG9RmAiF413LYb8YElbhaBYBLqN5RB64ckzi2lZV%2Fob5wVIU0pUMIStowmb4QRYowK3gzuklEscMyFtlIs3yJRaFC0ko7vzmS6DmC6J4jccxDK8km9kIilfIcUIULw6GrVeheC0nizVRaTe%2BHDRQdmviwpe7SwKPeiU69wN2wIz0SyBwPhBegJkqggWLjnMXzUCYRWSTCgtHMFBtUPK2RDbp8EZaeHGB%2BDxLZNFPV59AnCaFERPbSd2gLGJAFge4WnYbrpqH2p%2FifZu22gpssKEZRDFKYi%2Blrm38QfFanhCa3UQ6VZgIiQt2UI6kRioqg7qqMBGSphgwhMriyYYU5FoalWWg7wt8ZnQfQ0G5n8KRYQaKnIEzcPkgLRQMQ1P3gSjZsFEbpUpWl7dfpCItXZmVNhPh1quNJmW3lCQGwizccQYqD9RQMXMlMJ1MIdjdWo1u2RAaNmm9GyJteLI3cVhStYvvrNdSwNl1UpeIuwylDjcsvITNlUuubbVR0jmaCpx6zgXwQ5jnRe07eO0x%2FN0%2FgQQNyhmXPGwJTqWIMOGFlFc10ZTh7kaoOhNyRyHgagGnJi2WUpDkM5mnFHZ8YqLgw5fMPM5150m19uLVV4HWp2mRYOptNs%2BN9BuGJQG43LGCEplXtSqOs%2BtOpyO0WlRyKzjTVpqKrBxRzYxhN0PUCSGR5vpDSyLdZZbsAKVqDItBZ2St8nkgTDI5x9ZgAr%2FF7xf9oEoyQgAOe0L94Uoct6otFPpWt10HzB3sEvPDXlHsCeUyipDM4ISbESECbajwTEoouPsOYgjBExMNyQWZ3sPlctCQPMVdHyQ3Z1QUhLTWCd%2Fo6cPxXKAkfDc9Od8mPuefLz3x6eXya%2FTVfzDnFj%2BZARrcVqOFrH3mY53mgsVExyK56plZCfsBBfvhWQwhZTG21%2FGBPR5aq2RTxyZYQkQvYLGImN0WLC1jIZdvgp%2F3ouBC9xLpyMXvEA9YSp8MtNRmsgRpeVtaXWe1pV2nC21Kz%2BjIOFK70A4z6MUeRb07H0QR1bjKqLFiKApDZSzMQ8DowrHDGmPOzJx411drd7nXLv1s0eioAKNWOsMuh62n47s8DWXiMyBGGG5ojvptdoF94K1GHkQYsEXYS4axgicsG6EoIquO8bSI7yLFtg7c7JmN6sBXcONCdwOjYduSUs74a%2F1Ks3lTPE8l%2FrtVPE8riueJGXjeVoKQaqLvgM7yKHCMqQr77uXPaugMDhSAjPuJ6DgkEM9bikKiXfOtKKSYnba3uCAsGy9HBW%2BlT3AN9S7LKJICaIlquLptI7MRStKT3Yz9FoLuL3KOIolADH%2F5tyXACipf7u1YYVyHPpPseyXVest%2FoxAhkNB7ZVoEsFpSSnJRu4jVxC87BITbbR5j2AgI%2BhH5hACzIqAdIdwfL4xnNJnH2ehCk9FhqEWTCRKOsaTHbfb9Ggck%2BZU6yuYJN9EfjtXztqgeUuw3YNj3UHEto9gWHcNnYiFp8VwADUbgjRAJlYsTmYFU%2BjB8Fl4cjTwRwFFDQSmcBDZV4uKdPJZF2ugH4Ngbj%2B4yGANeCJY2cvAMHHN9gmVaDvBONTnjrRot3K8O5h%2FgRIQaiqEuuYsKp03TD3vne0yfZ20eVltMtbDNk7nLvWh2Xavt2LGpDCsFCnIbrW0v8ErCYFAYBoPM0k81vbA5Zvgm1lSHkgrPBhWb7M22tzjDrDqI76jaXMCHFsd4liYeGheroZp5hanlZGwwmW5C%2FFC%2F%2Fr4GnUpQCQoURV1fJ7ssR0JTpZKqCQqnKbqsyGF%2BWf5kR4eUN9RQOHt0MSufWMbc02HRwm7FMQ%2BDsI6HIfuyz8LV5cRIY1k9LlIZ8YOwYfpmUqIlhkK6kQBCVqooMhWRrOfq8q0geWB1uUawwDsSaRDptOZDh%2Bn1CjRzYgSh9ky2PiPlveCG0ksJNloSgRY8XGSc%2Bo7TNuPS%2F3TUh9magUPuSCgTYRIUROQq5TclJoqjAF4oKXyMCARWhrnMlVhN6Ysrw6N5BEUBHmDwx0vqHkgRJyxsUFm2d9JDC0z5IE4XcIeIu1aHtQSmEWBE48RorQqDe%2BGRA2nFSYtTSiS%2FbZ5QI2JhOqCNMAquCvN2SVnqF1jyPZe1i%2BanHkWyUxepqOzE1DWXaaVOIGUtT4iZCgwxEBz7IcCqkKiUFJO6JdaGKGxV6kZSEnQg6fj5NkhrNuqStwUo8KtUV4mB78uezt1KkpHoQCnWQRgRE8v1gB6SEj2Ml2CuUDqTnnSqaIa%2BJsW%2FnfBU047vxRGsGSevuLODtT0Iu4SwU0ucEOc8zDw8trArTo9ixSQP7ChFGK6WmtpOsSOZ9pO0R0eqWSqVjtQK2JJ9%2B%2Fh%2FrYXG7HjVwdifH7NNoT1wovFH303TWXvHa3qJk%2BIbXmc4zljeVUq5yY8gGMEohgBJlzap2ShrZeBI7cx5QEhK%2FjS%2Fewzvcrwg9IOlz7L0ky0xMqaJyzkQK7OqgmfkAVbsju26dhtrGw27b8N021Owsn3bLQVBn1Sjn1VfDBUshbjuaoGec6CNpbTBhGHaMG1sq%2Br0V5Wd%2FUztkRnOguU7dUfqzniGe5Cuxk9JuIxaTdHMpqDlcCXoHxfgCUTATRCQyhq2UgPPPzPpZ9EvOowsVFAVfbzBchJqjmZ6ETSDUn9kJaALgmajSNSy4qYHvhfne4xUl8JKp1Ioe1voKvvJ95azs9WML7ObdEOhUxZ1YJaA2rsxsmmaYQr4n3i%2FOaEJ%2Fx6R3OL4SUtvqi3lKJZ4XGjP8qSpAFPowz5U8EDDd51hd52E6u82ViSduIKnk6Z%2BYd9m9DyO9DOGgGsBcAxguGFzSm%2Fd7pTNZlOGGeRLbaaUEZdymha0WdOeAd4ThlGh82ALPR7zeeQONuYmZEZ2S%2BIr9z9zNOoDob7uGn%2Bz32fNuGykNfcs2R8Tq%2B8FEwUJYl0iVyxNlRlEvjgCTLzZHCoxVzYQYW0vdi2z4%2BihoXgmBv2t3tbIiN5mX2Ckw%2B%2FNfKZBpR3atB%2FatKOndJCs2I85p1qwb7e%2FeHlf5hUTbBRWMex6T5N5iMEY%2BjEkBPVYoyAdtsN8Ti6d5r4sDEZCFGPeZwgegVm%2FgBYG7QWTWUOXjoC5H%2FOzUMY2qyElB7JPKlrowcTQyyqLO4Q7X4byDtJeiGkS9UOaqMcEDhGWI9dokKdANl6LcBAtiB6C%2B8NTFEwMjsTgh4JTOkIONcqBOIC1lXrkzuEw0NMD9FQOAdPiMSNcVx3dauG91eETMWYtxFIxYm8a1DxHykijbtVIqTNrPFGsayH4AN43KHTFN6SkW8yJjNYidSO3nWlmimN7SwKSQu7bPx7238LTw5E7sPrFbL7ifUDrvhXcyf%2BidklL3wj2TaJnfEtqyPJFCLLWS57th56kdW3sbxr%2BG7ADvuWN297b1x4uL1MGtRUXmFpJv%2FaH47D7HvQe76B7TC3DfxmelnWlHS%2BehZIsG0q%2BNvHzHtxMm7JntqwfHhwiO%2BQQ6TupO%2FPXzTmtMkbzt2tB3gFbrTTZSjZQ2XE7F4ioIrEUXyZWC9aS0X30EMufi2jtUeU4fsMtW26hrrcl8%2Fig0P1ihe7yLPXF91ShS31yjmpM2hBc25%2B48AYdCw7mexMDzoxhYkMKRodvz%2BBxqqo6iXYXyUYKDiUaeqTnljMypOh8lHxQTQVOiVfBSSqNaacKjHyksGY3%2F4yTLPD%2Fi3SfYHbblteDzY3RkuRTNzlz%2FOfgLvAzqpnEJZTg26JoEn6JNfNg1FryRyuagKzMr1qPAnJEcsiK%2F7%2Bhqk2JECMBEOCTGcFZ6zYXhZrhrZJVEimVm4D0rHnksqA7QPqgQ9ySEDhSWz605A%2FUAME%2F%2FV0EbdkPwAc86FwrTyVW7YcM1TaD%2BHyDxk1Um%2BMQnzSSabpQThWo95m1WNvH1GpFGSqbJnG06hLLsAg8yUhE36cpKAwTJeKXBQPRyEMM5MAGF2gMecqHebm1wNGAdVr8YtCnvLRZVxJtkLq%2FEN4fgYEIGFpECAxa%2BKCl85VSp5lMKI7XbaYVbv1SrMAN9dYCQjKOu6kumitG2KXEgt4kcjj%2F%2BkwaAGs74jVnkbcrAooj0JqE12vaN%2BUTRT1JKPncxFNCppIhp48s8QMyskKljZwB7z43HPZlVQNFsQtek6kKT14mzCEKkMRSyAsr6JaFDAxjDwq6f6RPE%2B6xGl4iK7vaUD03o6zp9y9uaIahDoxS1BIDhpkUXrLNloyMgpClSLT5EQybqfNKEpqNS2K%2FFgxkQzjYzjU04YUExI%2Bi0kxZZDFlgs2T%2F75NL8tZViYfyLDl2LbRavnjNLCZY9LPeIF2F8l4XFgrlWrNeLi8%2F6%2F6XL58aECzq3Z2eV%2B9ixZUF4uLu0QHzY6LC%2F8wmcBySs4s%2BxkwiCGA%2BGYIKoPXzfLGsExJrHScGTQGcFtE261ObdwdEXHjntVG7JqLmg1cBp8p6h9SH3nYG8Bo03iZuKA58v3RgLGO%2Fmh8xGj3mFhVjuM1rYKHjKzZwQyofeNeaeC1LLuEfjV2Hc8u%2BaNRfw1Cy59KiHeWIhKWJVNYuxEC21i0bkA8r8S9msXzuhl9IvTjRoa0RJFoTdxpaDXnrXFmxd2Tc%2B%2FgmqJAyAkpqWV0p%2BamP7AMlZhMXJnsCNYnhvyeJkXT2j0lkWuqAsxENThGIOo7IDnfAZXfbC%2FcXPhiboobVP81XoyrtUc%2FcvMU3%2FtWoTFqEORCi9LBbK80nvhBmtykjEtpyxEAhnSoWh1lV0C3toyyQFTkIEfdI40KApwmULUbU8aSLpdAK8iqoxXe9ZYXKa8XX9IE2hBguXMJUkD%2BMjkX1JqYoNo1az5vwalmFJzK1iBo2MOhHffspd5C53PWWqPrgpHxWVl%2FGqDKt7qeq2ocZ%2FyPsPO8fwewWJYu6s%2FU5zWzIra28XPvXpGiMYfZNsSvJGxYY6aNfraJ95tZCtlSP2YpkKNoifDMzxhKfDjknkL898VxGzVLptWv4zY5cw3CDFZyDTV3R%2F3P1IX03rBZrWF2t9cU7O9hG7nlrH5Ww9TtjQbNCXjtNTB%2Fl1LL96O7q0yNwkwKiYsLAJnRXJJntRQurKu8SgdhiPWJF7gKz1g%2B7Mkrer3RpN9uvDvjY9rMjNihELjnKqhqOmbHCWIRhnrP8uxS3bhrVP%2BLpVUzse0VmGUWFi4YEDDxZhghyOfn50jtbgReMchGC6uLMXRBOVIerMPbheUSGo96Gmso20xBuWUyRda%2FPDWqMFLnEn1UWWjA4mZJPUNCybcyodbkUkx391HE2Q2nJeLulsm3ZIh6oWev56bOWWISFpKfnr2Z1C1eSgOsXjd1i5eU%2BJ2kjKlbeWl2egY7cjuhdDHBBv4w8pvCcHssqlVYP2WiuOXT63dnVJTlhLFWx9ZNLwjtAW%2BP6mkpCiRLW4soHEDFwHuVfAPTDPlkcCnd%2FLyw9f2hV3vdjrxrrC9pvqeXoo1ZdS3bdpTFkqoXtf6MFOX1wmX7rpPltPZ0PgFzrQWlVJiZqjLMVMZaU4jm0TKG72%2Fmn2GMh5tz%2B8ya9FlOqB0MHZtnaVCiUBKLWmESIlt%2FhQHLH4NXnze22wBs55dZZKQjMpdZWOSX57%2FMf3MbQrKEq22jrN5EsmtW2kZEj5YKKwDQWK0v1mPRzCKyw%2F4l%2B5dV48Fk00Vl9mk7EHfc%2Fc1L9uTqzZu1h0Pxm5foc%2Btv3i03rtr5XSuwfPXMXcuX5KKkrp7Fh3nYuFnRDshu2YWN%2B221eUf65u78BuYZvZdSN3BRdRf6QW3OsIHJvly9gXdHbdazebEYGxhhMRy2bdq2zawtFyl397JuNvdtm1VhJntlF7YtKylqLxuebQqvcO%2FAY1dx8K3CQ1Jel%2F2Y9rBXxWYJ6W%2BZXrpjrA67PECgKwlCvQadrTX4bwEHuwvdpJqWZ9cBA7a6ewPbi7t1ke7isIdEooGwtshe2%2BbUO8NWf9K2ayi2ntbF8dfNfqIrzlZm1p7t48yqsJ4QZlxSQHvLAI03M%2BNrIT037EWz1n6mMaaqiLIgc6JFj4fV4DV9gpJ9YyMSykNTAYbCLW6Jk2gefKfvrW7ymXUGrXCctZF7Z49tC2eFpXQ5YE02l%2FgXyeFJphDvHGp0ejfd%2BGIwn7Vuq9UV7XQ3%2FFabeandQdE%2B2E3f60UKuL0QafilQNRSg49k4stHmhFBSzho%2BIVq%2BLgJgwKPQNRXeTcaNEaLifZ37jXYrs0UA4UeYhWHNScRzGGTg4pStEAF2GHwAzYDzAiAQ9iXjxTBbNUwgF2diuyd8a1u6%2F%2BL60Ulx6sOxv78%2BJ%2FoIqc0RV%2Btq%2Fwvp1eA1VY5CVTSyIISqIxaLvYDIwVeW9XFGNVh35yLNSn5rnpy1riv3v1nVo3rNB0k9z5daXPUgSuVSt9skyFuDaAJMCgbIcsbfO9VNA7%2BZao36B9337PRcIJWb4Gyx8FNwFn4jez2EYz2%2BD14S0o8c3%2BOkgbQ2HbBVA3AJx%2Fd3cMXOoOB3XbA%2FQBrL4gxpb9u2jwelMtClEu662rYMICuGyAuzq3rPX%2BF3hlvqhDoLKRBmGGS7rkVpB%2Bh5hEG7uXAb9stN7Zczz4ulUr%2F7MvqhIokmd5gwtHCabVYz7htznyq9gG%2FocMQgvZ4b9Yl1P0V6O2HXVSWdEAJTQdcwF4JmpOYWxczu90%2Bb7kgpny8Zqxbzemoj%2BCPE5oH1DSGdjt%2BbeiCzaJd%2FVDf2qpZERFfdcgqU%2B0KzEhbLHlXpBmRlYv8Aq9i%2BvsXo2iu1OPLPbv1vtC44e7hRp3FlgCf2rEdgY0ZawjTejoTF%2FwOfo8bAja2AuCPEckcwSL%2F1sT1nClS4nH%2F6KFtt%2BEDDir9pgdRqN5oiKRrGO5Ui3xdQaMvEzkuIzgtqcIxFKBIOBoKo%2F3zIsWBVn5wO1qDBOX1uH8u0XhMhqYH1HV15NHm0LMUhBsTDpUeD2qOpuPWaRX0gcoxOsjxTe2%2B77le2LoB1yMf8O3ZysFavpfgX%2FwW4ECzXcZsEod68YOhVItfiSXdjet0naHlO8Nu8vR%2BCb7g31KvcGzm0OTlNKAh6v6XFrVce8nDf5mXei%2FXMu3B7M7GRWvVSymLhirJOeOiBVUu%2BimQPByg16amXhAKylHh3oB5MQi09TvUeKZmtfyRO095ZiaXfF7EsVI1zlcPLTbx0AicQEY5CM2neYOg%2FmLCYD1Wf8APoYJWQ6qNRsD2VKiCaVKgsplKXC%2FDQX%2Bg7AjwEcUq66Sq5pesBN3CNqpAKlDzxJ5VXY73zaUi%2BssXwMA5pQZaY6Ti6rWck0uXLEkBDu%2BNrE2qR5vW%2B8OQfRiQSN9bBRuwxU3JGjw18SrYEYQFEtFhGO7cIp1CcQVqLx1A%2BehOyy9jnl0cBM8cw%2FIp8rNErZxvz9BarGgRFq1VDA4lejmnliey6ie%2F37gmH1BUMVHa%2BIeFKaCTNkox8L1kb6X86t9YuNHJysZN9IcmqKhh46%2BwZUBqE7DvAqDm3Yt6dWGklrEwMjOSyGYgUnUhTrDidxFS9SSYxoYBUnnuL6m7%2FxGZ8oTLrKRTnhMyEupm0O%2FDka%2FZIJXjdD1Ta7cyCw89IuyaDGkfhcOHmXU4sY6Jab4CYp%2Fp1U5mlKboqUDBTxJ6Zij%2BlegBul4uF9uFS5ETnENRSoJMSU1BlmkuCKi0VBSEFs%2F9JVA8P%2BIomZF4wg28MwyFAeeRXN7tQGrrYrzDoaDwzB3B6ifM80XuCIGaMhhGWeA1r05MTUdsJpi%2Bk0G%2F5gKjbTXzyg0iJRWk%2ByjssL3MECE3Rqj%2B4WIIa%2FSXXhDjejDem6cAVnfChCT9iViOOZAW%2Bc9U8km8EQ1LSIu0FEa%2BCRfK5wTpbYrOQmGapLOcoHjWIaPgbEL%2Fl0LaiZKZwDJYtcJoLIvB%2BrfLXZ7LLni13RK8%2FEGvynV9%2BV1TrGgoLZwo4R6RGDdyQ3PIL1y3%2FF480N3AF7PtqBCqBBhMFZRFREe0cNSED2IkRhkt4hg8hzjto%2FGY0KgiOUMS17DdqQNWp4rylTQ%2Bhk0fOXhne%2BOR56CwZezaIaCOfh%2B%2B73qCZnW3iahCsmlLbeF0InqpKpdIT92ouGD1S9bEklqcVvKXoB3%2FkKMImSVGViflpjgKA8INZ9Sj%2FRqPOi4CqxJ0nASBOR45V9ARvRLpio5KVkyOMKhgGws060kguJD9noDMIYcbrdHYbtfd0Wx%2BNWovWMmlNT8DXA68S6lU%2Bjl7yKpfRtnGxthDGNJYxRsKg%2F7j%2BYNTOANj4DM7hUkr211hDHy6Uzgfc3SphvJTe7Q9gjda3x7dcT4gi0k1QSlpjC5UTDWhQN8FId649%2Bo4hjcX%2BKwixzx6eX6%2Fp4qPearEIkPigpZowsgKiYuskLhYoFzYS7RfDzBwn%2F4ZOhz5Ye7iQ8osPrKiAucuPurnny898enl8mv01X8w5xY%2FmTE9TTyTDi6tpt2PryRJU2mBWYQNW9N3nWt7zlfg%2FIdrO4YxcPQusnkkV9agCnrlVpD3j2MRXEngRSm2f4MbfTfxgFwy6nRQTVliDddLBWAv6847mGIbNfD9RnfpWhwgY%2FZNmEmzSJ7BuTQctzKbBn5L9ibeBBdJWV4xby7CTmkR9GTTX1mI3yO%2FnJaUN6U1FjYl7yx%2FWrFBf8yf%2FnBhZHQnGNJy2o75L5AHEqd9a7hqUYYpx5ocKftHvk2zGropEBBAGaWH4GtCRygfywhHDpBkTVnS%2FABn2mFpSehD8aIK8V6EyvLSY0mztjDDTaVtGlaqnlRUqxmeZ7U22FlBl66R7oYXRM6sxqrbUmOXj7yw1DjiBUF%2BD2fYpblG3R1NnXbMJbIqYY7pEknjSQX6SIpiGCJPhUs0RnCdafoqfHFuEIHlM9tZpvFT7bhQjqFm5hj6jnEMRsAM1phVYc4pLvvTlYjWEWomYfxUR1qHEKgoAawDrv8L1I8SRv7D5W0w0kr0E2rTw%2BBL3orIDux%2FOZkSrwphDDSqM0gMBqAWyADEDM6vrSQ%2BilqCY4qqyJoxiTVjorhIGy5gw9CeIug7dsOejIHjmBzYR68xr8fzG9ksdQXNrZXfuIWFFmjfkePRzAktOKvAE%2FNMg5T1GpUA5kbDqf8oaL2w%2BOisf9q%2BkxGajB7AymAGm6wBDqtTFVgMrNH7OXNBwC4acD8mKXJWSFhw7LRqlkKWrGbKkeBoH0%2ByWUxiLX9eWrnaJ5RvcWVuCxgXD8D%2BZS2gzlg%2Fobj1kzajPYflk0eL4slFKSW7fHIHNe7lpLBa5yb8ebXOTTbWrujcAp2Lkuy3ddjoRBOUdnGny5vd6fxhp2fc6bkHhH5IKLSB9TMd0qwcVMXtqoq8xC5K3bCuuOt5zvvJXnYsG1pgZUMrqNSBR9XiqKSBRRc7GyZeQe75hInVXcpcSXljRukb9BZUCV5uDbWjPuiJoY81xqUFQWZxaZYXqTg1UWSnkO2EQZiaBXS0PANoH%2Fl%2F5vo6YceCNyIjgAeZhIEQGjWo1hk0Df7FTELZRS6xIc3tO8bkgUt8g0uQXbkzXIJR%2BhT2Y120mQxDvDpEf9UW1iTqKQjtVY%2B03KrEgEkDXExsYGqk8ZAUwMjqVYq8CwzY5mf1qaVkkhfT7uN1BhiRKBcYlxJZwBsH06%2FoTb1jniWRkem1l6ZfSO65mH4S%2BS2B5dx9S1BkZegE7UiG9udK6IQYvLSKPH%2BhdzDszhdiH2BQY4R3DDuxaAFMNXRBBvdJhirK8fYtWhDpXjQ4xk%2BIpzQbC3yfIDsoSaokSWI48m22UIgQmgSvwJ8RFvIqf2VcnnQ6HaHVovRgcKatNBVZoalYAX8QFW88%2BVgStXhARJL5EvHdRpMJmTWVhSmx0q6X0f2aVEIxK34sL0k7JpJYOeg4pIHwoRm4102r9Q4TzIbtP3EIbKEJ%2Fx4RYPP4SUtvqi0lPLka9RyQUNO1HNSbbDAajhjA59F7YU4C76SXtLGfnhe9kbZfu9abab86kdFNwYBchIIwNHCwOaNF%2BjXg1NdK5IgMS3N0ddEmbJtrhCGVFpB5uI2MMR6Dq8kB6APan5aqWTQcZNvC3DuCG7XNJVq9OId9vymCqZI2gxzyhyzpwRL2AMzyq1AVDrPhwzYhOHojb3VBYVen0rfA2OAv%2F4mM80ChBXWJrhzpYoSloZwPU4oQL5ZMhLIMI5UMoazSYeVFILRw2kdCwunkmnLEfEMP1Uizai3aUDPaLFOD%2FzAYuSbFoPmSuyHyK9h9s4rcjXqkosRgNIZnyOlIY2y4mYyYLRvkx9DvRX61TUL1KMigX06okCz1SLhpq2yhuDfdMG%2F5UaPWVWhVXJLzr%2FkOqY0xkQD51qCOcxrCBtoVunbX8fzUDoU5vQjqbLX9BlPM58WQ3FF%2FrdGoD1Z13UVULE2VddZAyJGJZwNSsSZ9P3Q4Ri5O6cD6u7pf2sOp446GA5QIWjhFbeKNSO3b5chqp0q6AhqxpUzb0aFBWQZHcgjWF%2FEiq%2BRYrK1AcbkQUhaUzk10KCN5D38gKpJ4FE19KClceMk6MEnfyb%2FI27lM8uMzxDuzIltspjuZJApxalWSRJi1PZmU7MwXFmdvqj%2BZxArgb9VPHjwl1U0ectwiveRp%2FH08aQaafS7CsdNpKUqbfkxmgNdYv%2B34xXehYsgldcRcRHcTa1npc8HSlvZdF61G1SeOoUwV2WF2zWc0m01ZYOm7Enc96fdRJkPqs%2B4SWhUXV7OW9EVPbe1qeB5QGPJrWz8c%2BfA90nZLIZsin5VZbYmkbvXBxIOUB94dblG4gEM8BxuyU4pzxa7cmxs1tlNXGnkw8qatbczqllbR6aRP7jElUpbwmSTHxmtiu%2FEb5Nf7e4tzlvaYpZ20PduPSKvjiKza4ykBLx2XXMeU3Nr8q6%2FbvTynAtjCjHkpUf%2BkEOM%2BYp6FJlO8rqE4Y17bTArYr8TD%2BG4%2FcypFsVbTvkNbq30FUmYUTCl3FEz0UzCp1jxyQZBrnO4jkBKoMFoAh5nqCkj%2BQA8qfxZkj8eQs%2F2fod1sYQX36xbWM7yeDBIsnL0l4OA0jlGJoTDZW2HcjVWBf%2FDibDEsl0xMZz%2FMarfzCjUujXYuUrzu5%2BNgUOs%2BOM1dEAEOyWVG014wyMxnm6%2B7Fr%2FZeRUtwcN0nlbRJJYLvbjmNxINMkBU9aCeJ4JjeURyBboLhb5u%2BYCsh%2FBrfwqrTUqRk95xhBRI481%2FAT20RgMw3ufnIMG59i8pASFX%2F8Na5kNBSArwQSIywutiiTTGiAZnmP328unFyeztkEHL2Z%2BKkGzK1%2FdVdHb3DFpBZ163tTqRZaOO0AUY%2FRkQaK7vHeN3RrGYH3ecoFZGaWl2s8NcmUz6L9z%2Flq11Wgw9GpxTbUuxixQhfBIVmWeE7HkWFF4eIoS5mBva0z%2FDLljPwt5L%2FsGU%2F4RSVjda2ikGwsgRkTjMQKCOkky4x9h3PCxnXWQfh7n4KspZjqDqhbeCR3SEzYyy%2FGFm8Rr3CceDPzTsvt3ywRIz6oroAoG0myW9m%2Fg4KzC1iFhH0QTphGgdJoMHAP8IAGKRRh2%2BNfqVpqZx6UX%2FdVbbgCCLXUa9AXAauow%2BqPAUnN1wUkn%2B92IFcG5xOQJSEaZ9Rz7gn%2B%2BZuphILStOpCRcYKyWnCy%2FcR6lxMzd%2FVcBG67bsS8uyaQNt%2BtbplyulCFbg05cNurC%2BiShqr6Jiyv6cGaR6%2F28KdLYHQG72iN8%2BKAiU73Z%2BKQ1vHUVmUZGgP1CWgQEGLlVUE4NWtQQHHg%2F%2B4boRxvrNi0nkMP%2FqAxKkDQGKYTtunKnBX2z5tLCRApB23YrIrqu%2FIuj0PErxF%2FOko4BzJHS1DRvUccOXwqojCxK4XwymF9wW1oW%2FvDfrqxtieiErXWiZA%2BHjizYfQ8KO5hsxiCRnUUlW074uYCSxRUW%2FG0nAMmWUWRkZRMuDqjQ1KhF%2FnYzgZW6SWh%2BM3WTtq4oy2gn3WYvTDNREm7cPwwdVSgKv4stsrLUXf1ljHyz9VpLNYnVKoewU9yf2eU8BHxQkZuQi0BJyKQlSQh2QSPd097M5K%2BSbOjXS5lwV%2F5YynAlUSAVfb9FzjD6L%2F71PGk9%2FrJaaeQ2ZKkoSkLiUSZ2SvlmbsQkMDiScmQKCC43jMDQPCoLI2IFilB0Yu84kpCm7HyDI8k6nytHig8ndP%2FFf18cu%2BJpduUtNGJnCDjDsGWPYKlNxe7Yrmu3k%2BQR5GkOm9446lSOU1qi9VcGisUhRz13lZylMxesrBenkiuLDrAhj9IZDkMtxIXfjGL%2BV%2BHqbieLSsiqZMu7pWQzRFqeMSzEpZJM6tQagp24Zhyrh3503EJBsTJO9SwfM%2B8Piwu9xef1oltFs6XCuI9KOQQYucHMHqeFRSr4g2t3V%2BMQPKMwi31h7u2qUtR7TU%2BITkncbCCCp5ONEcBpm8VjPFQD0hv1cfHp38JjtCSPYag3AgvvqTgew%2BpxGGkYEaDtIlhRQwxgd3UuUHoDXFAtOAJbFVVpmOcgY4IpbGACBX33JEH8vnZpeVGMKiR6IP2ROQbNSAyFuDCaEf6q7kdbUYiJV2i1%2B2hrPZGWjpthgZfwh0XeFNu8pjqXMTNQg3TVKAKxjBgVQjIO%2BVMsYRjzJ9QYx6igTgFhz26U9moid5SOcJfDVt1%2Fi2iS5ERTJpb6C3OHNshm5M1wlV%2BDXfAzDXmhE29EQ2bBHG6mMipFQRaEpP87mW5YdKYOw4%2BEu5YYRuA7hG5F7MAWSOI%2BjtpJJOGeg8E6BttUIbc0pUgLSepX5BRKAoHcEDNBAgsvcOWoc%2BD3%2B8mJPZJHfggnkGyanJrWsT3lRBvfQGSPzjawvMaipsROl9DJopS1pS9sH0D60%2BEeCnTNCqJUNin%2BNSJYYmj6mxXBIh1QOWj6OctJNaOc3F5LY3Zp%2BaFIaGdIQ96twh6Z9lvjxNNfr1OERJ%2BHTsELREXZ4QQgepenF7y6FtASNpx42pZtrS2xRbautjlVXUZA1ObWhKZYqJQXw2KonUk8ZbWxPnDyXDm5mNWdJ%2B4WTohIu%2FPYrcqC%2Fl9hbowCi8g1YzmvWCTOSNAK1pAZCyMPIvHRociDKSPjICxxJymrP7ULwr2eD5MpjmPwajIGwDOgRQWREQMorKKS1RH9wDTyZRpZy7rF3VL%2FRDo8FEk7gYHfpWyBINRDZYLR8aA1ceH8RlwVEO%2FsyvattuVbx%2F%2F8PJr8W%2FgCp1N8QWDEk0VeYKXLFccZGBHlA2fIlzMoWTmDtlOcQWKpE6xkg6SCsTJB4PeZkuE2yaV8MckHjnbcrhRZObWFgn8sxaVflUCJEpkwOITdDrE1S%2BOJf5w8CoSWa0NM%2Fe8B6O2TNJIYIWRR3Kw0ygL0DfGgxz%2BcmLV3rcgp1ISpDIe%2FqDMnLHQR5C%2B%2FM2Sd7h4RL137zFSshJw0ugIsfJLi5l%2BiYy6dkVu1Wj1qGX4tGE1hCygqiT0lM3YUx1hPXipsPYVUUUeJnWWyr9NBaxM5lNokLMST57XxjCEtI1CNf44IPGKqRzelpIAlPBP0%2BQvTNn9IhqsZd3F0Rkf0ly4sHVj%2F%2B5aLnOWTWbYKI%2FKussRAYatJO1FIJ6%2F4etJ6bTN2%2FsoaIz0VHr2GMkIoxy9gp3nEr4E%2FxCn75DZMePgfB3c2LzCk%2BLrzrKIfbbMqq5whvZpIfmdgQcs%2BOsvJOfSh%2ByQ8iozk%2BsjDtCNWmiPfHw3ABX14wgy7o7DEOXqY4Y2BlnuErWSLfOk4M9j92QzGU%2Bn5%2FthDMqgG%2FrXaQ6HkICfgEFhGJdx8APrrwH%2FgcQ%2F%2Bd%2BT9Uf%2BQb1Bu1yD5eb3%2FOn2r%2B4cXtNJ42F1bh%2FmWdqPr5TJTuwn4XWHkKGhJo0CjFVKJwYgKEytyBliarRhQYR0EsZ40BrhgiLgR0%2FWIhzr%2FyWI4uDbHJCkVPb0r2dKVXkvN2fAMSxmKsQ%2FM8TcwxzXILTgbz8AlxRnbYoys5mPQmW0iR7UGQU0MLa5GIbgTEfm4ZRjBxrHzRB3daq08T682DKMEqOvpCn%2FOSVRrL7ysrlr5whrPsZc%2Bg4vs1zEhbiUT6lh%2Ba%2FQJPsAWYrX2qDWBbXP%2Fg94F%2B69jPxJNhKJA0yA5lj8NphTuxtgPCpgBnqMHnEdHkDQw3iaH1bkZGM6vdAP8mM0wXIdMT3Bhmne64zDwE672%2FylM%2Fx%2FlfqyirC1YPoQyuGARdy0Iy66DMnIgpIByYnTEcCkorIhOYXSUIQR2kFa7I63yicdKFPS%2BwAiFbFJiKSx%2BlqDDQ2LQjxKD5KyJQcputROTU0pjszeuIpnHlCM7VtTKFQbEt4QF2Eqba9sMFoDC3aqot5cJOIqadF3hNblI1qEkQCG3X6KgHBBHimYdhCOsZh27hTii0OkSQAHA%2FXtKlhfZ%2FlHwu5%2FnZYXbMJ%2F9X%2BBmFuObmWfENgUCNbcRz5myZ4CawRWLrbyuzti2vB5Ud9Eg897XWXE4iE2yK%2Fua5V5dkiIcphHvYa5wuGFyKTtVSWuAgCMEm293k4XVPeMXuyj9s3IJdce4BB2dHtrA6OfoBPDjMD%2BbpGyb8zSIEwnaF4DDLHykm0rYk1kOu8WA18nGAwzQ4BA%2BiwZtJYxLHtRnIkexhsDVgIUFSzcxDJCxujuwUYl0B8Z82IxUZxJItr9Fv9KptgqsNASW47iwBCI1g7W0lZQNSUqCLLMmi52fWxjGjZLBPbp7xLt03ddL4GBhWhc33SoDUoiZj4zZ3X6GFL63UjwrvyGJ8pzfQtHu2kMGap4rG5xNJvwxur8LKiNeVFz39wwZf78uXvRXplitT4xCQpthxC43mmSlZsi02U75nk71i8hcalRYpFdlqTLfsFw4DtoutB1CG1V1y%2FVirUhW1whlMZzQhmfkLTBafwXg8gx7L97rxJ61%2BhMPnAQGt4%2BaDmRLYihO9QvZAUP1U9CfNXZ6WjNcmoDTK1yY1FqclcJ28MG0yAqyXcuoL1wYBVxil9LdCVCUL0ivBDcUyKlyYMTiRwTG8PKwYhnCnQZ44FoMrmARnuTRkWQPOqipRKBQJZiHpemMJNA06Toc%2BTabkiIiSIJX4M8QfG1l%2BDIF8jQdNjUh3yBhIrL9saqUnWa3R6QZwEwoJQT5g223OrWxWxjxiZ7VRs4%2FLurv5zLYMv2ExkQZMKkqFVsTowwhii3xmlbBQ0ZUOJgBBjXulQZey7JL6Fdj1%2FHskj8a9X9mG%2BXkgklWgrBgcGSW2iIXRDbaoZdz0R5rYv6s9FhrwdTviMeajJtGgdfVGHr7GskvWKQhcaUh2bPophr6gEOhQ%2BDzJM5E8insoUGlCjNN8isbEGUb5dLAwYNZ813HntpmeC7E4vIWGF3fMdZXKlBKW1MViUWGoiFLIk%2FTf2hKFsWLeCXJi2SGPS9u1IbSDiDeOTKjG2%2Fa%2BqpfnV2%2B3wy7%2F120XPHK%2FUN6r61mRrsF4k14Yxxr5HgQ28doq8PgVGT70%2FkzvxaLhOxLAWnP4Y4Ui1RZBI5PsAmFlZ3LUnUFrig%2BodNBu2L77ZRU0mQn7E%2FzGxvuFJm9o2VlLHruWXnop2CerHnkgiDVZXFnqstOMu1cDmyzWuZfKEHBQuov%2BBW%2FAB%2FwuHPNQtEZzrVlCUmozkrDvVDUQDtLFn8GNZ8pjgLWbvxdiUt6mgP6O73qVSWYku9mKs2ZPygub0mjKSYBhLtQmo8XH78b2GJJvXTNOLt2XZwQTOMVsdgXy3AvLDqtZWm5TGV%2BxiTAtzWcbNKGSE8iSXG3OmF5u7rvdk1eLf%2B3Je80NaO8W%2BECIsd%2B2l1OTIaD5CSN4nenustluZWeuFVKo7q1hbWc7DglB6AGqWOjfqEEc1Ws6M1gwW4lCiiIUDDFZ0RlYPNLLHgCXSuKibGw%2BbEvZ%2BzasWkjIbZmGHj%2FE4TkoMEHOJHQhH%2BRCWgehfG64KSlN9WWEp5EuYwda%2BD05%2BQSxRpASRU8BdgFTddyYICdG4yGo%2BT5%2BJ0WWZF6SRv76XXM3hioT6y3io%2B21VI1WNyYvM140uwDEwDM1whMKxo1iQziO3%2FraZ1OS1Ha9NNiUj%2FlUcfRK7hBoBWA26qsbFX4OC4y7h9OB8Q6ThlXac1H6ECDsCz6ETE%2F4jeflEqxMuDpIuOhYOLTpjuc4VwmMEIrTLDpGFGplcgZtDuXF9Pn5FPJqr9nV%2BqIcq1lY36FZS8RWXlgftmYn%2BtMLR%2FOS8cBql06%2B2tAGykYcT%2FTANbeoSv5YjiABePLnx%2Bl8n9437yYLC5SSHnSpTN8t9unwKhgTXpkBo4LYFkpUu%2BXc6dV7KiwBAKd9rCv6KCFGmflHcoLAF7MeI9dFf5%2BUbqhwD5bwTUGfBgJR0b3B%2BzxawbtpGFHX21RFhLNugEPNxV0SwGl8YRvQefqBE6wZFJxSnxhf3JiinKisCBsWaavWhjN09kPHTBTexMxKmoteV1PrCUL0nTDOaU6XXwZdWLi3luQMxzTMcFfWK2R06ZMunA0FqA4KwuguHWknQJZyzmy5eyKIitnlyoFScm7XVUhUuCgUGlJ2rC2WHGSlEoy%2FMuSSmGycILO8Z9C6ZzCYGZBxWy0%2BJHn9hHubO%2FLV%2FKhRyqWrDGKMjaafMVz%2BwhYfUDfW6XJKVqCEIkhuC30PZ5bE1AltERxOoIZSUWlDcXA8ox4cBjZDshONA0zW7bDweBLCTklG8jrDB4X6pEbkrm%2FNGxeUNQcfqvbrgNmFxov2wmlE4V%2FZSg95Ay7EkuXhKQUT%2BY8Zo6lS2qaQrAilp5X6Jrnmc6Q45YVYNRh32z4dR8zayHIRySzVkipa8yHPWoJ4hFVsaTSPXTYUN78ogFk%2FkySZycQmlXk%2BFUhHA%2BsRpRR8aAeVBFCl2kgXJvLHaR%2FrbNFl5MQCqLMXPPNNongeXYGZ4H51NF0anJmPdG2EGZs0bbDadg5i0%2Bezyw%2F%2Bd3qsh6OPBFzSsRdJO7S%2BpofVUXEZnjwvQ40FsuNHarYY7Ai3s0wevBuBEg1dpHXcp3xcufhmgAE7D7fxhBYA7jEH%2FmgH3ynn%2Ba6Y6MPLEMQGAxGEQa7eJa3kNZr48bmJopXmbKbN0S0RJ8DVrtvgdU0kwDM5E%2F5LLOjSJb7PWsixnAX%2FHcda%2BJvRLIN%2Bexqjkx4685wZNo%2B%2Fk3Bl2UJbb8s%2FrLH%2FFfm5BJpxrhFFszKv%2Fvt%2Fu5D%2BCULRYpcopuypPMlPfpnyy0bQ7kQIc4G0O2GdvvEHgIR20pwY2a%2FRpQSZVKsNYKOC1TJMZhqsNAt7OpeViTIQRQHug1kmNx18ItnIz5ej4dcZE4oaXQ2siAxoi5qUaUYYN%2BvZocH8IWf6YVC1qIxXsjq6d6QXijQLsG23bFd125jEFyv5IH%2FP%2F4H8QVgtmOPoQFzOH%2BoCK2UIh2tZaPNn701UVOTIcJzkQH%2BRPCL5xjVVrysb1SoHNoT0OG2bxq7ubOGrH0Nwq24K6xB3JT3%2BJsrtcPEtx4RZSANPW%2FSSKv8JWkQhLvxyRztlMBnbtFKiVaQweRgWXSyqLD91aAU4dbKp52OzCcWDX%2F7IS0kbvpHit%2BgONAKnrSL3Y4PNTOQQZxbqTvJrqJMqTVxp6FnNOYmZbA2FUfdc5eGmUNasrRb0lBmlbTvrY5VqLGUnQaU3aIBlfYsJo2lzsitWq3ecc8aAuHiQheeaBBPOx27%2B4WyK9wIecguSeLEn0mrDcgjgd76ldiyN%2Bw%2BeO2RW6KDFHHd5XhJGUmWAlq32zzmOTiWIwG8DBf9zCF8Blb9Ni%2BxWnoFFZm47BKofYaOLHseFWvS5ZthZSd2IUrIqWjCSD7OFzLLgYvSFOOptUakVLMawJgblfgN5QBxFlwDS2pT6oAP7gaokDNybTfsbpA2JPnCtKKYfqYu18922CoMVcfQ6s2oOuYugfXMhmfu7sq0NFmKzpP4HEWnyUp0mqxr%2BxOXznP8hUKbbNl8DE6RBIVCuPtcLE5AbvHb8gkSKFDGS%2BzUWIiJQJpVBr0ly6QSBWMXyPAUBhrQVfQhEGykQaUMfeYwrqYeGSb5bQWISXJBRBDSwATBPRF4QQCVEPbPxE1EsGQtR%2B4TBUHAY8Myu0aeGOkgEsYFk4%2BmwoFSvKNpRKQvbX4SwDCg4WKtAcYoFUY4YTFTtD6CMpFxoxWIU88fo1ksQ0B6eDVYnHJj7DrDrjka%2BekJ7IeIZVy74PVkMINjZNCxKnkKQ08K9Zu9tKvXKxX6Zj41x4XaBlYwJF1ZoWEwU%2FzyVjuUzFFSKXfnD1viiFyy25ycJOyshT6iLCU1mGRif16gmWIi7SocdOrYBDnlNbP%2Fguf0xN4uAGaTV%2F6qSGaRXjYpc6qqsmNxR1lYTQPbwVpVeS1R58NzrOYqKsMcL65NbmjO%2FaB%2FNNtZElVSWprd7DApN6EAtS1b6yx1o2Q1WkJCWK8924ZnX6SdwonMZNqll3DQgclgOeiSdSsLDZdWiNm1JtkaTP7Cur2f0ktwVtdLjCI9ZmFmcfRDB7wNIJ5ixlbczQxvORj37QHq7rcAcfxOPRNFZGzP9oG8vkNeohYWgZK60IxoagWyqwzStUBhkRVrKswgL251EmXaLKA7kSFK%2BOIc6yLtgqRYQZADUyAHCJ5w2PDrk5SsJ%2FRDRm6osNkacFGiaOqn%2Bz2PgpGsfECtGkp1w4vGs5xgrBqm8MIClo32RwdVwvuBcpnT2gHbJ8Pi8SwPZoFbjnZiABOc4uRV6HODifUa9ISbaqQJKw29rMF4g2EQwCvssheR%2FzvalhV1Y92B7Z22i3MoXcyJcjSKcBj9DwWeQTgFyn9GqU7uZRd%2F6%2FIy9Dvm8hbHF%2BRNi%2BLokq27NAxhQVFIrZbO4PMJUEkJ%2F7ym8tQqykyFSihsFTPU0x1WMe43VYXEbtQZzJYXQxSlzaykkmE%2FbsfRLJGO2aFsYnAvheWnKtA6VVg90A59bVb3tUlJaCSW%2FJrPS2vr1XJt8Lik8R7rMrXmk5rNpgxjC9QESdz1pN9H1Jz6dgicP9E6Rqyt%2F7pp0wtMHogLtXJ6E%2F16%2FPnYXt3IbEcHb3c6gIs4U%2FsevAWiavBk7tjH3%2F6Hv%2BY0xOGkv6QXE54NnwwD3qtid6xJ32f7j9H7rNu8LW1orWB1WAPbSgu1nB5JqI%2BkHaZNft1yPdtt%2BMCMtLtzhEC2emox78OH4UAc30I9B5OjAGzUt4a%2BA%2B5dXjLPxwlazGkGyiu2RM4kVN7aGrP%2Bsflo1GWAVgQvf14zsYFmi%2FZw6rijIXRWFz27hwXdxIK6Ns4%2FuRxZbds9rOl%2BrCmsUYN2wu7I1d1uTbqwH9fKT1GYkYQCzTaBYbbtq7%2Fip%2BsUhhWSeM4CbX4rm3ZX0CGhoMq0FISGkIoUVKIywkR%2FRcEcldIusWKwrD1Y4BbMkKC3HUcTNVusDBUmUn34ywKmK38P66ZpeTkZrCUvNj37Ej37q037v219FlnxW%2Bct3OrN8tdkzC9d1tU58wRvIkOByo4B7suMHqkLf%2FAxEi7FNI%2Fc7X0anE2gwrKCT5stoVfEv2STLscZEkVdR1meMWyib0MsLermNEk4ioIGcPyK6jnwpejytzUqcoS8uUta1X0iB5YXk4nHKeVva9esSaQlSPgkPlZPxmqcJS39RUEVaIQP%2FCrwsZ3HHouxgdhmZ%2FQSNoVCsMeyS3c5d%2Bn%2BvU0jc0nrLND2UjdN8hd6UF1S7J5RMzQ83op9KyqJotywv32sYGzDBhaddgL78aEJcobdIxJQhU7fEjnqldDl3vE%2Fe9ieDzodou351lEGQ9pbs0hws2uu0k5YtLKlEB8MrCwBj9vDBebjCywXs8BE24%2FveZEu8WPWXPHFNV5U6cIeJKCpld6XTP71F01I9Ell1FWzOnUUl62rsrIDcyyzSosZRkJeqyuvxMDzn5vTv4Ds8JBNFJUdvj6xJcAtskYIkp178yM27a9Cl91Okw5Nyqr%2FqzuGO6v9ClZEx%2FXzZk5FFBqHcBUMBUe1LcUuMlopinIy0syLGgOSQGdwI6U4bpQBhWc79pycjFeKDD1hEfKNqXfFcW%2BVnq94h3Vi0jloJ5T3utW6rkdVfXEdrTGku7Vsuc0vNx3OpwA6UIJ0Ym3d3mjQnHjrL2kWFQuDDjKXrq0ryrKlS0cqLGDhyFl%2BpbrPrM4rDndQo010vKrxRnt3OE%2FO2vwit2Vba0vsRdbVNqeqay2yJjRFpdhFTnLr7S%2ByetCzvx1HDztBrtS0CYNcrWmTTbcrmrZKJ7%2FYfQ8KcKfDJJRfhgOt5tm8QYirYvjbDvdx0GgvHKqqrxzpqGcBxFyoxPEUKhAFOQRWCNGXKUsHW1BBwQwBQNY3KR1spc21bbZ0aMuqqLfXkg66rvDaOm7ab6gAnBqPCW9fPJA7H8RDkeKBMP0M4kHcLfFAyrIp8fD7JUNI%2Brl0CBBILGWXxYG2mb29yEoSssN57zBDiOVyMMjrR05aNbOTljhFd4Y3MJL8MaIThG1SIYqPgZocGBLq0qCi9glKNrCndJ1kH1gPUbp%2FzHq4kiLyYlyp%2BBkfmjN%2FUCBX0jOoID91m%2BuKKlpKJq2Sb8v2Ur%2FCegxgHe0wmZsoM5LtZZZjnC%2FQ96fz1GpssPdV1uzARULgS%2FTcLmUHbicGKGXOASSEtSviRafdk4kY4Now4%2ByoYaeDVmN11PCoKkDgcYNHFi8WVRwCJK%2BAf3Gv6VqRxN8v0fTcIl5cidOJBAjbYu28aq2z3KyFYOL%2FJA5Oh72Trv4EvEGcTFkULfZHVjt%2BFy8rnR%2Bk%2BlKpXly4W6edvih8G%2FfpIapsRUnmatS2%2B3sYwk2k46aFcHMiCC1BEAqjOivsDhnLxlKLogiBYyjhuBUuNMZQm1vYp26Jp1iGXfNM0kfPRL3sdB39HLXCMyqpdHNoUreCQmRGvp7ESg4trH5P4BihhIOjOFddXeD4jLq6wO1WFFHgGPl6i9jRr1dvF9Sfh69YlDh11xXakBaT7WE16M3D3dKNbKHDRePW8Ajy%2FsF2rKhNq6YeSdyieaxRI63VZdKBFnV5pUKQEXWl5AQ5l3b7GHeFzz0S%2Bdv0Tj7RiIdXCCpQNNrIUjMKKwoSuAywMAch8kMhkjXWKHC7BekQjjzWjxzmntku27dC46ktM4rT3DzN2L2vADdgm6%2Bl8cQ%2FhhdfQxNHKMd%2F90%2FUVi9gXPChaYZ1yWq3w5F9B%2FQiDw5XHCNLtpnVGAY0s76tMANa4Fj1v99w1KS6HkOBKHB%2FwP%2BIcDPnazlnElTwC2vtciIhgSo6UBl10bzMgrcrjogYRQdB43od6Ugq6Q1vwH9Qj9Jh5%2FdY4tbaehTtA2QZ%2BkhnMw3IdwOLXg9HQONFHAx5Nt1JagbWJWyYdWVICCbr6QwsqBpElyM5iT7UwMKjyKyrjzwspsVKc%2BT7owG4oA9PmGFzBJaXDj3M8MbAmAo0LYt86TgzmH9hBuOp9Hx%2F7CH%2FJFDza632UCg5yBoYtm231AJPFGpty7fAf%2BBxD%2F535P1R%2F5BvMFxag6LV6%2F3X6VvdP7yglcbD7tquyW85LcNWjyn1oYXRo5gsJmJxwc36lXgGOULPYTlo%2BbUGN1RgS7HAFYkjcwHLg1zsygZGQxvlp5RR7glgair6%2FdrMD0nkVaGUoyBEWIF3lzh0rwPbzMg2E9XKvC5n1PiK608Y2j07VyLI0m40FuoLz4bvLc7c5zfdOGonq%2FUXlJMdGkKJLSerkRtJBowtJV%2Bc1sCOGDYXnDUeMMReua7tL3jvniL5aJlChzkRxmILpwM7MhmjUFzokBBdgbYwlp5I7kbo6S8zhX9KQtszdHlWLEGD%2BpchoqhAFWYGS1CnaiPlyepTC%2FZrvPc57XQ1udOZbX5ZmC3FmY78wUG7Xw7avNQVSiplRQkvkFYP%2BQrfLWwLKWB1sIlw9tXBJsI7VgabCiCFPU9O4HNNThDEeDnJ7iffCjwdVmZkpdZG7kJ5jFgutFHyFyqHROvQEpycYXryOs%2F0IxTnecnQtfjgsd41j3VurhBKEd6%2Bz5oO3MXcwfWeBUukxbvqyVnjvnr3n1k1rlNJ9uD9jS24ngj3CxzD8AmBKTcCVikIGRyZB2XyZ3lLZEpXq5KCmlGV3FDeEhn5CvXDHQ1IGsdd0E40f%2FjaUDZRSylUVCUbs1c4S%2Be3lLSYiPywIVJY6HfFcXshiyXJ2lsFhzEWKAuSJh5FYBZKHEfOZ%2B%2F98t1S2pzZQFialIENZLUoo3VWS8TGD1vL8LyWpN1kZC2ltQx9qzAtl9oG5FZ4eqhb5WZSCRkaXBx07l3TuXMKv3NJ6mO48zarcQusVLlFdgWWq0SqHjTtrAudVLVZ0paJxFzgSmdIT%2FvV2cwJGFigmDFCuApjzgt0lgvZHGhAgw3BYFmq6y%2F0mxWktrIWlRkAKc5rRlSIeMZGQd12cgilpu%2Fa4pYtyf9EhruTnU5RXJ6ZyMoz%2B0Y6BUSAyF5awIJ8XhMJ4sAM0qiKkb242dY%2BgB9RRHWI3G8kcv%2BTjh5pjTu24ZdJppgKEouqVUZgSC2qyZgg0oGhFQD2jJYt7H1wUG%2Biq0%2FQncK1ZxiEIQZ6dO2TzXVzXPuDg%2BKvdVCISU9biJazNQeFmMVBERakrOBSB%2FdFJjKg3BeSEkqpVQ6M4mKFEq1qUStadKxQ4OiFqtW2FyvckeACsO%2BOMgYXpNxx2NmufrrhddIIKNrTL9IOt9bEhTMecKR5HTe1G7leqdUHPGv9oGX2WoyimIWYqMTVWXFFltetQEahUNO4e8C6fGy7LnbvamBdFg%2Fap3wFwiEy8BI5b17yQ8LbgWyWA3WEV%2B5YNovESndYD8mWF5Yh2ebSwBUYZ34ol4jqDNXoit23u6gD5c86uTrDKSARpoo%2Bjz28ALRbYV3DbN3K1Y1LX1krJboU8MwaEY0vkcbQmykTkb7baDjpWPz2rqgi1FRNRMahBIEIljvdvTGqhaQfFwwUPsrtNo8FWOMHhggmBo6UfMLoeHDAmYcXtuZIAiGE48RjWmeb5zd9BB4wGF816DwCkWjBQMEppWbBFqVz5u5FgBJVhI8DrPUaKkiUj3QB4UCk3vHGhTDZjJ8msApXsYSDZc9mF0mYEl6kzXqmg6dARpGO%2BDV2bSYBN0M%2F4Z%2FI3oSpmE34N9yI8ZOW3lRbSnyXdqyB05%2BTSxRrANc6eApQuZqu5UB%2FIDcYDUfJ82n7XS9pYz9d0mZhM5BIBF3FjCbyDPwb1P7Zt%2FpAM2M8pfbvv%2BkxnRSWUvSYuH%2Fx%2FG5uDFkXuQUUTgfGY7mh%2FUmvMM0VEWvScT8mA3Inug3Tdme%2FqDff8AImn%2F8v8uXnNbNZnwoEmZ%2BqlEafeJzq2llzelotVYNBZXr%2By%2BlLAOOogTD%2BJ6%2FnLQsNb4mNHFhboaxNRvwL4XUBPdRUtjqzK%2FfT755rBCEJVWEaiC0ASUMfTISohu0ChNpmAPnDR34VnpLhcR1ZE7CTkrBoHAyPmAi1jdx5m%2Bvq7umChhDsGrRXNDnsXrXV2c7gZtmP6U%2FFst%2BL19u%2B7rUnIg53TOBYaJWhuwPsZBVKP8hSOcRkCbPe5hp4Y9cZdvdjFbBXB0u4MhJaqHEtWAjIPfltT%2FVfxDQB4RvlSLvg6CZQUK8pBOKqyzGNBWyLUFGB%2BLC%2FfhkP1kQhxKUhNhr2rclCXCSza9uEE1jTe7fhV69A2EMcmR%2BGvBQrmm5BHvamQ4jRei0icxUYhjGrERRqHVomwa%2Bw6Uk62kUpAp6qBkwK3pB15wTfYVAf9coHVXHbbjraFoRVAUa%2Fn%2B5NO7i3DgLp28wPqDpGOcY24BF%2BaaR485PeRJi8%2BzDjVGB7wczDrnbpEmS7hL9Z3bWwJYg6CjVkc9GiX4F%2BK0D38OIq2gZY0FciDsdQHOvIVOAipxQoanWeKAxY%2BAroEfjp2OKrIimMfGSGEghxDX0wOPR08AF5nRf7E3%2FYNqPeX0m9J4wduxNqEY015CUhFnboVN8pE5XudbKXXoZk6s7mJ3ocnVa2Y%2BD4n%2F2Y7oOdsynuuU8uWRXKfQP1egLMVEc4zkDyYrkcOA0kqLPpYiRrL26kw2LWAzMtWtaBeTd5tComlGnwCF4VnEJZTepPUOfDypYUSEioYx1CGrmvSzWIwwN7Rjfi28YI%2BqFpODIcLmK0k7eB%2Bn9j31aYAnxg2geVl82ukxs6tLBUaFYbfEQJDikxwq6h7SaQFjHRWA4iUjPiCmGYkOnsJGBLUiyFGwwDKtx0O0D6PuFQdTi8UHEPnDUVkhNeDTy64AP2KgT7ibIEDtvosI2W6soJktyqz2mBH7UPc6vC%2FarpkUmOGuM6CuCE8o%2FuS7rEXxXGiNLctoftvrWQzsohZX3qt8oEdycjm4S2DvGqQ7zq2ybFDqXt7nk6dtQQS9jOePYTeYE1eH0QJqktTZ5gxUvgI%2FApHRl9RJE9iK9ti6%2FlAC3ucQHsPGVSwOExLH8kRxMFrgFk3pql72m4EEXVm%2F6hUJl5joFuqPE6q%2FFViEaWf9GpLO4uRMzfBOaRGTZKFnYLzIP0%2BT1AvewEdUi7RR1k5AeolwPUS35QL3qJU%2BPCVGI2cdo41Avd5CAbnR6gXlYogQeol9Us4QD1wmYXGlfi4ujSfNj9ZHtoL0SPO6C9HHxwu%2B%2B6OKC9%2FAanzcohHdBeDuGFA2ujwwu7g%2FYypjbQTi35oaTtsId3cQ%2FTda90MU667bkTmfm%2FtUr%2FkBJxSIk48LvN5%2Bvh0DmuFcwWnT8YaNs20LYQVc%2B82vsRZ9eERJidFRmQSSw%2B1hqzwCC7trtB9kUflhLHJ3uxKMLR8m4s6Fvddh0wU7Dt4N8Wtyfx1gyR2R1rwkE825uiSf47NMkdrdUb6LdRY9vyerBdI%2FrhFklT3zHSZIVGDiklW6IOhd8t6pBX9lP5y1JKCELbIY%2FkG3kkWlxbVHeiZZDMaPV6yCOJD%2B%2FvyiOJwHZEtnw6xsUhVySftkAKo%2B3zphNF0lMoD4kiB8%2FkjnnjaMGBK%2BExwh2sCaqwoO4ieKxB3VCIxLwOUl6U74KHQr4bjkeGIsNEhf06qpM%2FuEOLcYdy%2B9rZImxoEUUPRtVyh7jhX8vvcJ2kgYoYK6jdTBTvxgwSeQ0uqHgMqivpeLUMC%2FkBO4uihH8PlD6JUU0XXmKQh0oEvnotjPIIakHyLShE2QOT3XbMaeWQ1o%2B6r%2FI4xELt6dLg96YG7nUITZUTRpDKMIIklhHEi8VZQYzSGiYef8Aq6fJ1pPNpBDUfY6JC7hc2CDMYW6oadvRI6rWrQPYIA6UANzFV%2BizjPRijgl4INYBYKL0hY5ZRYhNGWjOPTKN8cnlmxoRNWjr2ot1MME21CZj5Zc9SiMYeTsP3n0646rDpjQMeCiYVrJ6JHg1EDZQ%2FdNpWiIiDcInAOi98PktGTqloAfxWiKpcYSMSQEEdgeiSuNg6R2QfjbW7BPsgfKQMSc7gWFhAEdMF3MQkc21EsQ5pdKBoszwDkY6IutIIGVcgCi8W9s8zCNoGuiM1B%2FTYwyIn%2BkUxzrXM%2BlV0syb6%2B6FTOGnPlAgwFTUrif5%2Bmd6YNQkhcmSkH0cqZYWgSxSLkTi4vwN4ULMWN4HTlCnUf0uXIxdjyqLgvw0D3z0Ldt0SMgtpKdzSIcY5tqvji4c69%2BEHr0VY7GlODpiiNXrAFPVFO%2BRoBCGLMKfU7ZGVb0VvHxAF5dEg68wCkA9yr6KLVEXXhC6KKCuVA2I3xEBpNuUAIDPJtLB5oEXeMVyO%2FXLtWsGBvt1ZKFH5azmKllByZI1WckSOlSek6oUFvllxnw0HvnmBXrV9CnyTcHaGwLe8W4FvMnJGIGCFbbciXLXCsFuCB%2F9rgsmKUqsBHl1k5EhKBpMFTqdZisCzg8lSYZaTIjIsp9SwZN11Rq7jz1FRut1eWpaeInjAcvRHkwyW7jiSqRX8KJK8RTElhiRLZgzoOsoYADYXcoYKAUsKJJzIRc7BU3DFwNme1Ubsav0srDXkTQL%2BSeAEBnGwjGq9OMpgwVUcxE2%2B4kbOLG60HRM3LGCng7jJJG7K5VqtXN6wuBFYuUubFzeMdIUV2CcHMVOcmOFZwEgbFjPagZF8PwmyqmyckYispKeNMxKVYzAS5cgUUE%2BHSHoIg7WYxFNXIQHLcuA8CVwuKmozoh74TlF8R8iKsFQc31EZ3hTsBzQ5VlZSpDOegSP5uYGARbt5iCjgQadJoYfh8AHsQhkPKASBCjxEMxKxiEQNTJXEGirIuYqdoBqVpRKNCNHDCD2xOElADl3gKwNeOBvADDpnabXwXqiPK6PqPto0SyDJC2nDWV29v2pR4h0uTPag0na95wy7fTuwNFbtfAteRnYyV5J4JfpHJVcEux%2FuU02UdJmXZEXkOSW2azkGq0i3lzbqUCk0O%2F8P4AwEC5n4aDWGQ%2BX%2FM4R3pCksVYDconxQ%2BwIu5w6M2Azf%2FJRUkAoA">参考这里流程图阅读会更加容易理解</a></p>
<blockquote>
<p><code>BeanFactoryPostProcessor</code>接口是Spring初始化<code>BeanFactory</code>时对外暴露的扩展点，<code>Spring-IOC</code>容器与允许<code>BeanFactoryPostProcessor</code>在实例化任何<code>bean</code>之前读取<code>bean</code>定义，并且可以修改它。</p>
<p>而<code>BeanDefinitionRegistryPostProcessor</code>继承自<code>BeanFactoryPostProcessor</code>,比<code>BeanFactoryPostProcessor</code>具有更高级的优先级，主要用来常规的<code>BeanFactoryPostProcessor</code>检测开始之前注册其他的<code>bean</code>定义。特别是，可以通过<code>BeanDefinitionRegistryPostProcessor</code>来注册一些常规的<code>BeanFactoryPostProcessor</code>，因为此时所有的常规<code>BeanFactoryPostProcessor</code>都还没有开始被处理。</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值</span></span><br><span class="line"><span class="comment">	 * 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>invokeBeanFactoryPostProcessors()</code>方法中首先会调用方法<code>getBeanFactoryPostProcessors()</code>来拿到当前应用上下文<code>beanFactoryPostProcessors</code>变量中的值。然后再执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br></pre></td></tr></table></figure>

<p>来实例化并且调用所有已经注册的<code>BeanFactoryPostProcessor</code>。进入方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">	Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 判断beanFactory 是不是BeanDefinitionRegistry 如果是则直接调用invokeBeanFactoryPostProcessors,</span></span><br><span class="line"><span class="comment">	 * 否则将 beanDefinitionRegistry转化为BeanFactoryPostProcessor 然后在执行如果是则直接调用invokeBeanFactoryPostProcessors</span></span><br><span class="line"><span class="comment">	 * beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if条件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * regularPostProcessors用来存放BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * registryProcessors用来存放BeanDefinitionRegistryProcessors</span></span><br><span class="line"><span class="comment">		 * BeanDefinitionRegistryProcessors扩展了BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 循环进来的beanFactoryPostProcessors,正常情况下，beanFactoryPostProcessors肯定是没有数据的</span></span><br><span class="line"><span class="comment">		 * 因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的，</span></span><br><span class="line"><span class="comment">		 * 只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(...)才会有数据</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 判断postProcessor是不是BeanDefinitionRegistryPostProcessor,因为BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">			 * 扩展了BeanFactoryPostProcessor，所以这里首先判断是不是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">			 * 如果是的话，直接就执行postProcessBeanDefinitionRegistry(...)方法，然后把对象装到registryProcessors中</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">				BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">						(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">				<span class="comment">/** 注册bean定义后置处理器 */</span></span><br><span class="line">				registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">				registryProcessors.add(registryProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 如果不是就装到regularPostProcessors中</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				regularPostProcessors.add(postProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 这里不会初始化FactoryBeans，会让bean工厂后置处理器去初始化这些常规bean</span></span><br><span class="line"><span class="comment">		 * 并且将这些bean分离出来按照 BeanDefinitionRegistryPostProcessors实现的接口*/</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 1、调用 实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors后置处理器</span></span><br><span class="line"><span class="comment">		 * 获得实现BeanDefinitionRegistryPostProcessors接口类的BeanName： org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">		 * 并且装入数组postProcessorNames中，如果自定义了实现了BeanDefinitionRegistryPostProcessor接口的类，并且也在自定义的类上打上了<span class="doctag">@Component</span>注解</span></span><br><span class="line"><span class="comment">		 * 在这一步还是拿不到自定义的这个类，因为spring还没有进行扫描。</span></span><br><span class="line"><span class="comment">		 * 扫描是在ConfigurationPostProcessor类中完成的也就是下面的invokeBeanDefinitionRegistryPostProcessors(...)方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 获得ConfigurationClassPostProcessor并且放到currentRegistryProcessors</span></span><br><span class="line"><span class="comment">				 * ConfigurationClassPostProcessor是很重要的一个类，他实现了BeanDefinitionRegistryPostProcessor接口</span></span><br><span class="line"><span class="comment">				 * BeanDefinitionRegistryPostProcessor又实现了BeanFactoryPostProcessor接口</span></span><br><span class="line"><span class="comment">				 * ConfigurationClassPostProcessor里面执行了扫描Bean，Import，ImportResource等各种操作</span></span><br><span class="line"><span class="comment">				 * 用来处理配置类的各种逻辑</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 把name放到processedBeans,后续会根据这个集合来判断处理器是否已经被执行过了</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 排序处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 合并currentRegistryProcessors，这里为什么要这么做呢？因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span></span><br><span class="line"><span class="comment">		 * 一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 * 父类的方法，即BeanFactoryProcessor的方法，所以这里把处理器统一放在集合中，后期统一执行父类方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 第一次调用bean定义后置处理器,这个方法比较重要，需要我们点进去详细研究一下</span></span><br><span class="line"><span class="comment">		 * 可以理解为执行ConfigurationClassPostProcessor的postProcessorBeanDefinitionRegistry()方法</span></span><br><span class="line"><span class="comment">		 * spring热插拔的体现，向ConfigurationClassPostProcessor就相当于一个组件，spring很多的事情就是交给</span></span><br><span class="line"><span class="comment">		 * 组件去管理的，如果不想用这个组件，直接吧注册组件的那一步去掉就可以</span></span><br><span class="line"><span class="comment">		 * 注册<span class="doctag">@Import</span>等注解也是在这个方法中调用</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 因为currentRegistryProcessors是一个临时变量，所以需要清除掉</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 2、调用实现Ordered接口的BeanDefinitionRegistryPostProcessors后置处理器</span></span><br><span class="line"><span class="comment">		 * 再次根据BeanDefinitionRegistryPostProcessor获取BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span></span><br><span class="line"><span class="comment">		 * 如果没有执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span></span><br><span class="line"><span class="comment">		 * 如果没有实现Order接口的话，这里不把数据加到currentRegistryProcessors、processedBeans中，后续再做处理</span></span><br><span class="line"><span class="comment">		 * 这里才可以获取我们自定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 排序处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 合并processors</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 执行我们自定义的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 清空临时变量</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 3、调用其他所有的BeanDefinitionRegistryPostProcessors后置处理器</span></span><br><span class="line"><span class="comment">		 * 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span></span><br><span class="line"><span class="comment">		 * 下面的代码是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">			reiterate = <span class="keyword">false</span>;</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">					reiterate = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			<span class="comment">/** 第三次调用bean定义后置处理器 */</span></span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调用目前处理的所有后置处理器的回调函数</span></span><br><span class="line"><span class="comment">		 * registryProcessors装的是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 * 上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * regularPostProcessors装的是BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span></span><br><span class="line"><span class="comment">		 * 但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">		<span class="comment">/** 调用在上下文实例中注册的工厂处理器。 */</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">	<span class="comment">/** 这里不进行初始化FactoryBeans，而是让bean工厂后置处理器去初始化这些常规的bean */</span></span><br><span class="line">	String[] postProcessorNames =</span><br><span class="line">			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,Ordered, and the rest.</span></span><br><span class="line">	<span class="comment">/** 分离出 orderedPostProcessorNames 和nonOrderedPostProcessorNames */</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 循环BeanNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果这个bean被执行过了，则跳过不执行</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">			<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果bean实现了PriorityOrdered接口，则加入到priorityOrderedPostProcessors</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果bean实现了Ordered接口，则加入到orderedPostProcessorNames</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 既没有实现PriorityOrdered接口，也没有实现Ordered接口，则加入到nonOrderedPostProcessorNames</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1、调用实现PriorityOrdered接口的bean工厂后置处理器</span></span><br><span class="line"><span class="comment">	 * 排序处理priorityOrderedPostProcessors,即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行priorityOrderedPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2、调用实现Ordered接口实现的bean后置处理器</span></span><br><span class="line"><span class="comment">	 * 执行实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 3、调用其他所有的bean后置处理器</span></span><br><span class="line"><span class="comment">	 * 执行既没有实现PriorityOrdered接口也没有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/** 这里会调用EventListenerMethodProcessor.postProcessBeanFactory(),注册事件监听器后置处理器 */</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">	<span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">	beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，判断了<code>beanFactory</code>是不是<code>BeanDefinitionRegistry</code>的实例,这里毋庸置疑肯定是的，然后会执行以下操作：</p>
<ol>
<li><p>定义了一个Set集合，用来装载<code>beanName</code>用的，后面会根据这个集合判断后置处理器是不是被执行过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p>定义了两个List，一个是<code>regularPostProcessors</code>，用来保存<code>BeanFactoryPostProcessor</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>另一个是<code>registryProcessors</code>用来保存<code>BeanDefinitionRegistryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BeanDefinitionRegistryPostProcessor</code>扩展了<code>BeanFactoryPostProcessor</code>。</p>
<p><code>BeanDefinitionRegistryPostProcessor</code>有两个方法，一个是自己的<code>postProcessBeanDefinitionRegistry</code>方法，另一个是父类的<code>postProcessBeanFactory</code>方法。</p>
</blockquote>
</li>
<li><p>循环传进来的<code>beanFactoryPostProcessors</code>，正常情况下<code>beanFactoryPostProcessors</code>肯定是为空的，没有数据的；因为<code>beanFactoryPostProcessors</code>是获得手动添加的，而不是获取spring自动扫描的。只有通过手动调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">annotationConfigApplicationContext.addBeanFactoryPostProcessor(args);</span><br></pre></td></tr></table></figure>

<p>才会不为空，获取到数据。</p>
<blockquote>
<p>如果<code>beanFactoryPostProcessors</code>不为空，依次遍历；判断是不是<code>BeanDefinitionRegistryPostProcessor</code>类型，</p>
<ol>
<li><p>如果不是则将遍历出的<code>postProcessor</code>加入到<code>regularPostProcessors</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">regularPostProcessors.add(postProcessor);</span><br></pre></td></tr></table></figure></li>
<li><p>不是，现将<code>postProcessor</code>强转为<code>BeanDefinitionRegistryPostProcessor</code>类型，然后注册为bean定义，最后加入到<code>registryProcessors</code>集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"><span class="comment">/** 注册bean定义后置处理器 */</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
</li>
<li><p>定义了一个临时变量<code>currentRegistryProcessors</code>，用来保存<code>BeanDefinitionRegistryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p>拿到所有<code>BeanDefinitioinRegistryPostProcessor</code>类型的bean的名字，将其保存在<code>postProcessornames</code>数组中；然后遍历<code>postProcessorNames</code>数组。判断是不是实现了<code>PriorityOrderd</code>接口，如果实现了进行一下两个操作，否则跳过</p>
<ul>
<li>从bean工厂获取到<code>BeanDefinitionRegistryPostProcessor</code>实例，将该实例保存到<code>currentRegistryProcessors</code>。</li>
<li>将上述步骤获取到的实例名字保存到<code>processedBeans</code></li>
</ul>
<blockquote>
<p><strong><code>ConfigurationClassPostProcessor</code></strong> 是一个很重要的类，这个类实现了<code>BeanDefinitionRegistryPostProcessor</code>接口，而<code>BeanDefinitioinRegistryPostProcessor</code>又实现了<code>BeanFactoryPostProcessor</code>接口。</p>
<p>在<code>ConfigurationClassPostProcessor</code>中会执行扫描<code>@Bean</code>、<code>@Import</code>、<code>@ImportResource</code>等各种注解</p>
</blockquote>
</li>
<li><p>进行排序，<code>PriorityOrdered</code>是一个排序接口，如果实现了这个排序接口，就说明此后置处理器是有顺序的，需要进行排序操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br></pre></td></tr></table></figure></li>
<li><p>把<code>currentRegistryProcessors</code>合并到<code>registryProcessors</code>，这里合并的原因是因为spring只会执行<code>BeanDefinitionRegistryPostProcessor</code>独有的方法，而不会执行<code>BeanDefinitionRegistryPostProcessor</code>父类的方法，即<code>BeanFactoryProcessor</code>接口中的方法，所以需要把这些后置处理器放入到一个集合中，到后面统一执行<code>BeanFactoryProcessor</code>接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br></pre></td></tr></table></figure></li>
<li><p>这里可以是一个扩展点，在这里可以自定义我们的注册逻辑;同时这里也是第一次调用bean定义的后置处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br></pre></td></tr></table></figure>

<p>我们进入到这个方法内部看一看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">		<span class="comment">/** 这里调用ConfigutationClassPostProcessor处理beanDefinitionMap中的bean定义 */</span></span><br><span class="line">		postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出来，通过循环依次调用<code>ConfigurationClassPostProcessor</code>处理传进来的<code>registry</code>。不妨在进入到<code>postProcessBeanDefinitionRegistry()</code>方法中看一看。**注意：<code>BeanDefinitionRegistryPostProcessor</code>实现了<code>ConfigurationClassPostProcessor</code>**接口，所以我们这里应该找<code>ConfigurationClassPostProcessor</code>类中的<code>postProcessBeanDefinitionRegistry()</code>方法。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">	<span class="comment">/** 这里会解析配置类的一些注解，例如<span class="doctag">@Configutation</span>、<span class="doctag">@Component</span>、<span class="doctag">@Import</span>等配置注解 */</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要调用了<code>processConfigBeanDefinitions()</code>来解析配置类的一些注解，例如：<code>@Configuration</code>、<code>@Component</code>、<code>@Import</code>等配置注解。<a href="/archives/8d05e930">详细解析参考<code>invokeBeanDefinitionRegistryPostProcessors</code></a></p>
</li>
<li><p>清空了临时变量<code>currentRegistryProcessors</code>，因为后面还会使用这个集合变量，所以这里使用完毕之后需要清空，一遍后续使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentRegistryProcessors.clear();</span><br></pre></td></tr></table></figure></li>
<li><p>再次根据<code>BeanDefinitionRegistryPostProcessor</code>获取<code>BeanName</code>，然后进行循环，判断这个后置处理器有没有被执行过，如果没有被执行过，并且也实现了<code>Ordered</code>接口的话，就把此后置处理器保存在<code>currentRegistryProcessors</code>和<code>processedBeans</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">		currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">		processedBeans.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以获得我们自己标注了<code>@Component</code>注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于<code>ConfigurationClassPostProcess</code>在上面已经被执行过了，所以虽然这里可以通过<code>getBeanNamesForType</code>获得，但是并不会加入到<code>currentRegistryProcessors</code>和<code>processedBeans</code>中。</p>
</blockquote>
</li>
<li><p>进行排序操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br></pre></td></tr></table></figure></li>
<li><p>合并<code>Processors</code>，合并理由同7</p>
</li>
<li><p>执行我们自定义的<code>BeanDefinitionRegistryPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br></pre></td></tr></table></figure></li>
<li><p>清空临时变量，同9一样</p>
</li>
<li><p>在上面的方法中，仅仅是执行了实现<code>Ordered</code>接口的<code>BeanDefinitionRegistryPostProcessor</code>，在这里是执行没有实现<code>Ordered</code>接口的<code>BeanDefinitionRegistryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">	reiterate = <span class="keyword">false</span>;</span><br><span class="line">	postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">			currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">			processedBeans.add(ppName);</span><br><span class="line">			reiterate = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">	registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">	<span class="comment">/** 第三次调用bean定义后置处理器 */</span></span><br><span class="line">	invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">	currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面是调用子类独有的方法，这里需要把父类的方法在执行一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<p>这个方法的调用链很深，其实他最终会去执行<code>ConfigurationClassPostProcessor</code>类中的<code>postProcessBeanFactory()</code>方法。</p>
<p><img src="/archives/e74be873/image-20210828130627960.png" alt="ConfigurationClassPostProcessor#postPRocessBeanFactory"></p>
<blockquote>
<ul>
<li>在<code>postProcessBeanFactory()</code>方法中回调了<code>processConfigurationBeanDefinitions((BeanDefinitionRegistry) beanFactory)</code>方法来解析了<code>@Component</code>、<code>@Configuration</code>等注解</li>
<li>调用<code>enhanceConfigurationClasses(beanFactory)</code>来进行<code>CGLIB</code>代理，这里只会代理配置类为<code>Full</code>的类</li>
<li>然后向<code>beanFactory</code>中添加一个<code>ImportAwareBeanPostProcessor</code>后置处理器</li>
</ul>
</blockquote>
</li>
<li><p>再一次调用<code>invokeBeanFactoryPostProcessors</code>，执行<code>BeanFactoryPostProcessor</code>的方法，但是这里<code>regularPostProcessors</code>一般情况下是不会有数据的，只有在外部通过手动添加<code>BeanFactoryPostProcessor</code>，才会有数据。</p>
</li>
<li><p>查找实现了<code>BeanFactoryPostProcessor</code>的后置处理器，并且执行后置处理器方法。下面的逻辑和上面的步骤类似，这里就不在列举了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 这里不进行初始化FactoryBeans，而是让bean工厂后置处理器去初始化这些常规的bean */</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">		beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,Ordered, and the rest.</span></span><br><span class="line"><span class="comment">/** 分离出 orderedPostProcessorNames 和nonOrderedPostProcessorNames */</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环BeanNames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果这个bean被执行过了，则跳过不执行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">		<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果bean实现了PriorityOrdered接口，则加入到priorityOrderedPostProcessors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">		priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果bean实现了Ordered接口，则加入到orderedPostProcessorNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">		orderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 既没有实现PriorityOrdered接口，也没有实现Ordered接口，则加入到nonOrderedPostProcessorNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、调用实现PriorityOrdered接口的bean工厂后置处理器</span></span><br><span class="line"><span class="comment"> * 排序处理priorityOrderedPostProcessors,即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行priorityOrderedPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、调用实现Ordered接口实现的bean后置处理器</span></span><br><span class="line"><span class="comment"> * 执行实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">	orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、调用其他所有的bean后置处理器</span></span><br><span class="line"><span class="comment"> * 执行既没有实现PriorityOrdered接口也没有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">	nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 这里会调用EventListenerMethodProcessor.postProcessBeanFactory(),注册事件监听器后置处理器 */</span></span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br></pre></td></tr></table></figure>

<p>最后附上<code>invokeBeanFactoryPostProcessor</code>方法中执行流程图，结合历程图更容易理解整个流程</p>
<p><img src="/archives/e74be873/IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-invokeBeanFactoryPostProcessor.png" alt="IOC加载流程-invokeBeanFactoryPostProcessor"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
</search>
