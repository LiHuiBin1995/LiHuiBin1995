<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github搭建博客详细教程</title>
    <url>/archives/8eb04e19/</url>
    <content><![CDATA[<p>经历了两天的折腾，终于搭建好了个人博客。由于第一次搭建个人博客，所以在搭建过程中也遇到了很多的问题。现在特意整理一下整个搭建过程以及中间遇到的问题。</p>
<h4 id="一、软件准备"><a href="#一、软件准备" class="headerlink" title="一、软件准备"></a>一、软件准备</h4><ul>
<li><a href="https://git-scm.com/downloads">安装Git</a></li>
</ul>
<p><img src="/archives/8eb04e19/image-20210727204933786-16274456504351.png" alt="image-20210727204933786"></p>
<p>根据系统需求下载对应的版本，这里下载windows版本</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/download/">安装Node.js</a></li>
<li>安装Hexo</li>
</ul>
<p>默认已经安装以上两个软件，接下来安装Hexo。在任意文件夹中打开<code>CMD</code>窗口执行如下指令安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>等待大概一分钟安装完毕，执行<code>hexo -v</code> 如果出现版本信息，说明安装成功。</p>
<h4 id="二、创建git远程仓库"><a href="#二、创建git远程仓库" class="headerlink" title="二、创建git远程仓库"></a>二、创建git远程仓库</h4><p>1、如果还没有github账号，需要先注册账号。如果不会注册直接百度就可以，类似的教程百度有很多；这里默认都注册过了github。接下来登录github创建仓库：如下图</p>
<p><img src="/archives/8eb04e19/image-20210727221144333.png" alt="image-20210727221144333"></p>
<blockquote>
<p><strong>特别需要注意的是 第一步中仓库名称必须是Ower.github.io 格式，其中Ower是用户名。如果不是这个格式的话，后面使用hexo生成的静态页面会识别不了</strong></p>
</blockquote>
<p>2、以上步骤完成之后，在电脑本地创建一个文件夹，存放我们的本地blog。</p>
<p><img src="/archives/8eb04e19/image-20210727222117448.png" alt="image-20210727222117448"></p>
<p>3、打开CMD命令窗口，并且cd到blog文件中执行初始化blog工程指令<code>hexo init</code></p>
<p><img src="/archives/8eb04e19/image-20210727223759193.png" alt="image-20210727223759193"></p>
<p>完毕之后目录结构如下：</p>
<p><img src="/archives/8eb04e19/image-20210727223938616.png" alt="image-20210727223938616"></p>
<blockquote>
<p>想要详细了解目录结构可以查看hexo官网 <a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p>
</blockquote>
<p>4、配置blog工程中的<code>_config.yml</code>文件</p>
<p><img src="/archives/8eb04e19/image-20210727224818946.png" alt="image-20210727224818946"></p>
<p><img src="/archives/8eb04e19/image-20210727225056195.png" alt="image-20210727225056195"></p>
<p>这里主要是设置上图中圈中的三个地方，这里解释一下三个代表什么:</p>
<ul>
<li><code>url</code>: 表示将来访问仓库博客的地址，其格式为”https://仓库名称”</li>
<li><code>theme</code>: 表示博客要使用的主题，默认使用<code>landscape</code>，如果是不想使用默认主题，可以到<a href="https://hexo.io/themes/">hexo官网</a>找自己喜欢的主题。当然如果自己有web相关基础的话也可以自己参照<a href="https://hexo.io/zh-cn/docs/themes">hexo官网自定义主题</a></li>
<li><code>type</code>: 表示博客将来要发布到哪个服务器，这里我们选择发布到<code>git</code></li>
<li><code>repo</code>: 表示发布到<code>git</code>中的哪个仓库里，这里我们是发布到上面创建的仓库中<code>https://github.com/li-huibin/li-huibin.github.io</code></li>
</ul>
<blockquote>
<p>注意这里设置的repo 地址是仓库地址，而不是https://仓库名称。应该是如下图红框中的地址，这里不能设置错了，否则会访问不到博客</p>
<p><img src="/archives/8eb04e19/image-20210727230856137.png" alt="image-20210727230856137"></p>
</blockquote>
<ul>
<li><code>branch</code>: 表示发布到仓库的哪个分支，默认<code>master</code></li>
</ul>
<p>到此为止，个人博客基本搭建完毕。接下来在<code>cmd</code>中编译工程，然后启动本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo generate</span><br><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo server</span><br></pre></td></tr></table></figure>

<p><img src="/archives/8eb04e19/image-20210727231758842.png" alt="image-20210727231758842"></p>
<p>本地服务启动后，hexo默认地址是<a href="http://localhost:4000/">http://localhost:4000</a> 。我们访问这个地址就可以看到本地的博客服务了</p>
<p><img src="/archives/8eb04e19/image-20210727231930894.png" alt="image-20210727231930894"></p>
<p>5、将本地博客发布到git仓库</p>
<p>执行如下指令将我们的本地博客发布到刚刚创建的远程git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo deploy</span><br></pre></td></tr></table></figure>

<p>然后，就可以直接在浏览器中访问<code>https://li-huibin.github.io</code>来访问博客了。到此为止博客搭建完毕。</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理</title>
    <url>/archives/81aeb1f/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Spring中最重要的就属<code>IOC</code>了，不论是在面试中，还是在一些中间件与Spring的继承中，都离不开<code>IOC</code>，下面就来瞧瞧<code>IOC</code>是个什么东西，他是怎么一个加载流程，先大致粗略的了解一下！</p>
<h2 id="一、下载Spring源码"><a href="#一、下载Spring源码" class="headerlink" title="一、下载Spring源码"></a>一、<a href="https://gitee.com/li-huibin/spring-framework-5.2.16.-release">下载Spring源码</a></h2><h2 id="二、编译Spring源码"><a href="#二、编译Spring源码" class="headerlink" title="二、编译Spring源码"></a>二、编译Spring源码</h2><p>在编译的时候有些包是需要从外网下载的，有条件的可以科学上网，这样可以加快编译速度。如果不管怎么编译都是报错，或者下载包总是失败，可以留言我，我可以提供一点有限的帮助。</p>
<h2 id="三、创建demo模块"><a href="#三、创建demo模块" class="headerlink" title="三、创建demo模块"></a>三、创建demo模块</h2><p><img src="/archives/81aeb1f/image-20210813193225670.png" alt="创建demo模块"></p>
<blockquote>
<p><strong>注意：</strong> 一定要选择<code>Gradle</code>，别选错了，因为从<code>Spring5</code>开始，使用的是<code>Gradle</code>来构建整个项目的</p>
</blockquote>
<p><img src="/archives/81aeb1f/image-20210813193542786.png" alt="创建demo模块-2"></p>
<p>这里因为我已经事先创建过了模块，所以上面会有一个报错。然后点<code>Finish</code>完成创建。</p>
<p>创建完毕之后，在初始化模块的目录结构，我的目录结构是如下结构：</p>
<p><img src="/archives/81aeb1f/image-20210813193846621.png" alt="demo模块目录结构"></p>
<p>这里我创建了三个类<code>ApplicationMain</code>启动类、<code>TestIOC</code>接口、实现<code>TestIOC</code>接口的<code>TestIOCImpl</code>实现类。</p>
<p><code>TestIOC.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestIOC</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloIOC</span><span class="params">(String say)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>TestIOCImpl.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.TestIOC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIOCImpl</span> <span class="keyword">implements</span> <span class="title">TestIOC</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloIOC</span><span class="params">(String say)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;====&gt; &quot;</span> + say);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationMain.java</code>启动类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.impl.TestIOCImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1 mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lhb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br><span class="line">		TestIOCImpl bean = applicationContext.getBean(TestIOCImpl.class);</span><br><span class="line">		bean.helloIOC(<span class="string">&quot;hello spring ioc&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、IOC主流程分析"><a href="#四、IOC主流程分析" class="headerlink" title="四、IOC主流程分析"></a>四、<code>IOC</code>主流程分析</h2><p>首先，肯定是要从整个程序的入口开始分析的，下面就从<code>ApplicationMain</code>中的<code>main</code>方法开始。从上图中我们可以看到在<code>ApplicationMain</code>类中的<code>main</code>方法中手动创建了一个<code>AnnotationConfigApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br></pre></td></tr></table></figure>

<p>嗯？？what.<code>AnnotationConfigApplicationContext</code>是一个什么东西。。为什么要创建这个东西；那么就带着这个疑问点到他的源码里看一看。<code>Ctrl</code>+鼠标左键走起。</p>
<p><img src="/archives/81aeb1f/image-20210813200002798.png" alt="AnnotationConfigApplicationContext.java"></p>
<p>这两个名叫<code>Juergen Hoeller和Chris Beams</code>的作者给写了一大片注释，大概意思就是<code>AnnotationConfigApplicationContext</code>是整个引用的上下文，可以用他来获取容器中的Bean，和注册Bean等；<code>AnnotationConfigApplicationContext</code>实现会这继承了Spring框架中大部分的基础能力，一切Spring的动作，都是从这个类开始进行的，并且整个过程也都是这个类来进行接管的；所以它也是比较强大；总之大部分容器中的和Bean的操作都可以通过<code>AnnotationConfigApplicationContext</code>来操作。</p>
<p><img src="/archives/81aeb1f/image-20210813201436746.png" alt="AnnotationConfigApplicationContext关系图"></p>
<p>从上面的<code>AnnotationConfigApplicatioinContext</code>类关系图中可以看出，这个类其实比较复杂的。好了这个类先聊到这里，接下来我们看到<code>AnnotationConfigApplicationContext</code>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext, deriving bean definitions</span></span><br><span class="line"><span class="comment"> * from the given component classes and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> componentClasses one or more component classes &amp;mdash; for example,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	 * 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	 * DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	 * 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	 * 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	 * 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">this</span>();</span><br><span class="line">	<span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	 * 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	 * 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	 * 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	register(componentClasses);</span><br><span class="line">	<span class="comment">/** 刷新 */</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中调用了三个方法，下面一一说一下这三个方法都干了什么</p>
<blockquote>
<p><strong><code>this();</code>：</strong>这个方法调用了本类的无参数构造函数，其实在调用<code>AnnotationConfigApplicationContext</code>的无参数构造方法之前，先调用的父类的构造方法。在这些方法中主要是做了一些初始化的操作，比如初始化我们的容器<code>beanDefinitionMap</code>，初始化资源读取器<code>AnnotationBeanDefinitionReader</code>和资源扫描器<code>BeanDefinitionScanner</code>等</p>
<p><strong><code>register(componentClasses)</code>：</strong> 这个方法很重要；在这个方法中会扫描所有的Bean，并且会把扫描出来的Bean定义进行注册；Spring还会在这里把带有<code>@Configuration</code>注解的类进行标记为<code>Full</code>配置类，不带<code>@Configuration</code>注解的类但是有<code>@Component</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportSource</code>、<code>@Server</code>等注解的类标记为<code>Lite</code>配置类，然后被标记为<code>Full</code>的配置类会进行<code>CGLIB</code>代理增强处理。</p>
<blockquote>
<p><em><strong>Spring的循环依赖也是在这个过程中解决的，后面会详细看这个方法</strong></em>    </p>
</blockquote>
<p><strong><code>refresh()</code>：</strong> 这个方法很重要，几乎Spring所有的启动动作都会在这个方法来完成的。在这里会准备Bean工厂，为Bean工厂设置一些依赖到的接口，也会添加后置处理器，注册类的后置处理器，注册Bean工厂后置处理器，解析<code>@Import</code>、<code>@Component</code>注解、注册Bean后置处理器、初始化事件、实例化Bean等操作、发布初始化完成事件等操作；这个方法后面也会详细看</p>
</blockquote>
<p>下面通过一个图来回顾总结一下整个流程：</p>
<p><img src="/archives/81aeb1f/IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="Spring-IOC原理"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo静态页面图片不显示问题</title>
    <url>/archives/e4419141/</url>
    <content><![CDATA[<p>hexo静态页面图片不显示一般有几个原因：</p>
<p>1、<code>_config.yml</code>中没有设置<code>post_asset_folder: true</code>；这个设置默认是false</p>
<p>2、没有安装插件 asset-image</p>
<p>如果在运行工程之前上面两个步骤都没有操作过，则首先需要在<code>_config.yml</code>中设置<code>post_asset_folder:true</code> 。然后在cmd中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>由于国内网络环境，可能需要多下载几次才可以下载成功，要耐心等待。或者有条件的可以翻墙下载。</p>
<p>以上操作完毕之后重新发布工程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>页面效果如下：</p>
<p><img src="/archives/e4419141/image-20210728134047043.png" alt="image-20210728134047043"></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/archives/ccff2b22/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是Java中最常用的设计模式之一。在我们悉知的Spring中源码中的bean创建就是使用了工厂模式；这种类型的设计模式属于创建型模式，他提供一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>日志记录器：记录磁盘信息、业务事件、访问服务器信息等，让用户来选择日志记录到哪里。</li>
<li>连接服务器使用不同的协议，<code>POP3</code>、<code>IMAP</code>、<code>HTTP</code>三个协议可以用同一个接口来实现。</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>当一个调用者想创建对象时，只需要知道对象名字即可</li>
<li>扩展性高，如果需要增加新的类品，只需要新增一个工厂类即可</li>
<li>隐藏产品的具体实现，让调用者只关心接口</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>每次新增一个产品都需要新增一个产品工厂类，增加了系统复杂度。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>工厂模式在Spring源码中的应用解析：</p>
<p>我们知道在Spring中，如果我们想要通过容器去创建一个bean就需要调用一下代码来实现bean创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br><span class="line">TestIOCImpl bean = applicationContext.getBean(TestIOCImpl.class);</span><br></pre></td></tr></table></figure>

<p>其实<code>ApplicationContext</code>创建bean就是使用到了工厂模式。在上面的代码中，我们并没有显式的通过<code>new</code>去创建一个<code>TestIOCImpl</code>,通过调用<code>applicationContext.getBean()</code>传入一个bean的class来实例化；具体创建过程则交给了<code>ApplicationContext</code>去实现了。</p>
<p>首先来看看<code>ApplicationContext</code>整体的继承关系，也就是工厂模式的继承关系</p>
<p><img src="/archives/ccff2b22/image-20210810151313670.png" alt="ApplicationContext.java"></p>
<p><code>ApplicationContext</code>接口继承了一个最顶层的工厂类<code>BeanFactory</code>，来继续看看<code>BeanFactory</code>中有些什么方法呢。</p>
<p><img src="/archives/ccff2b22/image-20210810151723712.png" alt="BeanFactory.java"></p>
<p>看到这里是不是就会有点想法，我们在上面的代码中调用的<code>getBean(Class class)</code>是不是就是调用的这里的方法呢？具体实现那肯定就是在子类中去实现的喽。因为我们一开始的代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br></pre></td></tr></table></figure>

<p>创建的<code>ApplicationContext</code>接口实现类其实是<code>AnnotationConfigApplicationContext</code>类型，那么在<code>AnnotationConfigApplicationContext</code>类中是不是也实现了<code>getBean</code>的一些方法？实际上spring并没有在<code>AnnotationConfigApplicationContext</code>中去实现这些方法，而是通过一个抽象类<code>AbstractApplicationContext</code>来实现了<code>ApplicationContext</code>接口中的<code>getBean</code>一系列方法。这样做的目的也是为了提高后期的扩展性，毕竟spring这么强大，扩展性肯定是必须要很强的。</p>
<p><img src="/archives/ccff2b22/image-20210810152406751.png" alt="AnnotationConfigApplicationContext.java关系图"></p>
<p><code>AbstractApplicationContext</code>中实现<code>getBean</code>系列方法的代码：</p>
<p><img src="/archives/ccff2b22/image-20210810153412546.png" alt="getBean(...)代码实现"></p>
<p>以上就是在Spring中创建Bean所用到的工厂设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
