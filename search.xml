<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java垃圾收集器之ZGC剖析</title>
    <url>/archives/a87613ac/</url>
    <content><![CDATA[<h2 id="ZGC诞生背景"><a href="#ZGC诞生背景" class="headerlink" title="ZGC诞生背景"></a>ZGC诞生背景</h2><p>在Java中，JVM在进行垃圾回收的时候，有一个很大的问题，就是STW(Stop The World)，即JVM要进行垃圾回收时，会暂停所有的业务线程。导致所有业务系统暂停，直接降低了用户体验；所以目前市面上所有的垃圾回收器优化方向也是朝着怎么缩短STW方向，进而提升用户体验。</p>
<p><img src="/archives/a87613ac/image-20220430232058737.png" alt="STW(Stop The World)"></p>
<h2 id="垃圾回收器的发展"><a href="#垃圾回收器的发展" class="headerlink" title="垃圾回收器的发展"></a>垃圾回收器的发展</h2><p>为了满足不同的业务需求，Java垃圾回收器的算法也在不停的迭代，对于特定的一个应用，选择其最合适的GC算法，才能更高效率的实现业务目标。尤其是近些年来伴随着各种高并发，超高并发应用的使用，要求JVM要能适应超低停顿时间，同时也带给JVM带来了应对大堆和超大堆的挑战，基于此，2018年在发布的JDK11中，加入了ZGC(<code>A Scalable Low-Latency Garbage Collector</code>) 垃圾回收器</p>
<p><img src="/archives/a87613ac/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="垃圾回收器"></p>
<h2 id="ZGC介绍"><a href="#ZGC介绍" class="headerlink" title="ZGC介绍"></a>ZGC介绍</h2><p>ZGC(<code>The Z Garbage Collector</code>) 是JDK11中推出的追求低延迟的垃圾回收器，其特点包括：</p>
<ul>
<li>停顿时间不超过100ms，在JDK16中已经达到了不超过1ms；</li>
<li>停顿时间不会随着堆大小或者活跃对象的增加而增加；</li>
<li>支持8MB~4TB级别的堆，JDK15已经可以支持16TB；</li>
</ul>
<h2 id="ZGC中的内存布局"><a href="#ZGC中的内存布局" class="headerlink" title="ZGC中的内存布局"></a>ZGC中的内存布局</h2><p>为了细粒度的控制内存的分配，和G1一样，ZGC将内存划分成小的分区，在ZGC中成为页面(<code>page</code>)。所以在ZGC中是没有新生代、老年代的分代概念。</p>
<p>ZGC中支持3种页面，分别是小页面、中页面、大页面。其中小页面指的是2MB的页面空间，中页面指的是32MB的页面空间，大页面指的是受操作系统控制的大页面。</p>
<p><img src="/archives/a87613ac/ZGC%E9%A1%B5%E9%9D%A2.png" alt="ZGC页面"></p>
<blockquote>
<p>当对象大小小于等于256KB时，对象分配在小页面</p>
<p>当对象大小大于256KB小于4MB之间，对象分配在中页面</p>
<p>当对象大小大于4MB，对象分配在大页面</p>
<p>ZGC对于不同页面回收策略是不同的。也就是说，<strong>小页面优先回收，中页面和大页面则尽量不回收</strong></p>
</blockquote>
<h2 id="ZGC核心概念"><a href="#ZGC核心概念" class="headerlink" title="ZGC核心概念"></a>ZGC核心概念</h2><h3 id="染色指针-Color-Pointers"><a href="#染色指针-Color-Pointers" class="headerlink" title="染色指针(Color Pointers)"></a>染色指针(Color Pointers)</h3><p>颜色指针可以说是ZGC的核心概念。因为它在指针中借了几位来做指针染色，所以它必须要求在64位机器上才可以工作。并且因为要求64位的指针，也就不能支持压缩指针。</p>
<p><img src="/archives/a87613ac/ZGC%E4%B8%AD64%E4%BD%8D%E6%8C%87%E9%92%88%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8.png" alt="ZGC中64位指针虚拟空间使用."></p>
<blockquote>
<p>ZGC中低42位表示使用中的堆空间</p>
<p>ZGC借几位高位来做GC相关的事情(快速实现垃圾回收中的并发标记、转移和重定位等)</p>
</blockquote>
<h2 id="ZGC垃圾回收流程"><a href="#ZGC垃圾回收流程" class="headerlink" title="ZGC垃圾回收流程"></a>ZGC垃圾回收流程</h2><p>一次ZGC垃圾回收流程包括两个阶段</p>
<ol>
<li>标记阶段(标记垃圾)</li>
<li>转移阶段(对象复制或移动)</li>
</ol>
<p><img src="/archives/a87613ac/ZGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B.png" alt="ZGC垃圾回收流程"></p>
<blockquote>
<ol>
<li><p><strong>初始阶段：</strong> </p>
<p>在ZGC初始化之后，此时地址视图位Remapped，程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动。</p>
</li>
<li><p><strong>初始标记：</strong> </p>
<p>这个阶段需要暂停用户线程(STW)，初始标记只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，停顿时间不会随着堆的大小或者活跃对象的大小而增加。</p>
</li>
<li><p><strong>并发标记：</strong> </p>
<p>这个阶段不需要暂停(没有STW)，根据初始标记找到的根对象，使用深度优先遍历对象的成员变量进行标记，来扫描剩余的所有对象，这个处理时间比较长，所以通过并发处理，业务线程与GC线程同时运行。但是这个阶段会产生漏标问题(可用过增量更新和原始快照<code>SATB</code>来解决)。</p>
</li>
<li><p><strong>再标记：</strong> </p>
<p>这个阶段需要暂停(STW)，主要是处理并发标记中漏标的对象，通过原始快照(SATB)算法解决(G1中的解决漏标的方案)</p>
</li>
</ol>
</blockquote>
<h3 id="ZGC染色指针的并发转移算法"><a href="#ZGC染色指针的并发转移算法" class="headerlink" title="ZGC染色指针的并发转移算法"></a>ZGC染色指针的并发转移算法</h3><h4 id="ZGC转移阶段分为三步"><a href="#ZGC转移阶段分为三步" class="headerlink" title="ZGC转移阶段分为三步"></a>ZGC转移阶段分为三步</h4><ul>
<li>并发转移准备(分析最有价值GC分页，该阶段无STW)</li>
<li>初始转移（转移初始标记的存活的对象，同时做对象重定位，该阶段有STW）</li>
<li>并发转移（对并发标记的存活对象做转移，该阶段无STW）；并发转移阶段因为GC线程和用户线程同时执行，所以在转移过程中借助转发表来完成对象转移。</li>
</ul>
<h2 id="图解ZGC垃圾回收过程"><a href="#图解ZGC垃圾回收过程" class="headerlink" title="图解ZGC垃圾回收过程"></a>图解ZGC垃圾回收过程</h2><ol>
<li><p>初始标记</p>
<p><img src="/archives/a87613ac/ZGC%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0.png" alt="初始标记"></p>
</li>
<li><p>并发标记</p>
<p><img src="/archives/a87613ac/ZGC%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0.png" alt="并发标记"></p>
<blockquote>
<p>并发标记中，用户线程和GC线程同时进行。所以这个阶段会产生浮动垃圾，即漏标。漏标可以通过增量更新和原始快照(SATB)两种方式去解决。</p>
</blockquote>
</li>
<li><p>再标记</p>
<p><img src="/archives/a87613ac/ZGC%E5%86%8D%E6%A0%87%E8%AE%B0.png" alt="再标记"></p>
<blockquote>
<p>这个阶段主要解决再并发标记过程中漏标的对象，此阶段STW</p>
</blockquote>
</li>
<li><p>初始转移</p>
<p><img src="/archives/a87613ac/ZGC%E5%88%9D%E5%A7%8B%E8%BD%AC%E7%A7%BB.png" alt="初始转移"></p>
<blockquote>
<p>这个阶段主要转移初始标记阶段标记的对象</p>
</blockquote>
</li>
<li><p>并发转移</p>
<p><img src="/archives/a87613ac/ZGC%E5%B9%B6%E5%8F%91%E8%BD%AC%E7%A7%BB.png" alt="并发转移"></p>
<blockquote>
<p>这个阶段转移并发标记阶段的对象，因为这个阶段用户线程和GC线程同步进行，所以会有对象正在使用，如果此时将正在使用的对象转移到新的地址，而正在使用的对象还是旧的地址，此时就会有问题，为了解决这个问题，这个阶段使用了转发表来记录转移对象的新地址和旧地址映射关系。等到下一个ZGC垃圾回收阶段，再回收转发表中的对象。</p>
</blockquote>
</li>
</ol>
<h3 id="根可达分析算法"><a href="#根可达分析算法" class="headerlink" title="根可达分析算法"></a>根可达分析算法</h3><p>在ZGC中，判断对象是否存活，是通过<code>根可达分析算法</code>来实现的，这个算法的基本思路就是通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(<code>Reference Chain</code>)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p><img src="/archives/a87613ac/%E6%A0%B9%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="根可达性分析算法"></p>
<p>作为GC Roots的对象主要包括以下4种：</p>
<ul>
<li>虚拟机栈(栈帧种的本地变量表)：各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>方法区中类静态变量：Java类的引用类型静态变量。</li>
<li>方法区中常量：比如：字符串常量池里的引用。</li>
<li>本地方法栈中JNI指针：(即一般说的Native方法)</li>
</ul>
<h2 id="ZGC参数设置"><a href="#ZGC参数设置" class="headerlink" title="ZGC参数设置"></a>ZGC参数设置</h2><p>ZGC优势不仅仅再其超低的STW停顿时间，也在于其参数的简单，绝大多数生产场景都可以自动适应。当然，在有些情况下也可能对个别的ZGC参数做调整，参数大致可以分为三类：</p>
<ul>
<li><p><strong>堆大小：</strong> -Xmx</p>
<p>当分配速率过高，超过回收速率，造成堆内存不够用时，会触发Allocation Stall，这个类Stall会减缓当前的用户线程。因此，当我们在GC日志中看到Allocation Stall，通常可以认为堆空间偏小或者concurrent gc threads数偏小。</p>
</li>
<li><p><strong>GC触发时机：</strong> ZAllocatioSpike Tolerance，ZCollectionInterval。</p>
<p>ZAllocationSpikeTolerance 用来估算当前的堆内存分配速率，在当前剩余的堆内存下，ZAllocationSpike Tolerance越大，估算的达到OOM的时间越快，ZGC就会更早地进行触发GC。ZCollectionInterval用来指定GC发生的间隔，以秒位单位触发GC</p>
</li>
<li><p><strong>GC线程：</strong> ParallerGCThreads，ConcGCThreads。</p>
<p>ParallelGCThreads是设置STW任务的GC线程数，默认为CPU个数的60%；ConcGCThreads是并发阶段GC线程的数目，默认为CPU个数的12.5%。增加GC线程数目，可以加快GC完成任务，减少各个阶段的时间，但也会增加CPU的抢占开销。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>垃圾收集器之ZGC</category>
      </categories>
      <tags>
        <tag>Java垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装配置Redis</title>
    <url>/archives/a813391e/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>Redis版本 6.2.5</li>
<li>服务器版本 Linux Centos 7.6 64位</li>
</ul>
<h2 id="下载Redis"><a href="#下载Redis" class="headerlink" title="下载Redis"></a>下载Redis</h2><p>进入官网下载地址<a href="https://redis.io/download">https://redis.io/download</a></p>
<p><img src="/archives/a813391e/image-20210914123642204.png" alt="Redis官网"></p>
<p>选择对应的版本，这里我选择的是Stable版，右键Download按钮，选择复制链接。进入到MobaXtream控制台，并打开我们默认建好的目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.5.tar.gz</span><br></pre></td></tr></table></figure>

<p>回车后如下图</p>
<p><img src="/archives/a813391e/image-20210914124512088.png" alt="Redis下载"></p>
<p>等待下载完毕</p>
<h2 id="解压并安装Redis"><a href="#解压并安装Redis" class="headerlink" title="解压并安装Redis"></a>解压并安装Redis</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>下载完成后需要将压缩文件解压，输入以下命令解压到当前目录</p>
<p><img src="/archives/a813391e/image-20210914124700732.png" alt="解压Redis"></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译需要gcc，所以在编译之前需要执行<code>yum install gcc</code>来安装gcc环境，等待安装完毕之后进入到解压文件夹，并执行编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.5</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><img src="/archives/a813391e/image-20210914125434056.png" alt="编译完成"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>输入一下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make PREFIX=/home/redis/build install</span><br></pre></td></tr></table></figure>

<p>这里多了一个关键字 <strong><code>PREFIX=</code></strong> 这个关键字的作用是编译的时候用于指定程序存放的路径。比如我们现在就是指定了redis必须存放在/home/redis/build目录。假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录，库文件会存放在/usr/local/lib目录。配置文件会存放在/usr/local/etc目录。其他的资源文件会存放在usr/local/share目录。这里指定号目录也方便后续的卸载，后续直接rm -rf /home/redis/build 即可删除redis。</p>
<p>执行结果如下图:</p>
<p><img src="/archives/a813391e/image-20210914130201598.png" alt="安装Redis"></p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>执行一下命令将配置文件拷贝到安装目录/home/redis/build/bin</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /home/redis/redis-6.2.5/redis.conf /home/redis/build/bin</span><br></pre></td></tr></table></figure>

<p><img src="/archives/a813391e/image-20210914130546712.png" alt="拷贝配置文件"></p>
<p>修改该配置文件中一下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6379</span><br><span class="line">pidfile /var/run/redis_6379.pid  # 把pid进程号写入pidfile配置的文件</span><br><span class="line">logfile &quot;/home/redis/build/log/6379.log&quot;</span><br><span class="line">dir /home/redis/build/data  # 指定数据存放目录</span><br><span class="line"># 需要注释掉bind</span><br><span class="line"># bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）</span><br><span class="line">daemonize yes #后台启动方式</span><br><span class="line">protected-mode no  #关闭保护模式，开启的话，只有本机才可以访问redis</span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-server redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="验证是否启动成功"><a href="#验证是否启动成功" class="headerlink" title="验证是否启动成功"></a>验证是否启动成功</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p><img src="/archives/a813391e/image-20210914134023196.png" alt="image-20210914134023196"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty核心源码解析</title>
    <url>/archives/b4dafe2/</url>
    <content><![CDATA[<h2 id="Netty线程模型图"><a href="#Netty线程模型图" class="headerlink" title="Netty线程模型图"></a>Netty线程模型图</h2><p><img src="/archives/b4dafe2/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="Netty线程模型图"></p>
<h2 id="Netty线程模型源码解析图"><a href="#Netty线程模型源码解析图" class="headerlink" title="Netty线程模型源码解析图"></a><a href="https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&page-id=fAExpZiIWca5xK1e2uDy&title=Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9B%BE.drawio#Uhttps%3A%2F%2Fraw.githubusercontent.com%2Fli-huibin%2Fstudy-java%2Fmain%2Fnetty%2FNetty%25E7%25BA%25BF%25E7%25A8%258B%25E6%25A8%25A1%25E5%259E%258B%25E5%259B%25BE.drawio">Netty线程模型源码解析图</a></h2><p><img src="/archives/b4dafe2/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E5%9B%BE.png" alt="Netty线程模型源码解析图"></p>
<h2 id="Netty高并发架构设计妙处"><a href="#Netty高并发架构设计妙处" class="headerlink" title="Netty高并发架构设计妙处"></a>Netty高并发架构设计妙处</h2><ul>
<li>主从Reactor线程模型</li>
<li>NIO多路复用非阻塞</li>
<li><strong>无锁串行化</strong>设计思想</li>
<li>支持高性能序列化协议</li>
<li>零拷贝(使用直接内存)</li>
<li>ByteBuf内存池设计</li>
<li>灵活的TCP参数配置能力</li>
<li>并发优化</li>
</ul>
<h3 id="无锁串行化设计"><a href="#无锁串行化设计" class="headerlink" title="无锁串行化设计"></a>无锁串行化设计</h3><p>在大多数场景下，并行多线程处理可以提升系统的并发性能。但是对于共享资源的并发处理不当的话，会带来严重的锁竞争，从而导致性能下降。为了解决并发锁竞争带来的性能损耗，可以通过串行化的方式，即所有的处理都是在一个线程中完成的，期间不会进行线程之间的切换，避免了多线程的竞争和同步锁。NIO的多路复用就是一种无锁串行化的设计思想(可以理解一下Redis和Netty的线程模型)，为了尽可能提升性能，Netty采用了串行化无锁设计，在IO线程内部进行串行操作，避免了多线程导致的性能下降。表面上看是CPU利用率不高，并发程度不够，但是可以通过调整NIO线程参数，可以同时启动多个串行化的线程并行运行，这种局部无所华串行线程设计相比一个队列-多个工作线程模型性能更优。</p>
<p>Netty的NioEventLoop读取到消息后，直接调用ChannelPipeline的fireChannelRead(Object msg),只要用户不主动切换线程，一直会由NioEventLoop调用用户的Handler，期间不进行线程切换，这种串行化处理方式可以避免多线程操作导致的锁竞争，从性能上看是最优的。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，某些情况下这部分内存也会被频繁的使用，而且也可能导致OutOfMemoryError异常出现。Java里用的DirectByteBuffer可以分配一块直接内存(堆外内存)，元空间对应的内存也叫作直接内存，他们对应的都是机器的直接物理内存。</p>
<p><img src="/archives/b4dafe2/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="直接内存结构图"></p>
<p>直接内存和堆内存区别代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存与堆内存的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//分配堆内存</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.putInt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.getInt();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;堆内存访问:&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//分配直接内存</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.putInt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.getInt();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存访问:&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAllocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;堆内存申请:&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directAllocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            ByteBuffer.allocateDirect(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存申请:&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heapAccess();</span><br><span class="line">            directAccess();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heapAllocate();</span><br><span class="line">            directAllocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">堆内存访问:44ms</span><br><span class="line">直接内存访问:29ms</span><br><span class="line">堆内存访问:33ms</span><br><span class="line">直接内存访问:19ms</span><br><span class="line">堆内存访问:55ms</span><br><span class="line">直接内存访问:38ms</span><br><span class="line">堆内存访问:39ms</span><br><span class="line">直接内存访问:20ms</span><br><span class="line">堆内存访问:38ms</span><br><span class="line">直接内存访问:18ms</span><br><span class="line">堆内存访问:36ms</span><br><span class="line">直接内存访问:19ms</span><br><span class="line">堆内存访问:34ms</span><br><span class="line">直接内存访问:19ms</span><br><span class="line">堆内存访问:40ms</span><br><span class="line">直接内存访问:20ms</span><br><span class="line">堆内存访问:37ms</span><br><span class="line">直接内存访问:24ms</span><br><span class="line">堆内存访问:59ms</span><br><span class="line">直接内存访问:25ms</span><br><span class="line"></span><br><span class="line">堆内存申请:11ms</span><br><span class="line">直接内存申请:36ms</span><br><span class="line">堆内存申请:13ms</span><br><span class="line">直接内存申请:52ms</span><br><span class="line">堆内存申请:62ms</span><br><span class="line">直接内存申请:40ms</span><br><span class="line">堆内存申请:2ms</span><br><span class="line">直接内存申请:37ms</span><br><span class="line">堆内存申请:1ms</span><br><span class="line">直接内存申请:81ms</span><br><span class="line">堆内存申请:2ms</span><br><span class="line">直接内存申请:23ms</span><br><span class="line">堆内存申请:1ms</span><br><span class="line">直接内存申请:31ms</span><br><span class="line">堆内存申请:2ms</span><br><span class="line">直接内存申请:32ms</span><br><span class="line">堆内存申请:7ms</span><br><span class="line">直接内存申请:41ms</span><br><span class="line">堆内存申请:8ms</span><br><span class="line">直接内存申请:142ms</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述程序运行结果看出：</p>
<p>直接内存申请比较慢，但是访问效率高。在Java虚拟机实现上，本地IO一般会直接操作直接内存(直接内存→系统调用→硬盘/网卡)，而非直接内存则需要二次拷贝(堆内存→直接内存→系统调用→硬盘/网卡)。</p>
</blockquote>
<h4 id="直接内存分配源码解析"><a href="#直接内存分配源码解析" class="headerlink" title="直接内存分配源码解析"></a>直接内存分配源码解析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">DirectByteBuffer</span>(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="number">-1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    boolean pa = VM.<span class="built_in">isDirectMemoryPageAligned</span>();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.<span class="built_in">pageSize</span>();</span><br><span class="line">    <span class="keyword">long</span> size = Math.<span class="built_in">max</span>(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//判断是否有足够的直接内存空间分配，可通过-XX:MaxDirectMemorySize=&lt;size&gt;参数指定直接内存最大可分配空间，如果不指定默认为最大堆内存大小，</span></span><br><span class="line">    <span class="comment">//在分配直接内存时如果发现空间不够会显示调用System.gc()触发一次full gc回收掉一部分无用的直接内存的引用对象，同时直接内存也会被释放掉</span></span><br><span class="line">    <span class="comment">//如果释放完分配空间还是不够会抛出异常java.lang.OutOfMemoryError</span></span><br><span class="line">   Bits.<span class="built_in">reserveMemory</span>(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用unsafe本地方法分配直接内存</span></span><br><span class="line">        base = unsafe.<span class="built_in">allocateMemory</span>(size);</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// 分配失败，释放内存</span></span><br><span class="line">        Bits.<span class="built_in">unreserveMemory</span>(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.<span class="built_in">setMemory</span>(base, size, (byte) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Cleaner机制注册内存回收处理函数，当直接内存引用对象被GC清理掉时，</span></span><br><span class="line">    <span class="comment">// 会提前调用这里注册的释放直接内存的Deallocator线程对象的run方法</span></span><br><span class="line">    cleaner = Cleaner.<span class="built_in">create</span>(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="built_in">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一块本地内存。内存空间是未初始化的，其内容是无法预期的。</span></span><br><span class="line"><span class="comment">// 使用freeMemory释放内存，使用reallocateMemory修改内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> native <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// openjdk8/hotspot/src/share/vm/prims/unsafe.cpp</span></span><br><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jlong, <span class="built_in">Unsafe_AllocateMemory</span>(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_AllocateMemory&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> sz = (<span class="keyword">size_t</span>)size;</span><br><span class="line">  <span class="keyword">if</span> (sz != (julong)size || size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_0</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = <span class="built_in">round_to</span>(sz, HeapWordSize);</span><br><span class="line">  <span class="comment">// 调用os::malloc申请内存，内部使用malloc这个C标准库的函数申请内存</span></span><br><span class="line">  <span class="keyword">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtInternal);</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_0</span>(vmSymbols::<span class="built_in">java_lang_OutOfMemoryError</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">addr_to_java</span>(x);</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h4 id="直接内存的优缺点"><a href="#直接内存的优缺点" class="headerlink" title="直接内存的优缺点"></a>直接内存的优缺点</h4><p>优点: </p>
<ul>
<li>不占用堆内空间，减少了发生GC的可能</li>
<li>在Java虚拟机实现上，本地IO一般会直接操作直接内存(直接内存→系统调用→硬盘/网卡)，而非直接内存则需要二次拷贝(堆内存→直接内存→系统调用→硬盘/网卡)。</li>
</ul>
<p>缺点：</p>
<ul>
<li>初始分配比较慢</li>
<li>没有JVM直接帮助管理内存，容易发生内存溢出。为了避免一直没有FULL GC，最终导致直接内存把物理内存耗尽。我们可以指定直接内存的最大值，通过<code>-XX:MaxDirectMemorySize</code>来指定，当达到阈值的时候，调用System.gc来进行一次FULL GC，间接把哪些没有被使用的直接内存回收掉。</li>
</ul>
<h3 id="Nety零拷贝"><a href="#Nety零拷贝" class="headerlink" title="Nety零拷贝"></a>Nety零拷贝</h3><p><img src="/archives/b4dafe2/Netty%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="Netty零拷贝"></p>
<p>Netty的接收和发送ByteBuf采用DIRECT BUFFERS，使用对外<strong>直接内存</strong>进行Socket读写，不需要进行字节缓冲区的二次拷贝。</p>
<p>如果使用传统的JVM堆内存(HEAP BUFFERS)进行Socket读写，JVM会将堆内Buffer拷贝一份到直接内存中，然后才能写入Socket中。JVM堆内存的数据时不能直接写入Socket中的。相比于对外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p>
<p>比如以下netty源码中的read源码<code>NioByteUnsafe.read()</code></p>
<p><img src="/archives/b4dafe2/read().png" alt="read()源码"></p>
<p>![ioBuffer(int initialCapacity)源码](Netty核心源码解析/ioBuffer(int initialCapacity).png)</p>
<p><img src="/archives/b4dafe2/initMemoryAddress().png" alt="initMemoryAddress()"></p>
<h3 id="ByteBuf内存池设计"><a href="#ByteBuf内存池设计" class="headerlink" title="ByteBuf内存池设计"></a>ByteBuf内存池设计</h3><p>随着JVM虚拟机和JIT即时编辑技术的发展，对象的分配和回收变得非常轻量级饿的工作了。但是对于缓冲区Buffer(相当于一块内存块)，情况却稍微不同，特别是对于对外直接内存的分配和回收，是一件耗时的操作。为了复用缓冲区，Netty提供了基于ByteBuf内存池的缓冲重用机制。需要的时候直接从缓冲池中获取ByteBuf使用即可，使用完毕就重新放回到缓冲池中。下面是Netty ByteBuf的实现:</p>
<p><img src="/archives/b4dafe2/ByteBuf%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="ByteBuf的实现"></p>
<p>可以看下netty的读写源码里面用到的ByteBuf内存池，比如read源码NioByteUnsafe.read()</p>
<p><img src="/archives/b4dafe2/NioByteUnsafe.read().png" alt="NioByteUnsafe.read()源码"></p>
<p><img src="/archives/b4dafe2/image-20211029143930357.png" alt="DefaultMaxByteRecvByteBufAllocator.allocate()"></p>
<p>进入ioBuffer()方法</p>
<p><img src="/archives/b4dafe2/image-20211029144121450.png" alt="AbstractByteBufAllocator.ioBuffer(int initialCapacity)源码"></p>
<p><img src="/archives/b4dafe2/image-20211029144314425.png" alt="image-20211029144314425"></p>
<p>继续看newDirectBuffer方法，我们发现他是一个抽象方法，由AbstractByteBufAllocator的子类负责具体实现，</p>
<p><img src="/archives/b4dafe2/image-20211029144727744.png" alt="实现类"></p>
<p>代码跳转到PooledByteBufAllocator的newDirectBuffer方法，从Cache中获取内存区域PoolArena，调用它的allocate方法进行内存分配：</p>
<p><img src="/archives/b4dafe2/image-20211029145104420.png" alt="PooledByteBufAllocator.newHeapBuffer方法源码"></p>
<p>PoolArena的allocate方法如下：</p>
<p><img src="/archives/b4dafe2/image-20211029145227866.png" alt="allocate方法源码"></p>
<p>我们重点分析newByteBuf的实现，它同样是个抽象方法，由子类DirectArena和HeapArena来实现不同类型的缓冲区分配</p>
<p><img src="/archives/b4dafe2/image-20211029145408499.png" alt="newByteBuf方法的实现类"></p>
<p>我们这里使用的是直接内存，因此重点分析一下DirectArena的实现</p>
<p><img src="/archives/b4dafe2/image-20211029145525546.png" alt="DirectArena.newByteBuf方法实现"></p>
<p>最终执行了PooledUnsafeDirectByteBuf的newInstance方法，代码如下：</p>
<p><img src="/archives/b4dafe2/image-20211029145707347.png" alt="PooledUnsafeDirectByteBuf.newInstance方法实现"></p>
<p>通过RECYCLER的get方法循环使用ByteBuf对象，如果是非内存池实现，则直接创建一个新的ByteBuf对象。</p>
<h3 id="灵活的TCP参数配置能力"><a href="#灵活的TCP参数配置能力" class="headerlink" title="灵活的TCP参数配置能力"></a>灵活的TCP参数配置能力</h3><p>合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如接收缓冲区SO_RCVBUF和发送缓冲区SO_SNDBUF。如果设置不当，对性能影响非常大的。通常建议设置128K或者256K。</p>
<p>Netty在启动辅助类ChannelOption中可以灵活的配置TCP参数，满足不同的用户场景</p>
<p><img src="/archives/b4dafe2/image-20211029150243286.png" alt="ChannelOption中TCP配置参数"></p>
<h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><ul>
<li>volatile的大量、正确使用</li>
<li>CAS和原子类的广泛使用</li>
<li>线程安全容器的使用</li>
<li>通过读写锁提升并发性能</li>
</ul>
<h3 id="ByteBuf扩容机制"><a href="#ByteBuf扩容机制" class="headerlink" title="ByteBuf扩容机制"></a>ByteBuf扩容机制</h3><p>首先了解一下ByteBuf中定义的几个成员变量，再从源码的角度来分析扩容。</p>
<p><img src="/archives/b4dafe2/ByteBuf%E6%A8%A1%E5%9E%8B.jpeg" alt="ByteBuf模型"></p>
<ul>
<li><code>minNewCapacity</code>: 表示用户需要写入的值大小</li>
<li><code>threshold</code>: 阈值，为ByteBuf内部设定容量的最大值</li>
<li><code>maxCapacity</code>：Netty最大能接受的容量大小，一般为int的最大值</li>
</ul>
<h4 id="ByteBuf核心扩容方法"><a href="#ByteBuf核心扩容方法" class="headerlink" title="ByteBuf核心扩容方法"></a>ByteBuf核心扩容方法</h4><p>进入源码中分析一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuf.writeByte() ---&gt; AbstractByteBuf.writeByte() ---&gt; ensureWritable0 ---&gt; calculateNewCapacity</span><br></pre></td></tr></table></figure>

<ol>
<li>判断目标值与阈值<code>threshold(4MB)</code>的大小关系，等于直接返回阈值</li>
</ol>
<p><img src="/archives/b4dafe2/image-20211029151742982.png" alt="AbstractByteBufAllocator.calculateNewCapacity方法"></p>
<ol start="2">
<li>采用步进4MB的方式完成扩容</li>
</ol>
<p><img src="/archives/b4dafe2/image-20211029151929485.png" alt="calculateNewCapacity方法扩容策略"></p>
<ol start="3">
<li>采用64位基数，做倍增的方式完成扩容</li>
</ol>
<p><img src="/archives/b4dafe2/image-20211029152103954.png" alt="calculateNewCapacity采用倍增方式扩容"></p>
<blockquote>
<p><strong>总结：</strong></p>
<p>Netty的ByteBuf需要动态扩容来满足需求，扩容过程：默认阈值为4MB，当需要的容量等于阈值，使用阈值作为新的缓冲区容量目标容量，如果大于阈值，采用每次步进4MB的方式进行内存扩张((需要扩容值/4MB)*4MB)，扩张后需要和最大内存(maxCapacity)进行比较，大于maxCapacity的话就用maxCapacity，否则使用扩容值目标容量，如果小于阈值，采用倍增的方式，以64(字节)作为基本数值，每次翻倍增长64–&gt;128–&gt;256，直到倍增后的结果大于或等于需要的容量值。</p>
</blockquote>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从工作原理</title>
    <url>/archives/1b578af4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接前面讲到的<a href="/archives/ba77e58/">《redis主从架构搭建》</a>，来讲一下Redis主从架构的工作原理到底是怎么运作的</p>
<h2 id="Redis工作原理"><a href="#Redis工作原理" class="headerlink" title="Redis工作原理"></a>Redis工作原理</h2><p>在上个博客中我们搭建了Redis主从架构；在过程中我们为master主节点配置了三个slave从节点。在这三个slave从节点启动的时候，不管是否第一次连接上master主节点，他们都会发送改一个<code>PSYNC</code>命令给master请求同步数据。</p>
<p>master主节点接收到<code>PSYNC</code>命令后，会在后台进行数据持久化，通过<code>bgsave</code>生成最新的快照文件；在持久化期间，master主节点还会继续接受客户端的请求，并且他会把这些可能修改数据的请求命令缓存在一块内存中。当持久化进行完毕之后，master会把这份rdb文件数据集发送给slave从节点，slave从节点会把接收到的数据进行持久化生成rdb，然后再加载到内存中。然后master主节点再将之前缓存在内存中的命令发送给slave从节点，从节点根据这些请求指令重放数据到redis中。</p>
<p>当master主节点和slave从节点之间的连接由于一些原因断开时，slave从节点能够自动重连master主节点，如果master收到了多个slave从节点并发连接的请求时，他会进行一次持久化，而不是一个一个连接一次，然后把这份持久化的数据发送给多个并发连接的slave从节点。以上整个流程可以用下图来表示</p>
<p><img src="/archives/1b578af4/image-20210914160847756.png" alt="主从复制(全量复制)流程图"></p>
<h3 id="主从部分数据复制"><a href="#主从部分数据复制" class="headerlink" title="主从部分数据复制"></a>主从部分数据复制</h3><p>当master和slave断开重连后，一般都会对整份数据进行复制。但是从<code>redis2.8</code>版本开始，redis改用可以支持部分数据复制的命令<code>PSYNC</code>去master同步数据，slave与master能够在网络连接断开重连后只进行部分数据复制(<strong>端点续传</strong>)。</p>
<p>master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据，master和他所有的slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始，如果master进程id变化了，或者从节点数据下标offset太旧，已经不再master的缓存队里中，那么将会进行一次全量数据的复制</p>
<p><img src="/archives/1b578af4/image-20210914161725948.png" alt="主从复制(部分复制，端点续传)流程图"></p>
<p>如果有很多从节点，为了缓解<strong>主从复制风暴</strong>(多个从节点同时复制主节点数据导致主节点压力过大)，可以做如下结构调整，让部分从节点与从节点(与主节点同步)同步数据</p>
<p><img src="/archives/1b578af4/image-20210914162422875.png" alt="主从复制风暴架构解决方案"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC和Http的区别</title>
    <url>/archives/c71dc211/</url>
    <content><![CDATA[<h1 id="Rpc调用和Http调用区别"><a href="#Rpc调用和Http调用区别" class="headerlink" title="Rpc调用和Http调用区别"></a>Rpc调用和Http调用区别</h1><ol>
<li><p>协议区别</p>
<p>Rpc是通常基于TCP/IP协议实现的；而Http是基于Http协议实现的</p>
</li>
<li><p>效率</p>
<p>Rpc效率要比Http效率高</p>
</li>
<li><p>复杂度</p>
<p>Rpc要比Http复杂。设计RPC框架，服务注册于发现，服务治理等。</p>
<p>Rpc是长连接，不必每次通信都要像http一样去进行3次握手，减少了网络开销；其次就是Rpc框架一般都是有注册中心，有丰富的服务监控管理；服务发布、服务下线、动态扩展等接口，对调用方来说是无感知、统一化的操作。</p>
</li>
<li><p>使用场景</p>
<p>Rpc通常在大型网站、微服务、分布式服务中使用，单体服务、小网站直接用http就可以</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
      <tags>
        <tag>面试宝典</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵架构搭建</title>
    <url>/archives/8bd0f0fd/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安装Redis教程这里就不说了，我们在之前搭建的<a href="/archives/ba77e58/">《Redis主从架构搭建》</a>基础上来进行Redis哨兵架构的搭建。</p>
<p><img src="/archives/8bd0f0fd/image-20210924094852940.png" alt="哨兵架构"></p>
<blockquote>
<p>主节点：192.168.49.128:6379</p>
<p>从节点：192.168.49.129:6381 ，192.168.49.130:6380</p>
</blockquote>
<h2 id="配置主节点"><a href="#配置主节点" class="headerlink" title="配置主节点"></a>配置主节点</h2><p>登录主节点服务器(192.168.49.128)，进入到redis解压文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/redis/redis-src/redis-6.2.5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的解压文件是在<code>/home/redis/redis-src/redis-6.2.5</code>，请根据不同文件位置修改对应的目录</p>
</blockquote>
<p><img src="/archives/8bd0f0fd/image-20210914171205948.png" alt="redis-6.2.5"></p>
<p>复制该目录下的<code>sentinel.conf</code>文件到安装目录中；我的安装目录是在(<code>/home/redis/build/bin</code>)，各位根据各自的安装位置要做对应的修改</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp ./sentinel.conf /home/redis/build/bin/</span><br></pre></td></tr></table></figure>

<p><img src="/archives/8bd0f0fd/image-20210914171427364.png" alt="复制sentinel.conf"></p>
<blockquote>
<p>我这里因为之前拷贝过一次，所以这里会提示”是否需要覆盖”</p>
</blockquote>
<p>进入到安装目录中修改<code>sentinel.conf</code>，将配置修改为以下值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-sentinel-26379.pid&quot;</span><br><span class="line">logfile &quot;/home/redis/build/log/26379.log&quot;</span><br><span class="line">dir &quot;/home/redis/build/log/data&quot;</span><br><span class="line"># sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span><br><span class="line">sentinel monitor mymaster 192.168.49.128 6379 2   # mymaster这个名字随便取，客户端访问时会用到</span><br></pre></td></tr></table></figure>

<h2 id="配置从节点"><a href="#配置从节点" class="headerlink" title="配置从节点"></a>配置从节点</h2><p>从节点配置步骤和主节点一样，所以这里也不再重复<code>sentinel.conf</code>的复制步骤了，参考主节点配置步骤即可，这里只列出配置文件中的配置详细。</p>
<p>192.168.49.129从节点<code>sentinel.conf</code>配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26381</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-sentinel-263819.pid&quot;</span><br><span class="line">logfile &quot;/home/redis/build/log/26381.log&quot;</span><br><span class="line">dir &quot;/home/redis/build/log/data&quot;</span><br><span class="line"># sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span><br><span class="line">sentinel monitor mymaster 192.168.49.129 6381 2   # mymaster这个名字随便取，客户端访问时会用到</span><br></pre></td></tr></table></figure>

<p>192.168.49.130从节点<code>sentinel.conf</code>配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26380</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-sentinel-263880.pid&quot;</span><br><span class="line">logfile &quot;/home/redis/build/log/26380.log&quot;</span><br><span class="line">dir &quot;/home/redis/build/log/data&quot;</span><br><span class="line"># sentinel monitor &lt;master-redis-name&gt; &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span><br><span class="line"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效</span><br><span class="line">sentinel monitor mymaster 192.168.49.130 6380 2   # mymaster这个名字随便取，客户端访问时会用到</span><br></pre></td></tr></table></figure>

<h2 id="启动哨兵集群"><a href="#启动哨兵集群" class="headerlink" title="启动哨兵集群"></a>启动哨兵集群</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-sentinel /home/redis/build/bin/sentinel.conf</span><br></pre></td></tr></table></figure>

<p><img src="/archives/8bd0f0fd/image-20210914174326163.png" alt="主节点哨兵启动"></p>
<p><img src="/archives/8bd0f0fd/image-20210914174653067.png" alt="slaver-2哨兵启动(192.168.49.130)"></p>
<p><img src="/archives/8bd0f0fd/image-20210914174756564.png" alt="slaver-1哨兵启动(192.168.49.129)"></p>
<p>sentinel集群都启动完毕后，会将哨兵集群的元数据信息写入所有sentinel的配置文件里去(追加在文件的最下面)，我们查看下如下配置文件sentinel-26379.conf，如下所示：</p>
<p><img src="/archives/8bd0f0fd/image-20210914181849488.png" alt="image-20210914181849488"></p>
<p>表示已经识别出了redis的主从 了         </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/archives/119ed1dc/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis目前提供了三种持久化的方式：</p>
<blockquote>
<ul>
<li>RDB快照(snapshot)持久化</li>
<li>AOF(append-only-file)持久化</li>
<li>混合持久化方式(Redis 4.0后加入的新特性)</li>
</ul>
</blockquote>
<h2 id="RDB快照-snapshot"><a href="#RDB快照-snapshot" class="headerlink" title="RDB快照(snapshot)"></a>RDB快照(snapshot)</h2><p>在默认情况下，Redis将内存数据库快照保存在名字为dump.rdb的二进制文件中。当然可以对Redis进行设置，可以让它在“N秒内数据集至少有M个改动”，这一条件被满足时，自动保存一次数据。比如说，以下设置会让Redis在满足“60秒内有至少1000个键被改动”这一条件时，自动保存一次数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 60 1000 # 关闭RDB只需要将所有的save保存策略注释掉即可</span><br></pre></td></tr></table></figure>
<p>当然还可以手动执行命令生成RDB快照，进入Redis客户端执行命令<code>save</code>或<code>bgsave</code>可以生成dump.rdb文件，每次命令执行都会将所有Redis内存快照到一个新的rdb文件里，并覆盖原有的rdb快照文件。</p>
<h3 id="bgsave的写时复制-COW-机制"><a href="#bgsave的写时复制-COW-机制" class="headerlink" title="bgsave的写时复制(COW)机制"></a>bgsave的写时复制(COW)机制</h3><p>Redis借助操作系统提供的写时复制技术(Copy-On-Write，COW)，在生成快照的同时，依然可以正常处理写命令。简单来说，就是<code>bgsave</code>子进程是由主线程<code>fork</code>生成的，可以共享主线程的所有内存数据。<code>bgsave</code>子进程运行后，开始读取主线程的内存数据，并把他们写入RDB文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和<code>bgsave</code>子线程相互不影响。但是，如果主线程要修改一块数据，那么这块数据就会被复制一份，生成改数据的一个副本。然后，<code>bgsave</code>子线程会把这个副本数据写入到RDB文件，而在这个过程中，主线程仍然可以修改原来的数据。</p>
<blockquote>
<p><strong>save与bgsave区别</strong></p>
<table style="width:100%;" cellpadding="2" cellspacing="0" align="center" border="1" bordercolor="#000000">
  <tbody>
            <tr>
                <td style="text-align:center;">
                    命令
                </td>
                <td style="text-align:center;">
                    save
                </td>
                <td style="text-align:center;">
                    bgsave
                </td>
            </tr>
            <tr>
                <td style="text-align:center;">
                    I/O类型
                </td>
                <td style="text-align:center;">
                    同步
                </td>
                <td style="text-align:center;">
                    异步
                </td>
            </tr>
            <tr>
                <td style="text-align:center;">
                    是否阻塞Redis其他命令
                </td>
                <td style="text-align:center;">
                    是
                </td>
                <td style="text-align:center;">
                    否(在生成子进程调用fork函数时会短暂阻塞)
                </td>
            </tr>
            <tr>
                <td style="text-align:center;">
                    复杂度
                </td>
                <td style="text-align:center;">
                    O(n)
                </td>
                <td style="text-align:center;">
                    O(n)
                </td>
            </tr>
            <tr>
                <td style="text-align:center;">
                    优点
                </td>
                <td style="text-align:center;">
                    不会消耗额外内存
                </td>
                <td style="text-align:center;">
                    不阻塞客户端命令
                </td>
            </tr>
            <tr>
                <td style="text-align:center;">
                    缺点
                </td>
                <td style="text-align:center;">
                    阻塞客户端命令
                </td>
                <td style="text-align:center;">
                    需要fork子进程，消耗内存
                </td>
            </tr>
        </tbody>
</table>

<p><strong>配置自动生成rdb文件后台使用的是bgsave方式</strong></p>
</blockquote>
<h2 id="AOF-append-only-file-快照"><a href="#AOF-append-only-file-快照" class="headerlink" title="AOF(append-only-file)快照"></a>AOF(append-only-file)快照</h2><p>快照功能并不是非常耐久(durable)：如果Redis因为某些原因造成故障停机，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从1.1版本开始，Redis增加了一种完全耐久的持久化方式：AOF持久化，将修改的每一条指令记录到文件<code>appendonly.aof</code>中(先写入OS Cache，每隔一段时间sync到磁盘)</p>
<p>比如执行<code>set append-only-file true</code>，aof文件里会记录如下数据</p>
<p><img src="/archives/119ed1dc/image-20210916110754085.png" alt="执行结果"></p>
<p>AOF功能可以通过以下方式来开启和关闭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes/no  # yes开启  no关闭</span><br></pre></td></tr></table></figure>

<p>这里也可以配置AOF的持久化策略，默认的话是每秒持久化一次，这样既保证了速度也保证了数据安全。</p>
<blockquote>
<ul>
<li><code>appendfsync always</code>：每次有新命令追加到AOF文件时，都会执行一次fsync，非常慢，也非常安全</li>
<li><code>appendfsync everysec</code>：每秒fsync一次，足够快，并且在故障时只会就是1秒钟的数据</li>
<li><code>appendfsync no</code>：从不fsync，将数据交给操作系统来处理。更快，也更安全的选择</li>
</ul>
</blockquote>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF文件中如果有太多没有用的指令时，AOF会定期根据<strong>内存的最新数据</strong>生成aof文件</p>
<p>例如：在客户端执行了5次自增命令</p>
<p><img src="/archives/119ed1dc/image-20210916111719187.png" alt="自增命令"></p>
<p>在aof文件重写之前中显示如下</p>
<p><img src="/archives/119ed1dc/image-20210916112017276.png" alt="AOF文件重写前数据"></p>
<p>重写之后aof文件变为了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$2</span><br><span class="line">count</span><br><span class="line">$1</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>这里有两个配置可以设置AOF自动重写频率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb #aof文件至少达到64M才会自动重写，文件太小重写的速度很快，重写意义不大</span><br><span class="line">auto-aof-rewrite-percentage 100 #aof文件自上次重写之后至少增长100%(增长一倍),才会再次触发重写</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然AOF可以手动重写，进入redis客户端执行命令<code>bgrewriteaof</code>重写AOF。</p>
<p><strong>注意：AOF重写redis会fork出一个子进程去做(和bgsave命令类似)，不会对redis正常命令处理有太多影响</strong></p>
</blockquote>
<h3 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a>RDB和AOF对比</h3><table style="width:100%;" cellpadding="2" cellspacing="0" align="center" border="1" bordercolor="#000000">
  <tbody>
        <tr>
            <td style="text-align:center;">
                命令
            </td>
            <td style="text-align:center;">
                RDB
            </td>
            <td style="text-align:center;">
                AOF
            </td>
        </tr>
        <tr>
            <td style="text-align:center;">
                启动优先级
            </td>
            <td style="text-align:center;">
                低
            </td>
            <td style="text-align:center;">
                高
            </td>
        </tr>
        <tr>
            <td style="text-align:center;">
                体积
            </td>
            <td style="text-align:center;">
                小
            </td>
            <td style="text-align:center;">
                大
            </td>
        </tr>
        <tr>
            <td style="text-align:center;">
                恢复速度
            </td>
            <td style="text-align:center;">
                块
            </td>
            <td style="text-align:center;">
                慢
            </td>
        </tr>
        <tr>
            <td style="text-align:center;">
                数据安全性
            </td>
            <td style="text-align:center;">
                容易丢数据
            </td>
            <td style="text-align:center;">
                根据策略决定
            </td>
        </tr>
    </tbody>
</table>



<p>生产环境可以都启用，redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点。</p>
<h2 id="Redis4-0-混合持久化"><a href="#Redis4-0-混合持久化" class="headerlink" title="Redis4.0 混合持久化"></a>Redis4.0 混合持久化</h2><p>重启Redis时，我们很少使用RDB来恢复内存中数据，因为会丢失大量数据。我们通常使用AOF日志重放，但是重放AOF日志性能相对RDB来说要慢。这样在Redis实例很大的情况下，启动需要花费很长的时间。Redis 4.0 为了解决这个问题，加入了一个新的持久化方案——<strong>混合持久化</strong></p>
<p>通过如下配置可以开启混合持久化(<strong>必须先开启aof</strong>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>如果开启了混合持久化，<strong>AOF在重写时</strong>，不再是单纯的将内存数据转化为RESP命令写入AOF文件，而是<strong>将这一刻之前</strong>的内存数据做RDB快照处理，并且将RDB快照内容和<strong>增量AOF</strong>修改内存数据的命令保存在一起，都写入新的aof文件，新的文件开始不叫<code>appendonly.aof</code>，等重写完新的AOF文件才会进行改名，覆盖原来的AOF文件，完成新就两个AOF文件的替换。在Redis重启的时候，可以先加载RDB的内容，然后在重放AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率大幅得到提升。</p>
<p><img src="/archives/119ed1dc/image-20210916122222002.png" alt="混合持久化appendonly.aof文件数据结构"></p>
<h3 id="Redis数据备份策略"><a href="#Redis数据备份策略" class="headerlink" title="Redis数据备份策略"></a>Redis数据备份策略</h3><ol>
<li>写<code>crontab</code>定时调度脚本，每小时都<code>copy</code>一份rdb或者aof的备份到一个目录中去，仅仅保留最近48小时的备份</li>
<li>每天都保留一份当天的数据备份到一个目录中去，可以保留近一个月的数据备份</li>
<li>每次<code>copy</code>备份的时候，把太旧的备份给删掉</li>
<li>每天晚上将当前机器上的备份复制一份到其他机器上，以防止机器损坏</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存失效和缓存雪崩以及热点缓存key重建优化</title>
    <url>/archives/134045b4/</url>
    <content><![CDATA[<h2 id="缓存失效-击穿"><a href="#缓存失效-击穿" class="headerlink" title="缓存失效(击穿)"></a>缓存失效(击穿)</h2><p>缓存失效也称缓存击穿，是由于大批量缓存在同一时间失效可能导致大量请求同时穿透缓存直达数据库，可能造成数据库瞬间压力过大甚至挂掉，对于这种情况我们在批量增加缓存时最好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。</p>
<p>示例伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">//设置一个过期时间(300到600之间的一个随机数)</span></span><br><span class="line">        <span class="keyword">int</span> expireTime = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>)  + <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, expireTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩指的是缓存层支撑不住或者宕机后，流量会全部打向存储层。<br>由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因不能提供服务（比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问<code>bigkey</code>，导致缓存能支撑的并发急剧下降），于是大量请求都会打到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。</p>
<p>预防和解决缓存雪崩问题，可以从以下三个方面着手解决：</p>
<ol>
<li><p>保证缓存层服务高可用性，比如使用Redis Sentinel或Redis Cluster。</p>
</li>
<li><p>依赖隔离组件为后端限流熔断并降级。比如使用阿里开源流控组件Sentinel或Hystrix限流降级组件</p>
<blockquote>
<p>比如服务降级，我们可以针对不同的数据采用不同的处理方式，当业务应用访问的是非核心数据（例如电商商品属性，用户信息等）时，暂时停止从缓存中查询这些数据，而是返回预定义的默认降级信息、空值或是错误提示信息；当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</p>
</blockquote>
</li>
<li><p>提前演练。在项目上线前，演练缓存层宕机后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。</p>
</li>
</ol>
<h2 id="热点缓存key重建优化"><a href="#热点缓存key重建优化" class="headerlink" title="热点缓存key重建优化"></a>热点缓存key重建优化</h2><p>在使用“缓存+过期时间”的策略时，既可以加速数据读写，又可以保证数据定期更新，这种模式基本上可以满足绝大部分需求，但是相应的也会出现两个问题，可能对应用造成致命bug：</p>
<ul>
<li>当前key是一个热点key（例如一个热门的新闻），并发量非常大。</li>
<li>重建缓存不能在短时间内完成，可能是一个复杂的计算，例如复杂的SQL、多次I/O，多个依赖等。</li>
</ul>
<p>在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。要解决这个问题主要就是避免大量线程同时重建缓存。</p>
<p>我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p>
<p>示例伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从Redis中获取数据</span></span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="comment">// 如果value为空， 则开始重构缓存</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 只允许一个线程重建缓存， 使用nx， 并设置过期时间ex</span></span><br><span class="line">        String mutexKey = <span class="string">&quot;mutext:key:&quot;</span> + key;</span><br><span class="line">        <span class="keyword">if</span> (redis.set(mutexKey, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;ex 180&quot;</span>, <span class="string">&quot;nx&quot;</span>)) &#123;</span><br><span class="line">             <span class="comment">// 从数据源获取数据</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            <span class="comment">// 回写Redis， 并设置过期时间</span></span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            <span class="comment">// 删除key_mutex</span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;<span class="comment">// 其他线程休息50毫秒后重试</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存与数据库库双写不一致"><a href="#缓存与数据库库双写不一致" class="headerlink" title="缓存与数据库库双写不一致"></a>缓存与数据库库双写不一致</h2><p>在大并发下，同时操作数据库与缓存会存在数据不一致性问题</p>
<ol>
<li><p>双写不一致情况</p>
<p><img src="/archives/134045b4/image-20210930134748777.png" alt="缓存&amp;数据库双写不一致"></p>
</li>
<li><p>读写并发不一致</p>
<p><img src="/archives/134045b4/image-20210930134845540.png" alt="读写并发不一致"></p>
</li>
</ol>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>对于并发几率很小的数据（如个人维度的订单数据、用户数据等），这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</p>
</li>
<li><p>就算并发很高，如果业务上能容忍短时间的缓存数据不一致（如商品名称，商品分类菜单等），缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</p>
</li>
<li><p>如果不能容忍缓存不一致，可以通过加<strong>读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong>。</p>
</li>
<li><p>也可以用阿里开源的canal通过监控数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度。</p>
<p><img src="/archives/134045b4/image-20210930141046670.png" alt="双写不一致解决方案"></p>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>以上针对的都是<strong>读多写少</strong>的情况加入缓存提高性能，如果是<strong>写多读多</strong>的情况又不能容忍缓存数据不一致，那就没有必要加缓存了，可以直接操作数据库。放入缓存的数据应该是对实时性、一致性要求不是很高的数据。切记不要为了用缓存，同时又要保证绝对的一致性做大量的过度设计和控制，增加系统的复杂性！</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存穿透</title>
    <url>/archives/f435d36e/</url>
    <content><![CDATA[<p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常处于容错的考虑，如果从存储层查不到数据则不写入缓存层。<br>缓存层将导致不存在的数据每次请求都要存储层去查询，失去了缓存保护后端存储的意义。<br>造成缓存穿透的基本原因有两个：</p>
<ol>
<li>自身业务代码或者数据出现问题。</li>
<li>一些恶意攻击、爬虫等造成大量空命中。</li>
</ol>
<h2 id="缓存穿透问题解决方案"><a href="#缓存穿透问题解决方案" class="headerlink" title="缓存穿透问题解决方案"></a>缓存穿透问题解决方案</h2><ol>
<li><p><strong>缓冲空对象</strong> </p>
<p>下面是伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>布隆过滤器</p>
<p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说<strong>某个值存在时，这个值可能不存在；当他说不存在时，那就肯定不存在。</strong><br><img src="/archives/f435d36e/image-20210930100804245.png" alt="布隆过滤器原理图"></p>
<blockquote>
<p>布隆过滤器就是一个<strong>大型的位数组和几个不一样的无偏hash函数</strong>。所谓无偏就是能够把元素的hash值算的比较均匀。  </p>
</blockquote>
<p>向布隆过滤器中添加key时，会使用多个hash函数对key进行hash算的一个整数索引值，然后对位数组长度进行取模算的一个位置，每个hash函数都会算得一个不同的位置。再把位数组的这几个位置都置为1就完成了add操作。    向布隆过滤器询问key是否存在时，跟add一样，也会把hash的几个位置都算出来，看看位数组中几个位置是否都为1，只要有一个为0，那么说明布隆过滤器中这个key不存在。如果都是1，这并不能说明这个key就一定存在，只是极有可能存在，因为这些位置为1可能是因为其他的key存在导致的。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。</p>
<p>这种方法适用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是<strong>缓存空间占用很少</strong>。</p>
<h3 id="布隆过滤器的实现"><a href="#布隆过滤器的实现" class="headerlink" title="布隆过滤器的实现"></a>布隆过滤器的实现</h3><p>可以用<code>redission</code>实现布隆过滤器，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redisson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line">        <span class="comment">//构造Redisson</span></span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;nameList&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%,根据这两个参数会计算出底层的bit数组大小</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">        <span class="comment">//将zhuge插入到布隆过滤器中</span></span><br><span class="line">        bloomFilter.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断下面号码是否在布隆过滤器中</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;lisi&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;wangwu&quot;</span>));<span class="comment">//false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用布隆过滤器需要把所有数据提前放入布隆过滤器，并且在增加数据时也要往布隆过滤器里放，布隆过滤器缓存过滤伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化布隆过滤器</span></span><br><span class="line">RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;nameList&quot;</span>);</span><br><span class="line"><span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span><br><span class="line">bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//把所有数据存入布隆过滤器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String key: keys) &#123;</span><br><span class="line">        bloomFilter.put(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从布隆过滤器这一级缓存判断下key是否存在</span></span><br><span class="line">    Boolean exist = bloomFilter.contains(key);</span><br><span class="line">    <span class="keyword">if</span>(!exist)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;</span><br><span class="line">        <span class="comment">// 从存储中获取</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存非空</span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：布隆过滤器不能删除数据，如果要删除得重新初始化数据。</strong></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓存那些事</title>
    <url>/archives/cfd129cc/</url>
    <content><![CDATA[<h2 id="Redis有哪些特性？"><a href="#Redis有哪些特性？" class="headerlink" title="Redis有哪些特性？"></a>Redis有哪些特性？</h2><ul>
<li>性能高，读的速度是100000次/s，写的速度是80000次/s</li>
<li>数据持久化，支持RDB、AOF</li>
<li>支持事务。通过<code>MULTI</code>和<code>EXEC</code>指令包起来</li>
<li>多数据结构类型</li>
<li>主从复制</li>
<li>其他特性：发布/订阅、通知、key过期等</li>
</ul>
<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul>
<li>完全基于内存，没有磁盘IO的开销，异步持久化除外</li>
<li>单线程，避免多线程切换造成的性能损耗</li>
<li>非阻塞的IO多路复用机制</li>
<li>底层的数据存储结构优化、使用原生的数据结构提升性能</li>
</ul>
<h2 id="Redis底层的基础数据结构有哪些？"><a href="#Redis底层的基础数据结构有哪些？" class="headerlink" title="Redis底层的基础数据结构有哪些？"></a>Redis底层的基础数据结构有哪些？</h2><ul>
<li><code>字符串：</code>没有采用C语言的传统字符串，而是自己实现的一个简单动态字符串SDS的抽象类，并保存了长度信息。</li>
<li><code>链表（linkedlist）：</code>双向无环链表结构，每个链表的结点由一个listNode结构来表示，每个节点都有前置和后置节点的指针。</li>
<li><code>字典（hashtable）：</code>保存键值对的抽象数据结构，底层使用hash表，每个字典带有两个hash表，供平时使用和rehash时使用。</li>
<li><code>跳跃表（skiplist）：</code>跳跃表是有序集合的底层实现之一。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示条约节点，每个跳跃表的层高都是1~32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象都必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li>
<li><code>整数集合（intset）：</code>用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li>
<li><code>压缩列表（ziplist）：</code>为了节约内存而开发的顺序性数据结构，可以包含多个节点，每一个节点可以保存一个字节数组或整数值。</li>
</ul>
<h2 id="Redis支持哪些数据类型？"><a href="#Redis支持哪些数据类型？" class="headerlink" title="Redis支持哪些数据类型？"></a>Redis支持哪些数据类型？</h2><p>五种常用数据类型：<code>String</code>、<code>Hash</code>、<code>Set</code>、<code>List</code>、<code>SortedSet</code>。三种特殊的数据类型：<code>Bitmap</code>、<code>HyperLogLog</code>、<code>GeoSpatial</code>，其中Bitmap、HyperLogLog的底层都是String数据类型，Geospatial底层是Sorted Set数据类型。</p>
<ul>
<li>字符串对象String：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li>
<li>列表对象list：ziplist、linkedlist</li>
<li>哈希对象hash：hashtable、ziplist</li>
<li>集合对象set：hashtable、intset</li>
<li>有序集合对象zset：ziplist、skiplist</li>
</ul>
<h2 id="Redis常用的5种数据结构和应用场景？"><a href="#Redis常用的5种数据结构和应用场景？" class="headerlink" title="Redis常用的5种数据结构和应用场景？"></a>Redis常用的5种数据结构和应用场景？</h2><ul>
<li>String：缓存、计数器、分布式锁等</li>
<li>List：链表、队列、微博关注人时间轴列表等</li>
<li>Hash：用户信息、Hash表等</li>
<li>Set：去重、赞、踩、共同好友等</li>
<li>Zset：访问量排行榜、点击量排行榜等</li>
</ul>
<h2 id="为什么采用的单线程？"><a href="#为什么采用的单线程？" class="headerlink" title="为什么采用的单线程？"></a>为什么采用的单线程？</h2><p>官方回复，CPU不会成为Redis的制约瓶颈，Redis主要受制于内存、网络限制。例如，在一个普通的Linux系统上，使用pipelining可以每秒传递100万个请求，所以如果您的应用程序主要使用O(N)或O(logN)命令，则几乎不会使用太多的CPU，属于IO密集型系统。</p>
<h2 id="Redis-6-0-之后又改用多线程呢？"><a href="#Redis-6-0-之后又改用多线程呢？" class="headerlink" title="Redis 6.0 之后又改用多线程呢？"></a>Redis 6.0 之后又改用多线程呢？</h2><p>Redis的多线程主要是用来处理数据的读写、协议解析。执行命令还是采用单线程顺序执行。</p>
<p>主要是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程进行一些周边预处理，提升IO的读写效率，从而提升了整体的吞吐量。antirez在RedisConf 2019分享时提到，Redis 6 引入的多线程IO对性能提升至少在一倍以上。</p>
<h2 id="过期Key的删除策略有哪些？"><a href="#过期Key的删除策略有哪些？" class="headerlink" title="过期Key的删除策略有哪些？"></a>过期Key的删除策略有哪些？</h2><p>有三种过期删除策略。惰性删除、定期删除、定时删除</p>
<ul>
<li>惰性删除：使用key时才进行检测，如果已经过期，则删除。缺点：过期key如果一直没有被访问到，一直无法删除，一直占用内存，造成空间浪费。</li>
<li>定期删除：每隔一段时间做一次检查，删除过期的key，每次只是随机去一些key去检查</li>
<li>定时删除：为每个key设置过期时间，同时创建一个定时器。一旦到期，立即执行删除。缺点：如果过期键比较多时，占用CPU比较多，对服务的性能影响很大。</li>
</ul>
<h2 id="如果Redis的内存空间不足，淘汰机制？"><a href="#如果Redis的内存空间不足，淘汰机制？" class="headerlink" title="如果Redis的内存空间不足，淘汰机制？"></a>如果Redis的内存空间不足，淘汰机制？</h2><ul>
<li>volatile-lru：从已设置的过期时间的key中，移除最近最少使用的key进行淘汰</li>
<li>allkeys-lru：当内存不足以容纳新写入的数据时，再键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li>volatile-ttl：从已设置过期时间的key中，移除即将要过期的key</li>
<li>volatile-random：从已设置过期时间的key中，随机选择key淘汰</li>
<li>allkeys-random：从key中随机选择key进行淘汰</li>
<li>no-eviction：禁止淘汰数据，当内存达到阈值的时候，新写入操作报错</li>
<li>volatile-lfu：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰（LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最可能被访问到）</li>
<li>allkeys-lfu：当内存不足以容纳新写入的数据时，在键空间中，移除最不经常使用的key</li>
</ul>
<h2 id="Redis突然挂了怎么解决？"><a href="#Redis突然挂了怎么解决？" class="headerlink" title="Redis突然挂了怎么解决？"></a>Redis突然挂了怎么解决？</h2><ol>
<li>从系统可用性角度思考，Redis Cluster引入主备机制，当主节点挂了后，自动切换到备用节点，继续提供服务。</li>
<li>Client端引入本地缓存，通过开关切换，避免Redis突然挂掉，高并发流量把数据库打垮。</li>
</ol>
<h2 id="Redis持久化有哪些方式？"><a href="#Redis持久化有哪些方式？" class="headerlink" title="Redis持久化有哪些方式？"></a>Redis持久化有哪些方式？</h2><ol>
<li>快照RDB。将某个时间点上的数据库状态保存到<code>RDB文件</code>中，RDB文件是一个压缩的二进制文件，保存在磁盘上。当Redis崩溃时，可用于恢复数据。通过<code>SAVE</code>或<code>BGSAVE</code>来来生成RDB文件。<ul>
<li>SAVE：会阻塞redis进程，直到RDB文件创建完成，在进程阻塞期间，redis不能处理任何命令请求。</li>
<li>BGSAVE：会fork出一个子进程，然后由子进程负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</li>
</ul>
</li>
<li>只追加文件AOF。以日志的形式记录每个写操作（非读操作）。当不同的节点同步数据时，读取日志文件中的内容将写指令从前到后执行一次，既可以完成数据的恢复。</li>
</ol>
<h2 id="Redis常用场景"><a href="#Redis常用场景" class="headerlink" title="Redis常用场景"></a>Redis常用场景</h2><ol>
<li>缓存</li>
<li>分布式锁，利用Redis的setnx</li>
<li>分布式session</li>
<li>计数器，通过incr命令</li>
<li>排行榜，Redis的有序集合</li>
<li>其他</li>
</ol>
<h2 id="Redis缓存要注意的七大经典问题？"><a href="#Redis缓存要注意的七大经典问题？" class="headerlink" title="Redis缓存要注意的七大经典问题？"></a>Redis缓存要注意的七大经典问题？</h2><p>列举了亿级系统，高访问量情况下Redis缓存可能遇到哪些问题？以及对应的解决方案。</p>
<ol>
<li>缓存集中失效</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
<li>缓存热点</li>
<li>缓存大key</li>
<li>缓存数据一直性</li>
<li>数据并发竞争预热</li>
</ol>
<p>每个问题的详细解决方案可以参考<a href="/archives/f435d36e/">Redis缓冲穿透</a>、<a href="/archives/134045b4/">Redis缓存失效和缓存雪崩以及热点缓存key重建优化</a>、<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&mid=2247484947&idx=1&sn=5a70f88fba83b435b8144bf1ddd3cc9f&scene=21#wechat_redirect">亿级系统的Redis缓存如何设计？？</a></p>
<h2 id="Redis集群方案有哪几种？"><a href="#Redis集群方案有哪几种？" class="headerlink" title="Redis集群方案有哪几种？"></a>Redis集群方案有哪几种？</h2><ul>
<li>主从复制模式</li>
<li>Sentinel（哨兵）模式</li>
<li>Redis Cluster模式</li>
</ul>
<h2 id="Redis主从数据同步（主从复制）的过程？"><a href="#Redis主从数据同步（主从复制）的过程？" class="headerlink" title="Redis主从数据同步（主从复制）的过程？"></a>Redis主从数据同步（主从复制）的过程？</h2><ol>
<li>slave启动后，会向master发送sync同步命令</li>
<li>master收到sync之后，执行bgsave保存快照，生成RDB全量文件</li>
<li>如果在生成RDB全量快照的过程中，有写命令请求，则将写命令请求记录到临时缓存中</li>
<li>bgsave执行完毕之后，将RDB全量文件发送到slave节点</li>
<li>slave清除缓存中的数据，并将RDB中的二进制数据加载到缓存中，</li>
<li>master发送临时缓存区中写命令给slave，slave接收到写命令并依次顺序执行写命令，将数据加载到缓存中，完成数据初始化</li>
<li>此后，master会和slave保持长连接，master每次执行一个写命令都会发送给slave，保持master与slave之间数据的一致性</li>
</ol>
<h2 id="主从复制的优缺点？"><a href="#主从复制的优缺点？" class="headerlink" title="主从复制的优缺点？"></a>主从复制的优缺点？</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li>
<li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不具备自动容错与恢复功能，master节点宕机后，需要手动指定新的master</li>
<li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li>
<li>难以支持在线扩容，Redis容量受限与单机配置</li>
</ul>
<h2 id="Sentinel（哨兵）模式的优缺点？"><a href="#Sentinel（哨兵）模式的优缺点？" class="headerlink" title="Sentinel（哨兵）模式的优缺点？"></a>Sentinel（哨兵）模式的优缺点？</h2><p>哨兵模式基于主从复制模式，增加了<strong>哨兵来监控</strong>与<strong>自动处理故障</strong></p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>哨兵模式基于主从复制模式，所以主从模式有的优点，哨兵模式也有</li>
<li>master节点挂掉之后可以自动进行切换，系统可用性更高</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>Redis的容量受限于单机配置</li>
<li>需要额外的资源来启动Sentinel进程</li>
</ul>
<h2 id="Redis-Cluster模式的优缺点？"><a href="#Redis-Cluster模式的优缺点？" class="headerlink" title="Redis Cluster模式的优缺点？"></a>Redis Cluster模式的优缺点？</h2><p>实现了Redis的分布式存储，即每台节点都存储不同的内容，来解决在线扩容的问题。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>无中心架构，数据按照slot分布在多个节点</li>
<li>集群中的每个节点都是平等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li>
<li>可在线扩容到1000多个节点，节点可以动态添加或删除</li>
<li>能够实现自动故障转移，节点之间通过<code>gossip协议</code>交换状态信息，用投票机制完成slave到master的角色转换</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>数据通过异步复制，不保证数据的强一致性</li>
<li>slave充当“冷备”，不对外提供读、写服务，只作为故障转移使用</li>
<li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li>
<li>key事务操作支持有限，只支持多key在同一个节点的事务操作，多个key分布在不同的节点是无法使用事务功能</li>
<li>不支持多数据库空间，一台Redis可以支持16个db，集群模式下只能使用一个，即<code>db 0</code>。Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景</li>
</ul>
<h2 id="Redis如何做扩容？"><a href="#Redis如何做扩容？" class="headerlink" title="Redis如何做扩容？"></a>Redis如何做扩容？</h2><p>为了避免数据迁移失败，通常使用<code>一致性哈希</code>实现动态扩容缩容，有效减少需要迁移的key数量。</p>
<p>但是Cluster模式，采用固定Slot槽位方式（16384个），对每个key计算CRC16值，然后对16384取模，然后根据slot值找到目标机器，扩容时，我们只需要迁移一部分的slot到新节点即可。</p>
<h2 id="Redis的集群原理？"><a href="#Redis的集群原理？" class="headerlink" title="Redis的集群原理？"></a>Redis的集群原理？</h2><p>一个redis集群由多个node节点组成，而多个node节点之间通过<code>cluster meet</code>命令来进行连接，组成一个集群。</p>
<p>数据存储通过分片的形式，整个集群分成<code>16384</code>个slot，每个节点负责一部分槽位。整个槽位的信息会同步到所有节点中。</p>
<p>key与slot的映射关系：</p>
<ul>
<li>键值对key，进行<code>CRC16</code>计算，计算出一个16 bit 的值</li>
<li>将16 bit 的值对16384取模，得到0~16384的数字表示key对应的哈希槽</li>
</ul>
<h2 id="Redis如何做到高可用的？"><a href="#Redis如何做到高可用的？" class="headerlink" title="Redis如何做到高可用的？"></a>Redis如何做到高可用的？</h2><p>哨兵机制。具有自动故障转移、集群监控、消息通知等功能。</p>
<p>哨兵可以同时监控所有的主、从服务器，当某个master下线时，自动提升对应的slave为master，然后由新的master对外提供服务。</p>
<h2 id="什么时Redis事务？"><a href="#什么时Redis事务？" class="headerlink" title="什么时Redis事务？"></a>什么时Redis事务？</h2><p>Redis事务是一组命令的集合，将多个命令打包，然后把这些命令按顺序添加到队列中，并且顺序执行这些命令。</p>
<p>Redis事务中没有像Mysql关系型数据库中事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行事务回滚操作。</p>
<h2 id="Redis事务执行流程？"><a href="#Redis事务执行流程？" class="headerlink" title="Redis事务执行流程？"></a>Redis事务执行流程？</h2><p>通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，在执行期间，事务不会被中断，也不会执行客户端的其他请求，直到所有命令执行完毕。</p>
<p>具体过程：</p>
<ul>
<li>服务端收到客户端请求，事务以<code>MULTI</code>开始</li>
<li>如果正处于事务状态时，则会把后续命令放入队列同时返回给客户端<code>QUEUED</code>，反之直接执行这个命令</li>
<li>当收到客户端的<code>EXEC</code>命令时，才会将队列里的命令取出、顺序执行、执行完将当前事务状态改为非事务状态</li>
<li>如果收到<code>DISCARD</code>命令，放弃执行队列中的命令，可以理解为Mysql中的回滚操作，并且将当前的事务状态改为非事务状态</li>
</ul>
<blockquote>
<p>WATCH监视某个key，该命令只能在MULTI命令之前执行。如果监视的key被其他客户端修改，EXEC将会放弃执行队列中的所有命令。UNWATCH取消监视之前通过WATCH命令监视的key。通过执行EXEC、DISCARD两个命令之前监视的key也会被取消监视。</p>
</blockquote>
<h2 id="Redis与Guava、Caffeine-有什么区别？"><a href="#Redis与Guava、Caffeine-有什么区别？" class="headerlink" title="Redis与Guava、Caffeine 有什么区别？"></a>Redis与Guava、Caffeine 有什么区别？</h2><p>缓存分为本地缓存和分布式缓存。</p>
<p>1、Caffeine、Guava，属于本地缓存，特点：</p>
<ul>
<li>直接访问内存，速度快，受内存限制，无法进行大数据存储。</li>
<li>无网络通讯开销，性能更高。</li>
<li>只支持本地应用进程访问，同步更新所有节点的本地缓存数据成本较高。</li>
<li>应用进程重启，数据会丢失。</li>
</ul>
<p>所以，本地缓存适合存储一些不易改变或者低频改变的高热点数据。</p>
<p>2、Redis属于分布式缓存，特点：</p>
<ul>
<li>集群模式，支持大数据量存储</li>
<li>数据集中存储，保证数据的一致性</li>
<li>数据跨网络传输，性能低于本地缓存。但同一个机房，两台服务器之间请求跑一个来回也就500微秒，比起其优势，这点损耗完全可以忽略，这也是分布式缓存受欢迎的原因。</li>
<li>支持副本机制，有效保证高可用性</li>
</ul>
<h2 id="如何实现一个分布式锁？"><a href="#如何实现一个分布式锁？" class="headerlink" title="如何实现一个分布式锁？"></a>如何实现一个分布式锁？</h2><ol>
<li>数据库表，性能比较差</li>
<li>使用Lua脚本(包括 Setnx + expire 两条指令)</li>
<li>set的扩展命令(set key value [ex][px] [NX|XX])</li>
<li>Redlock框架</li>
<li>Zookeeper Curator框架提供了现成的分布式锁。</li>
</ol>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
      <tags>
        <tag>面试宝典</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis键值设计规范与性能优化</title>
    <url>/archives/c0eb8ebf/</url>
    <content><![CDATA[<h2 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h2><h3 id="1、key名设计"><a href="#1、key名设计" class="headerlink" title="1、key名设计"></a>1、key名设计</h3><p>(1) 【建议】：可读性和可管理性<br>以业务名（或数据库名）为前缀（防止key冲突），用冒号分隔，比如业务表:表名:id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trade:order:1</span><br></pre></td></tr></table></figure>
<p>(2)【建议】：简洁性<br>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125; 简化为 u:&#123;uid&#125;:fr:m:&#123;mid&#125;</span><br></pre></td></tr></table></figure>
<p>(3)【强制】：不要包含特殊字符<br>反例：包含空格、换行、单双引号以及其他转义字符</p>
<h3 id="2、value设计"><a href="#2、value设计" class="headerlink" title="2、value设计"></a>2、value设计</h3><p>(1)【强制】：拒绝<code>bigkey</code>(防止网卡流量、慢查询)<br>在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2<sup>32-1</sup>)个元素，但是实际中如果下面两种情况，我们认为他是<code>bigkey</code>。</p>
<ol>
<li>字符串类型：他的big体现在单个value值很大，一般认为超过10KB就是<code>bigkey</code>。</li>
<li>非字符串类型：哈希、列表、集合、有序集合，他们的big体现在元素个数太多。</li>
</ol>
<p>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。<br>反例：一个包含200万个元素的list。<br>非字符串的<code>bigkey</code>，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止<code>bigkey</code>过期时间自动删除问题（例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）</p>
<h4 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h4><ol>
<li><p>导致redis阻塞</p>
</li>
<li><p>网络拥塞</p>
<p>bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡（按照字节算是128MB/s）的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例方式来部署，也就是说一个bigkey可能会对其他实例造成影响，其后果不堪设想。</p>
</li>
<li><p>过期删除</p>
<p>有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但他设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(lazyfree-lazy-expire yes)，就会存在阻塞Redis的可能性。</p>
</li>
</ol>
<h4 id="bigkey的产生"><a href="#bigkey的产生" class="headerlink" title="bigkey的产生"></a>bigkey的产生</h4><p>一般来说bigkey的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，看几个例子：</p>
<ol>
<li>社交类：粉丝列表，如果某些明星粉丝列表设计不当，必会造成bigkey</li>
<li>统计类：例如按天存储某项功能或者网站的用户集合，除非没有人用，否则必会bigkey</li>
<li>缓存类：将数据从数据库load出来序列化到Redis里，这个方式很常用，但是有两个地方需要注意，第一，是不是有必要吧所有字段都缓存；第二，有没有相关关联的数据，有的人为了方便把很多关联数据都存一个key下，产生了bigkey。</li>
</ol>
<h4 id="优化bigkey"><a href="#优化bigkey" class="headerlink" title="优化bigkey"></a>优化bigkey</h4><ol>
<li><p>拆</p>
<blockquote>
<p>big list：list1、list2、……listN</p>
<p>big hash：可以用数据分段存储，比如一个大的key，假设存了100万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据</p>
</blockquote>
</li>
<li><p>如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来（例如有的时候需要hmget，而不是hgetall），删除也是一样，尽量使用优雅的方式来处理。</p>
</li>
</ol>
<p>(2)【推荐】：选择合适的数据类型</p>
<p>例如：实体类型（要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡）</p>
<p>反例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set user:1:name zhangsan</span><br><span class="line">set user:1:age 20</span><br><span class="line">set user:1:favor pingpong</span><br></pre></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hmset user:1 name zhangsan age 19 favor pingpong</span><br></pre></td></tr></table></figure>

<p>(3)【推荐】：控制key的生命 周期</p>
<p>建议使用expire设置过期时间（条件允许可以打散过期时间，防止集中过期）。</p>
<h2 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h2><ol>
<li><p>【推荐】：O(N)命令关注N的数量</p>
<p>例如：hgetall、Irange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p>
</li>
<li><p>【推荐】：禁用命令</p>
<p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p>
</li>
<li><p>【推荐】：合理使用select</p>
<p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p>
</li>
<li><p>【推荐】：使用批量操作提高效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原生命令：例如mget、mset</span><br><span class="line">非原生命令：可以使用pipeline提高效率</span><br></pre></td></tr></table></figure>

<p>但是注意控制一次批量操作的元素个数（例如500以内，实际也和元素字节数有关）。</p>
<p>注意两者不同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原生命令是原子操作，pipeline是非原子操作。</span><br><span class="line">pipeline可以打包不同的命令，原生命令做不到</span><br><span class="line">pipeline需要客户端和服务端同时支持。</span><br></pre></td></tr></table></figure></li>
<li><p>【建议】Redis事务功能较弱，不建议过多使用，可以用lua替代</p>
</li>
</ol>
<h2 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h2><ol>
<li><p>【推荐】：避免多个应用使用一个Redis实例</p>
<p>正例：不相干的业务拆分，公共数据做服务化。</p>
</li>
<li><p>【推荐】：使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">jedisPoolConfig.setMaxTotal(<span class="number">5</span>);</span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">2</span>);</span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">&quot;192.168.0.60&quot;</span>, <span class="number">6379</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//具体的命令</span></span><br><span class="line">    jedis.executeCommand()</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;op key &#123;&#125; error: &quot;</span> + e.getMessage(), key, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) </span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接池参数含义：</p>
<table>
  <tr>
    <th>序号</th>
    <th>参数名</th>
    <th>含义</th>
    <th>默认值</th>
    <th>建议值</th>
  </tr>
  <tr>
    <td>1</td>
    <td>maxTotal</td>
    <td>资源池中最大连接数</td>
    <td>8</td>
    <td>设置建议见下面</td>
  </tr>
  <tr>
    <td>2</td>
    <td>maxIdle</td>
    <td>资源池允许最大空闲连接数</td>
    <td>8</td>
    <td>设置建议见下面</td>
  </tr>  
  <tr>
    <td>3</td>
    <td>minIdle</td>
    <td>资源池确保最少空闲连接数</td>
    <td>0</td>
    <td>设置建议见下面</td>
  </tr>
  <tr>
    <td>4</td>
    <td>blockWhenExhausted</td>
    <td>当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效</td>
    <td>true</td>
    <td>建议默认值</td>
  </tr>
  <tr>
    <td>5</td>
    <td>maxWaitMillis</td>
    <td>当资源池连接用尽后，调用者的最大等待时间(单位为毫秒)</td>
    <td>-1:表示用不超时</td>
    <td>不建议使用建议默认值</td>
  </tr>
  <tr>
    <td>6</td>
    <td>testOnBorrow</td>
    <td>向资源池借用连接时是否连接有效检验(ping)，无效链接会被移除</td>
    <td>false</td>
    <td>业务量很大时候建议设置为false(多一次ping的开销)</td>
  </tr>
  <tr>
    <td>7</td>
    <td>testOnReturn</td>
    <td>向资源池归还连接时是否连接有效检验(ping)，无效链接会被移除</td>
    <td>false</td>
    <td>业务量很大时候建议设置为false(多一次ping的开销)</td>
  </tr>
  <tr>
    <td>8</td>
    <td>jmxEnabled</td>
    <td>是否开启jmx监控，可用于监控</td>
    <td>true</td>
    <td>建议开启，但应用本身也要开启</td>
  </tr>
</table>

<p><strong>优化建议：</strong></p>
<ol>
<li><p>maxTotal：最大连接数，早期版本叫maxActive<br>实际上这个考虑的因素比较多：</p>
<ul>
<li><p>业务希望Redis并发量</p>
</li>
<li><p>客户端执行命令时间</p>
</li>
<li><p>Redis资源：例如nodes(例如应用个数) * maxTotal 是不能超过Redis的最大连接数maxclients。</p>
<blockquote>
<p>例如：一次命令执行时间(borrow|return resource + Jedis执行命令(含网络))的平均耗时约为1ms，一个连接的QPS大约是1000；业务期望的QPS是50000；</p>
<p>那么理论上需要的资源池大小是50000 / 1000 = 50个。但实际上这个是理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。</p>
<p>但是这个值也不是越大越好，一方面连接太多占用客户端和服务器资源，另一方面对于Redis这种高QPS的服务器，一个命令的阻塞即使设置再大资源池仍然会无济于事。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>maxIdle和minIdle</p>
<p>maxIdle实际上才是业务需要的最大连接数，maxTotal是为了<strong>给出余量</strong>，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销。</p>
<p><strong>连接池的最佳性能是maxTotal = maxIdle</strong>，这样可以避免连接池伸缩带了的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxTotal可以再放大一倍。</p>
<p>minIdle(最小控线连接数)，与其说是最小连接数，不如说是<strong>至少需要保持的空闲连接</strong>，在使用的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了maxIdle，当超过的连接执行完成业务后会慢慢被移除连接池释放掉。</p>
<p>如果系统启动完马上就会有很多的请求过来，那么可以给redis连接池做<strong>预热处理</strong>，比如快速的创建一些redis连接，执行简单命令，类似ping()，快速的将连接池里的空闲连接提升到minIdle的数量。</p>
<p><strong>连接池预热示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Jedis&gt; minIdleJedisList = <span class="keyword">new</span> ArrayList&lt;Jedis&gt;(jedisPoolConfig.getMinIdle());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        minIdleJedisList.add(jedis);</span><br><span class="line">        jedis.ping();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接。。</span></span><br><span class="line">        <span class="comment">//jedis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统一将预热的连接还回连接池</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = minIdleJedisList.get(i);</span><br><span class="line">        <span class="comment">//将连接归还回连接池</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，要根据实际系统的QPS和调用redis客户端的规模整体评估每个节点所使用的连接池大小</p>
</li>
</ol>
</li>
<li><p>【建议】：高并发下建议客户端添加熔断功能(例如Sentinel、Hystrix)</p>
</li>
<li><p>【推荐】：设置合理的密码，如有必要可以使用SSL加密访问</p>
</li>
<li><p>【建议】：<strong>Redis对于过期建有三种清除策略：</strong> </p>
<ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期的key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删除掉，所以Redis会定期主动淘汰一批已<strong>已经过期</strong> 的key</li>
<li>当前已用内存超过maxmemory限定时，触发<strong>主动清除策略</strong> </li>
</ol>
<blockquote>
<p><strong>主动清除策略</strong>在Redis4.0之前一共实现了6种内存淘汰策略，在4.0之后，有增加了2中策略，总共8种：</p>
<p><strong>(a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>  volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru：会使用LRU算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用LFU算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>(b)针对所有的key做处理：</strong> </p>
<ol start="5">
<li>allkeys-random：从所有键值对中随机选择并删除数据</li>
<li>allkeys-lru：使用LRU算法在所有的数据中进行筛选删除</li>
<li>allkeys-lfu：使用LFU算法在所有的数据中进行筛选删除</li>
</ol>
<p><strong>(c)不处理：</strong> </p>
<ol start="8">
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>LRU（Least Recently Used  最近最少使用）：淘汰很久没有被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<h2 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h2><p>LFU（Least Frequently Used 最不经常使用）：淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中急剧下降，缓存污染情况比较严重。这时使用LFU可能更好。</p>
<p>根据自身业务类型，配置好maxmemory-policy（默认是noeviction），推荐使用volatile-lru。如果不设置最大内存，当Redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换（swap），会让Redis的性能急剧下降。当Redis运行在主从模式时，只有主节点才会执行过期删除策略，然后把删除操作“del key”同步到从节点删除数据。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群原理分析</title>
    <url>/archives/c0af2eb/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis Cluster将所有数据划分为16384个slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中；当Redis Cluster的客户端连接集群时，它也会得到一份槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个key时，可以直接定位到目标节点。同时也会带来一个问题”槽位信息在客户端和服务器不一致的情况，这就需要纠正机制来实现槽位信息的纠正”。</p>
<h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h3><p>Cluster默认会对key使用CRC16算法进行hash得到一个整数值，然后用这个整数值对16384进行取模得到具体的槽位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HASH_SLOT = CRC16(key) mod 16384</span><br></pre></td></tr></table></figure>

<h3 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的key所在的槽位不是自己管理的，这时它会像客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连接这个指定的节点去获取数据。客户端收到指令之后跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有key将使用新的槽位映射表。</p>
<p><img src="/archives/c0af2eb/image-20210922092847540.png" alt="跳转重定向"></p>
<h3 id="Redis集群节点间的通信机制"><a href="#Redis集群节点间的通信机制" class="headerlink" title="Redis集群节点间的通信机制"></a>Redis集群节点间的通信机制</h3><p>Redis Cluster节点间采用gossip协议进行通信，来<strong>维护集群的元数据(集群节点信息、主从角色、节点数量、各节点共享的数据等)</strong> 。</p>
<p>维护集群元数据的方式有两种：</p>
<ol>
<li>集中式</li>
<li>gossip</li>
</ol>
<h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p>优点：在于元数据的更新和读取时效性非常好，一旦元数据出现变更就会立即同步到集中式存储中，其他节点读取的时候就会立即感知到数据的变化；</p>
<p>缺点：在于所有的元数据的更新压力全部会集中在一个地方，可能导致元数据的存储压力。很多中间件会借助zookeeper集中式存储元数据。</p>
<h4 id="gossip协议"><a href="#gossip协议" class="headerlink" title="gossip协议"></a>gossip协议</h4><p><img src="/archives/c0af2eb/gossip%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1.gif" alt="gossip协议通信"></p>
<p>gossip协议包含多种信息，包括<code>ping</code>、<code>pong</code>、<code>meet</code>、<code>fail</code>等。</p>
<blockquote>
<p><code>meet</code>：某个节点发送<code>meet</code>给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点开始通信；</p>
<p><code>ping</code>：每个节点都会频繁的给其他节点发送<code>ping</code>，其中包含自己的状态还有自己维护的集群元数据，互相通过<code>ping</code>交换元数据(类似感知到集群节点增加和删除，hash slot信息等)；</p>
<p><code>pong</code>：对<code>ping</code>和<code>meet</code>信息的返回，包含自己的状态和其他信息，也可以用于广播和更新；</p>
<p><code>fail</code>：某个节点判断另一个节点<code>fail</code>之后，就会发送<code>fail</code>给其他节点，通知其他节点，指定节点宕机了；</p>
</blockquote>
<p><strong>优点：</strong> 在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，有一定的延时，降低了压力；</p>
<p><strong>缺点：</strong> 在于数据更新有一定的延时，可能导致集群的一些操作会有些滞后；</p>
<h4 id="gossip协议通信端口"><a href="#gossip协议通信端口" class="headerlink" title="gossip协议通信端口"></a>gossip协议通信端口</h4><p>每个节点都有一个专门用于节点之间gossip通信的端口，就是自己提供服务的端口号+10000，比如：节点端口是7001，那么用于节点通信的端口就是17001。</p>
<p>每个节点每隔一段时间都会往另外几个节点发送<code>ping</code>消息，同时其他几个接收到<code>ping</code>消息之后返回<code>pong</code>消息。</p>
<h3 id="网络抖动问题"><a href="#网络抖动问题" class="headerlink" title="网络抖动问题"></a>网络抖动问题</h3><p>在正常生产环境中，经常会出现突然部分连接不可访问，过一会之后又恢复正常。对于这样的问题Redis集群模式也提供了解决方案；可以配置选项<code>cluster-node-timeout</code>，表示当某个节点持续timeout的时间失联时，才可以认定该节点出现故障，需要进行主从机器换。如果没有这个选项，网络抖动导致主从频繁切换，数据重复复制。</p>
<h3 id="Redis集群选举原理"><a href="#Redis集群选举原理" class="headerlink" title="Redis集群选举原理"></a>Redis集群选举原理</h3><p>当slave发现自己的master变为fail状态时，便会尝试进行<code>Failover</code>，让其成为新的master。由于挂掉了master可能会有多个slave，从而存在多个slave竞争成为master节点的过程，过程如下：</p>
<ol>
<li><p>slave发现自己的master变为FAIL；</p>
</li>
<li><p>将自己记录的集群<code>currentEpoch</code>加1，并广播<code>FAILOVER_AUTH_RERQUEST</code>信息；</p>
</li>
<li><p>其他节点接收到该信息，只有master响应，判断请求者的合法性，并发送<code>FAILOVER_AUTH_ACK</code>，对每一个<code>epoch</code>只发送一次<code>ack</code>；</p>
</li>
<li><p>尝试<code>failover</code>的slave收集master返回的<code>FAILOVER_AUTH_ACK</code>；</p>
</li>
<li><p>slave收到<strong>超过半数master的ack</strong>后变成新的master</p>
<blockquote>
<p>这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩下一个主节点是不能选举成功的。</p>
</blockquote>
</li>
<li><p>slave广播<code>pong</code>消息通知其他集群节点</p>
</li>
</ol>
<p>从节点并不是在主节点已进入<code>FAIL</code>状态就马上尝试发起选举，而是有一定的延时，这个延时确保我们等待<code>FAIL</code>状态在集群中传播，slave如果立即尝试选举，其他masters或许没有意识到<code>FAIL</code>状态，可能会拒绝投票。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时计算公式：`DELAY = 500ms + random(0~500ms) + SLAVE_RANK * 1000ms`</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>SLAVE_RANK</code>表示此slave已经从master复制数据的总量的rank。Rank越小表示已经复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举。</p>
</blockquote>
<h3 id="集群脑裂数据丢失问题"><a href="#集群脑裂数据丢失问题" class="headerlink" title="集群脑裂数据丢失问题"></a>集群脑裂数据丢失问题</h3><p>redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p>
<p>规避方法可以在redis配置里加上参数(这种方法不可能百分之百避免数据丢失，参考集群leader选举机制)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min-replicas-to-write 1 # 写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>这个配置在一定程度上影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。</p>
</blockquote>
<h3 id="集群是否完整才能对外提供服务？"><a href="#集群是否完整才能对外提供服务？" class="headerlink" title="集群是否完整才能对外提供服务？"></a>集群是否完整才能对外提供服务？</h3><p>当<code>redis.conf</code>的配置<code>cluster-require-full-coverage</code>为no时，表示负责一个插槽的主库下线且没有相应的从库进行故障恢复时，集群任然可用，如果为yes则集群不可用。</p>
<h3 id="Redis集群为什么至少需要三个master节点，且推荐节点数为奇数？"><a href="#Redis集群为什么至少需要三个master节点，且推荐节点数为奇数？" class="headerlink" title="Redis集群为什么至少需要三个master节点，且推荐节点数为奇数？"></a>Redis集群为什么至少需要三个master节点，且推荐节点数为奇数？</h3><p>因为新master的选举需要大于半数的集群master同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。  </p>
<p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没有办法选举新master节点了，所以奇数的master节点更多的是从<strong>节省机器资源角度出发</strong>的。</p>
<h3 id="Redis集群对批量操作指令的支持"><a href="#Redis集群对批量操作指令的支持" class="headerlink" title="Redis集群对批量操作指令的支持"></a>Redis集群对批量操作指令的支持</h3><p>对于类似<code>mset</code>，这样的多个key的原生批量操作指令，redis集群只支持所有key落在同一slot的情况，如果有多个key一定要使用<code>mset</code>命令在redis集群上操作，则可以在可以的前面加上<code>&#123;XXX&#125;</code>，这样参数数据分片hash计算的只会是大括号中的值，这样能确保不同的key能落在同一slot中，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mset &#123;user1&#125;:1:name zhangsan &#123;user1&#125;:1:age 20</span><br></pre></td></tr></table></figure>

<p>假如name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的<code>user1</code>做hash slot计算，所以算出来的slot值肯定相同，最后能落在同一slot。</p>
<h3 id="哨兵leader选举流程"><a href="#哨兵leader选举流程" class="headerlink" title="哨兵leader选举流程"></a>哨兵leader选举流程</h3><p>当一个master服务器被某个sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。每个发现master服务器下线的sentinel都可以要求其他sentinel选举自己为sentinel的leader，选举是先到先得。同时每一个sentinel每次选举都会自增配置选举周期，每个选举周期只会选择一个sentinel的leader。如果所有<strong>超过一半</strong>的sentinel选举某个sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程和集群的master选举很类似。</p>
<p>哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新的master。不过为了高可用一般都推荐至少部署三个哨兵节点。为什么推荐奇数个哨兵节点，原理和集群奇数个master节点类似。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用集群水平扩展</title>
    <url>/archives/c709d40a/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="/archives/1d883d6c/">《Redis高可用集群部署》</a>中我们部署了Redis高可用架构。整个集群由6个节点组成，这6个节点分布在三台机器上，采用了三主三从模式。</p>
<p><img src="/archives/c709d40a/image-20210924125557525.png" alt="Redis高可用三主三从架构"></p>
<h2 id="1、启动集群"><a href="#1、启动集群" class="headerlink" title="1、启动集群"></a>1、启动集群</h2><p>启动<a href="/archives/1d883d6c/">《Redis高可用集群部署》</a>中搭建好的三主三从高可用集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-server /home/redis/cluster/8001/redis.conf</span><br><span class="line">/home/redis/build/bin/redis-server /home/redis/cluster/8002/redis.conf</span><br><span class="line">/home/redis/build/bin/redis-server /home/redis/cluster/8003/redis.conf</span><br><span class="line">/home/redis/build/bin/redis-server /home/redis/cluster/8004/redis.conf</span><br><span class="line">/home/redis/build/bin/redis-server /home/redis/cluster/8005/redis.conf</span><br><span class="line">/home/redis/build/bin/redis-server /home/redis/cluster/8006/redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="登录端口为8001的redis客户端"><a href="#登录端口为8001的redis客户端" class="headerlink" title="登录端口为8001的redis客户端"></a>登录端口为8001的redis客户端</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -c -h 192.168.31.16 -p 8001</span><br></pre></td></tr></table></figure>

<h3 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">192.168.31.16:8001&gt; cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924131031247.png" alt="Redis高可用集群节点状态"></p>
<p>从上面的集群状态信息中可以看出，这个集群运行正常，三个master节点和三个slave节点，8001端口的实例节点存储0-5460这些hash slot，8002端口的节点存储5461-10922这个范围的hash slot；8003端口的实例节点存储10923-16383这个范围的hash slot；这三个master节点存储的所有hash slot组成整个集群的存储槽位，slave节点是每个主节点的备份从节点，不会显示存储槽位。</p>
<h2 id="2、集群操作"><a href="#2、集群操作" class="headerlink" title="2、集群操作"></a>2、集群操作</h2><p>我们在原始的集群基础上在新增一主(8007)一从(8008)，增加节点后的集群架构如下图：虚线节点为新加入的节点</p>
<p><img src="/archives/c709d40a/image-20210924132147346.png" alt="新增节点之后集群架构"></p>
<h3 id="增加Redis节点实例"><a href="#增加Redis节点实例" class="headerlink" title="增加Redis节点实例"></a>增加Redis节点实例</h3><p>在/home/redis/cluster下新建8007和8008文件夹</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir 8007 8008</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924132807201.png" alt="创建文件夹"></p>
<p>并把8006文件夹下的<code>redis.conf</code>配置文件拷贝到8007和8008两个文件夹中，如下</p>
<p><img src="/archives/c709d40a/image-20210924133002072.png" alt="拷贝配置文件"></p>
<p>修改8007文件夹下的<code>redis.conf</code>配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ./8007/redis.conf</span><br></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port: 8007</span><br><span class="line">dir /home/redis/cluster/8007/</span><br><span class="line">cluster-config-file nodes-8007.conf</span><br></pre></td></tr></table></figure>

<p>修改8008文件下的<code>redis.conf</code>配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ./8008/redis.conf</span><br></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port: 8008</span><br><span class="line">dir /home/redis/cluster/8008/</span><br><span class="line">cluster-config-file nodes-8008.conf</span><br></pre></td></tr></table></figure>

<p>启动8007和8008两个服务，并查看启动状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/buile/bin/redis-server /home/redis/cluster/8007/redis.conf</span><br><span class="line">/home/redis/buile/bin/redis-server /home/redis/cluster/8008/redis.conf</span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<h3 id="通过redis帮助命令查找加入节点的命令"><a href="#通过redis帮助命令查找加入节点的命令" class="headerlink" title="通过redis帮助命令查找加入节点的命令"></a>通过redis帮助命令查找加入节点的命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924150425805.png" alt="cluster help手册"></p>
<blockquote>
<p><strong><code>create</code>：</strong> 创建一个集群环境<code>host1:port1</code>……<code>hostN:portN</code><br><strong><code>call</code>：</strong> 可以知晓redis命令<br><strong><code>add-node</code>：</strong> 将一个节点添加到集群里，第一个参数为新节点的IP:Port，第二个参数为集群中任意一个已经存在的节点的IP:Port<br><strong><code>del-node</code>：</strong> 删除一个节点<br><strong><code>reshard</code>：</strong> 重新分片<br><strong><code>check</code>：</strong> 检查集群状态</p>
</blockquote>
<h3 id="配置8007为集群主节点"><a href="#配置8007为集群主节点" class="headerlink" title="配置8007为集群主节点"></a>配置8007为集群主节点</h3><p>使用<code>add-node</code> 命令新增一个主节点8007(master)，前面的IP:Port为新增节点，后面的IP:Port为已知存活的节点。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster add-node 192.168.31.80:8007 192.168.31.80:8003</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924151637255.png" alt="新节点加入集群"></p>
<p>出现”[OK] New node added correctly”表示新节点加入成功。</p>
<p>再查看集群状态，确认一下是否真正加入成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -c -h 192.168.31.80 -p 8003</span><br><span class="line">192.168.31.80:8003&gt; cluster nodes</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924152021907.png" alt="8007节点加入成功"></p>
<blockquote>
<p><strong>注意：当添加节点成功之后，新增的节点不会有任何数据，因为它还没有分配任何的slot(hash槽)，我们需要手动为新节点分配hash槽</strong></p>
</blockquote>
<p>使用<code>redis-cli</code>命令为8007分配hash槽，找到集群中的任意一个主节点，对其进行重新分片工作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster reshard 192.168.31.80:8006</span><br></pre></td></tr></table></figure>

<p>输出信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 600</span><br><span class="line"><span class="comment"># (ps:需要多少个槽移动到新的节点上，自己设置，比如600个hash槽)</span></span><br><span class="line">What is the receiving node ID? a269eb14c20c00bce5277f1ab7d185a0b4ff7081</span><br><span class="line"><span class="comment"># (ps:把这600个hash槽移动到哪个节点上去，需要指定节点id)</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: all</span></span><br><span class="line"><span class="comment"># (ps:输入all为从所有主节点(8001,8002,8003)中分别抽取相应的槽数指定到新节点中，抽取的总槽数为600个)</span></span><br><span class="line"></span><br><span class="line">Ready to move 600 slots.</span><br><span class="line">  Source nodes:</span><br><span class="line">    M: 9733f9dcf9f49366c20ba48e9255ed8dacbf3ce9 192.168.31.16:8004</span><br><span class="line">       slots:[10923-16383] (5461 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">    M: 7335dcf54192b1015ff9b386391e424bd5379bb3 192.168.31.224:8002</span><br><span class="line">       slots:[5461-10922] (5462 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">    M: 1e0e204666cc8eab8c138913df4dd23135b38a05 192.168.31.16:8001</span><br><span class="line">       slots:[0-5460] (5461 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">  Destination node:</span><br><span class="line">    M: a269eb14c20c00bce5277f1ab7d185a0b4ff7081 192.168.31.80:8007</span><br><span class="line">       slots: (0 slots) master</span><br><span class="line">  Resharding plan:</span><br><span class="line">    Moving slot 5461 from 7335dcf54192b1015ff9b386391e424bd5379bb3</span><br><span class="line">    Moving slot 5462 from 7335dcf54192b1015ff9b386391e424bd5379bb3</span><br><span class="line">……………………</span><br><span class="line"></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"><span class="comment"># (ps:输入yes确认开始执行分片任务)</span></span><br><span class="line">……………………</span><br></pre></td></tr></table></figure>

<p>查看最新集群状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -c -h 192.168.31.16 -p 8004</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924153543684.png" alt="最新集群状态"></p>
<blockquote>
<p><strong>如上图所示，现在我们的8007已经有hash槽了，也就是现在可以在8007上写数据了，到此为止8007已经加入到集群中，并且是主节点(master)</strong></p>
</blockquote>
<h3 id="配置8008为8007的从节点"><a href="#配置8008为8007的从节点" class="headerlink" title="配置8008为8007的从节点"></a>配置8008为8007的从节点</h3><p>添加从节点8008到集群中去并查看集群状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster add-node 192.168.31.80:8008 192.168.31.80:8007</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924155734308.png" alt="配置8008为8007的从节点"></p>
<p>查看集群状态信息：</p>
<p><img src="/archives/c709d40a/image-20210924155923889.png" alt="集群状态"></p>
<p>如图所示，存在一个master(8008)节点，没有被分配任何的hash槽。</p>
<p>我们需要执行<code>replicate</code>命令来指定当前节点(从节点)的主节点id为哪个，首先需要连接新加的8008节点的客户端，然后使用集群命令进行操作，把当前的8008(slave)节点指定到一个主节点下(这里使用之前创建的8007主节点)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -c -h 192.168.31.80 -p 8008</span><br><span class="line">cluster replicate a269eb14c20c00bce5277f1ab7d185a0b4ff7081 <span class="comment">#后面这串id为8007的节点id</span></span><br></pre></td></tr></table></figure>

<p>查看集群状态，8008节点已成功添加为8007节点的从节点</p>
<p><img src="/archives/c709d40a/image-20210924160713937.png" alt="集群状态"></p>
<h3 id="删除8008从节点"><a href="#删除8008从节点" class="headerlink" title="删除8008从节点"></a>删除8008从节点</h3><p>用<code>del-node</code>删除从节点8008，指定删除节点IP和端口，以及节点id</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster del-node 192.168.31.80:8008 63aef88d1fda94a340f045f386eef8f61453c755</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>192.168.31.80:8008</code> 为要删除节点的IP和端口<br><code>63aef88d1fda94a340f045f386eef8f61453c755</code> 为要删除节点的id</p>
</blockquote>
<p><img src="/archives/c709d40a/image-20210924161819857.png" alt="删除8008节点"></p>
<p>查看集群状态，如下图所示，8008这个slave节点已经移除了。</p>
<p><img src="/archives/c709d40a/image-20210924171054803.png" alt="集群状态"></p>
<p>查看redis运行的实例，并关掉8008服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="built_in">kill</span> 进程ID</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924171652442.png" alt="关闭8008进程"></p>
<h3 id="删除8007主节点"><a href="#删除8007主节点" class="headerlink" title="删除8007主节点"></a>删除8007主节点</h3><p>最后，我们删除之前加入的主节点8007，这个步骤比较麻烦，因为主节点的里面是有分配hash槽的，所以我们这里必须要先把8007里的hash槽放入到其他可用主节点中去，然后进行移除节点操作，不然会出现数据丢失问题(目前只能把master的数据迁移到一个节点上，暂时做不了平均分配功能)，执行命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster reshard 192.168.31.80:8007</span><br></pre></td></tr></table></figure>

<p><strong>输出如下结果：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@MiWiFi-R1CM-srv cluster]<span class="comment"># /home/redis/build/bin/redis-cli --cluster reshard 192.168.31.80:8007</span></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.31.80:8007)</span><br><span class="line">M: a269eb14c20c00bce5277f1ab7d185a0b4ff7081 192.168.31.80:8007</span><br><span class="line">   slots:[0-198],[5461-5661],[10923-11121] (599 slots) master</span><br><span class="line">S: 93b31cae2f224d31c3c2e64c72ae3415dda34b2c 192.168.31.80:8006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 7335dcf54192b1015ff9b386391e424bd5379bb3</span><br><span class="line">M: 9733f9dcf9f49366c20ba48e9255ed8dacbf3ce9 192.168.31.16:8004</span><br><span class="line">   slots:[11122-16383] (5262 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: caf9f23f9e339c640d35d181f2c5c398b5ba2f30 192.168.31.224:8005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1e0e204666cc8eab8c138913df4dd23135b38a05</span><br><span class="line">S: 37e9a109f56d0e86995ff02482df4d0d94b6fc2c 192.168.31.80:8003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 9733f9dcf9f49366c20ba48e9255ed8dacbf3ce9</span><br><span class="line">M: 1e0e204666cc8eab8c138913df4dd23135b38a05 192.168.31.16:8001</span><br><span class="line">   slots:[199-5460] (5262 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 7335dcf54192b1015ff9b386391e424bd5379bb3 192.168.31.224:8002</span><br><span class="line">   slots:[5662-10922] (5261 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 600</span><br><span class="line">What is the receiving node ID? 1e0e204666cc8eab8c138913df4dd23135b38a05</span><br><span class="line"><span class="comment"># (ps:这里是需要把数据移动到哪？我们这里指定8001的主节点id)</span></span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: a269eb14c20c00bce5277f1ab7d185a0b4ff7081</span></span><br><span class="line"><span class="comment"># (ps:这里是需要数据源，也就是我们要移除的8007节点id)</span></span><br><span class="line">Source node <span class="comment">#2: done</span></span><br><span class="line"><span class="comment"># (ps:这里直接输入done 开始生成迁移计划)</span></span><br><span class="line"></span><br><span class="line">Ready to move 600 slots.</span><br><span class="line">  Source nodes:</span><br><span class="line">    M: a269eb14c20c00bce5277f1ab7d185a0b4ff7081 192.168.31.80:8007</span><br><span class="line">       slots:[0-198],[5461-5661],[10923-11121] (599 slots) master</span><br><span class="line">  Destination node:</span><br><span class="line">    M: 1e0e204666cc8eab8c138913df4dd23135b38a05 192.168.31.16:8001</span><br><span class="line">       slots:[199-5460] (5262 slots) master</span><br><span class="line">       1 additional replica(s)</span><br><span class="line">  Resharding plan:</span><br><span class="line">    Moving slot 0 from a269eb14c20c00bce5277f1ab7d185a0b4ff7081</span><br><span class="line">    Moving slot 1 from a269eb14c20c00bce5277f1ab7d185a0b4ff7081</span><br><span class="line">………………</span><br><span class="line">    Moving slot 11121 from a269eb14c20c00bce5277f1ab7d185a0b4ff7081</span><br><span class="line">    Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line">    <span class="comment"># (ps:这里输入yes开始迁移)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>致此，我们已经成功把8007主节点的数据迁移到8001上去了，我们可以看一下集群状态：</p>
<p><img src="/archives/c709d40a/image-20210924174054621.png" alt="集群节点状态"></p>
<blockquote>
<p>从上图可以看出8007下面已经没有任何hash槽了，证明数据迁移成功！</p>
</blockquote>
<p>最后直接使用<code>del-node</code>命令删除8007主节点即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli --cluster del-node 192.168.31.80:8007 a269eb14c20c00bce5277f1ab7d185a0b4ff7081</span><br></pre></td></tr></table></figure>

<p><img src="/archives/c709d40a/image-20210924174816518.png" alt="删除8007主节点"></p>
<p>在查看集群状态，还原到了原来的状态：</p>
<p><img src="/archives/c709d40a/image-20210924174859543.png" alt="集群状态"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用集群部署</title>
    <url>/archives/1d883d6c/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="/archives/8bd0f0fd/">《Redis哨兵架构搭建》</a>中我们说了怎么搭建哨兵架构，既然有了哨兵架构，为什么还要提供<strong>Redis高可用集群模式</strong>呢？那就的从哨兵模式的缺点开始说起；</p>
<p>在redis3.0以前的版本要实现集群一般都是借助哨兵Sentinel工具来监控master节点的状态，如果master节点异常，则会主动切换，将某一台slave作为master，哨兵配置略微复杂，并且在性能和高可用方面都表现一般，特别是在主从切换的瞬间存在<em><strong>访问瞬断</strong></em>的情况，而且哨兵模式只有一个主节点是对外提供服务的，没有办法支持很高的并发量，还有单个节点的内存也不适合设置过大，否则会导致持久化文件太大，影像数据恢复或主从数据同步的效率。</p>
<p>基于以上哨兵模式的种种的缺点，所以Redis又给我们提供了高可用集群模式。</p>
<h2 id="高可用集群模式"><a href="#高可用集群模式" class="headerlink" title="高可用集群模式"></a>高可用集群模式</h2><p><img src="/archives/1d883d6c/image-20210918123415239.png" alt="Redis高可用集群架构图"></p>
<p>redis集群是一个有多个<strong>主从节点群组成的分布式服务器群</strong>，它具有<strong>复制、高可用和分片</strong>特性。Redis集群不需要Sentinel哨兵也能完成节点的移除和故障的转移功能。只是在启动的时候需要将每个节点设置成集群模式即可，这种集群模式没有中心节点，可以水平扩展，按照官方文档描述可以扩展到上万个节点(<em><strong>官方推荐不超过1000个节点</strong></em>)。<strong>redis集群的性能和高可用性都优于之前版本的哨兵模式，且集群配置也非常简单</strong>。</p>
<h2 id="Redis高可用集群搭建"><a href="#Redis高可用集群搭建" class="headerlink" title="Redis高可用集群搭建"></a>Redis高可用集群搭建</h2><blockquote>
<p>redis集群需要至少<strong>三个master节点</strong>，我们这里搭建三个master节点，并且每个master在搭建一个slave节点，总共6个redis节点，这里用三台机器部署6个redis实例，每台机器一主一从。</p>
</blockquote>
<p>最终我们搭建的高可用架构图如下：</p>
<p><img src="/archives/1d883d6c/image-20210924125414621.png" alt="Redis高可用三主三从结构"></p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>在第一台机器的/home/redis/下创建文件夹<code>cluster</code>，然后在其下面分别创建2个文件夹如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/redis/cluster</span><br><span class="line">mkdir 8001 8004</span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>把之前的<code>redis.conf</code>配置文件copy到8001下，修改以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">port 8001 #（分别对每个机器的端口号进行设置）</span><br><span class="line">pidfile /var/run/redis_8001.pid  #把pid进程写入pidfile配置的文件</span><br><span class="line">dir /home/redis/cluster/8001/ # （指定数据文件存放位置，必须要指定不同的目录位置，不然会丢数据）</span><br><span class="line">cluster-enabled yes # 启动集群模式</span><br><span class="line">cluster-config-file nodes-8001.config # (集群节点信息文件，这里800X最好和port对应)</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line"># bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）</span><br><span class="line">protected-mode no # 关闭保护模式</span><br><span class="line"># 如果要设置密码需要增加以下配置</span><br><span class="line">requirepass 123456 # 设置redis访问密码</span><br><span class="line">masterauth 123456 # 设置集群节点间访问密码，跟上面一致</span><br></pre></td></tr></table></figure>

<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>把修改后的配置文件，copy到8004，修改第二步中的2,3,4,6行的端口号。</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>另外两台机器也需要做上面几步操作，第二台机器用8002和8005，第三台机器用8003和8006</p>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>分别启动6个redis实例，然后检查是否启动成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>用<code>redis-cli</code>创建整个redis集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -a mst --cluster create --cluster-replicas 1 192.168.31.16:8001 192.168.31.224:8002 192.168.31.80:8003 192.168.31.16:8004 192.168.31.224:8005 192.168.31.80 8006</span><br></pre></td></tr></table></figure>

<p>上面命令中的 1 代表每个创建的主服务器节点创建一个从服务器节点</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>执行上述命令需要先确认三台机器之间的redis实例能不能互相访问，如果不能访问需要我们把防火墙关闭，如果不关闭防火墙，则需要打开redis服务端口和集群节点gossip通信端口16379（默认是在redis端口上加10000）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld # 临时关闭防火墙</span><br><span class="line">systemctl disable firewalld # 禁止开机启动</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><p>验证集群是否成功</p>
<ol>
<li><p>连接任意一个客户端即可：<code>./redis-cli -c -h -p (-a访问服务端密码，-c表示集群模式，-h表示指定ip地址，-p表示指定端口号)</code>，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -a mst -c -h 192.168.31.16 -p 800*</span><br></pre></td></tr></table></figure></li>
<li><p>进行验证：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster info <span class="comment">#查看集群信息</span></span><br><span class="line">cluster nodes <span class="comment"># 查看节点列表</span></span><br></pre></td></tr></table></figure></li>
<li><p>进行数据操作验证</p>
</li>
<li><p>关闭集群规则需要逐个进行关闭，使用命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -a mst -c -h 192.168.31.16 -p 800* shutdown</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(一)</title>
    <url>/archives/81aeb1f/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Spring中最重要的就属<code>IOC</code>了，不论是在面试中，还是在一些中间件与Spring的继承中，都离不开<code>IOC</code>，下面就来瞧瞧<code>IOC</code>是个什么东西，他是怎么一个加载流程，先大致粗略的了解一下！</p>
<h2 id="一、下载Spring源码"><a href="#一、下载Spring源码" class="headerlink" title="一、下载Spring源码"></a>一、<a href="https://gitee.com/li-huibin/spring-framework-5.2.16.-release">下载Spring源码</a></h2><h2 id="二、编译Spring源码"><a href="#二、编译Spring源码" class="headerlink" title="二、编译Spring源码"></a>二、编译Spring源码</h2><p>在编译的时候有些包是需要从外网下载的，有条件的可以科学上网，这样可以加快编译速度。如果不管怎么编译都是报错，或者下载包总是失败，可以留言我，我可以提供一点有限的帮助。</p>
<h2 id="三、创建demo模块"><a href="#三、创建demo模块" class="headerlink" title="三、创建demo模块"></a>三、创建demo模块</h2><p><img src="/archives/81aeb1f/image-20210813193225670.png" alt="创建demo模块"></p>
<blockquote>
<p><strong>注意：</strong> 一定要选择<code>Gradle</code>，别选错了，因为从<code>Spring5</code>开始，使用的是<code>Gradle</code>来构建整个项目的</p>
</blockquote>
<p><img src="/archives/81aeb1f/image-20210813193542786.png" alt="创建demo模块-2"></p>
<p>这里因为我已经事先创建过了模块，所以上面会有一个报错。然后点<code>Finish</code>完成创建。</p>
<p>创建完毕之后，在初始化模块的目录结构，我的目录结构是如下结构：</p>
<p><img src="/archives/81aeb1f/image-20210813193846621.png" alt="demo模块目录结构"></p>
<p>这里我创建了三个类<code>ApplicationMain</code>启动类、<code>TestIOC</code>接口、实现<code>TestIOC</code>接口的<code>TestIOCImpl</code>实现类。</p>
<p><code>TestIOC.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:52</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestIOC</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloIOC</span><span class="params">(String say)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>TestIOCImpl.java</code>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.TestIOC;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIOCImpl</span> <span class="keyword">implements</span> <span class="title">TestIOC</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloIOC</span><span class="params">(String say)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;====&gt; &quot;</span> + say);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationMain.java</code>启动类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.impl.TestIOCImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: spring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1 mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-07-26 14:56</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lhb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br><span class="line">		TestIOCImpl bean = applicationContext.getBean(TestIOCImpl.class);</span><br><span class="line">		bean.helloIOC(<span class="string">&quot;hello spring ioc&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、IOC主流程分析"><a href="#四、IOC主流程分析" class="headerlink" title="四、IOC主流程分析"></a>四、<code>IOC</code>主流程分析</h2><p>首先，肯定是要从整个程序的入口开始分析的，下面就从<code>ApplicationMain</code>中的<code>main</code>方法开始。从上图中我们可以看到在<code>ApplicationMain</code>类中的<code>main</code>方法中手动创建了一个<code>AnnotationConfigApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br></pre></td></tr></table></figure>

<p>嗯？？what.<code>AnnotationConfigApplicationContext</code>是一个什么东西。。为什么要创建这个东西；那么就带着这个疑问点到他的源码里看一看。<code>Ctrl</code>+鼠标左键走起。</p>
<p><img src="/archives/81aeb1f/image-20210813200002798.png" alt="AnnotationConfigApplicationContext.java"></p>
<p>这两个名叫<code>Juergen Hoeller和Chris Beams</code>的作者给写了一大片注释，大概意思就是<code>AnnotationConfigApplicationContext</code>是整个引用的上下文，可以用他来获取容器中的Bean，和注册Bean等；<code>AnnotationConfigApplicationContext</code>实现会这继承了Spring框架中大部分的基础能力，一切Spring的动作，都是从这个类开始进行的，并且整个过程也都是这个类来进行接管的；所以它也是比较强大；总之大部分容器中的和Bean的操作都可以通过<code>AnnotationConfigApplicationContext</code>来操作。</p>
<p><img src="/archives/81aeb1f/image-20210813201436746.png" alt="AnnotationConfigApplicationContext关系图"></p>
<p>从上面的<code>AnnotationConfigApplicatioinContext</code>类关系图中可以看出，这个类其实比较复杂的。好了这个类先聊到这里，接下来我们看到<code>AnnotationConfigApplicationContext</code>的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AnnotationConfigApplicationContext, deriving bean definitions</span></span><br><span class="line"><span class="comment"> * from the given component classes and automatically refreshing the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> componentClasses one or more component classes &amp;mdash; for example,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	 * 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	 * DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	 * 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	 * 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	 * 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">this</span>();</span><br><span class="line">	<span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	 * 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	 * 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	 * 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	register(componentClasses);</span><br><span class="line">	<span class="comment">/** 刷新 */</span></span><br><span class="line">	refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数中调用了三个方法，下面一一说一下这三个方法都干了什么</p>
<blockquote>
<p><strong><code>this()</code>：</strong>这个方法调用了本类的无参数构造函数，其实在调用<code>AnnotationConfigApplicationContext</code>的无参数构造方法之前，先调用的父类的构造方法。在这些方法中主要是做了一些初始化的操作，比如初始化我们的容器<code>beanDefinitionMap</code>，初始化资源读取器<code>AnnotationBeanDefinitionReader</code>和资源扫描器<code>BeanDefinitionScanner</code>等</p>
<p><strong><code>register(componentClasses)</code>：</strong> 这个方法很重要；在这个方法中会扫描所有的Bean，并且会把扫描出来的Bean定义进行注册；Spring还会在这里把带有<code>@Configuration</code>注解的类进行标记为<code>Full</code>配置类，不带<code>@Configuration</code>注解的类但是有<code>@Component</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportSource</code>、<code>@Server</code>等注解的类标记为<code>Lite</code>配置类，然后被标记为<code>Full</code>的配置类会进行<code>CGLIB</code>代理增强处理。</p>
<blockquote>
<p><em><strong>Spring的循环依赖也是在这个过程中解决的，后面会详细看这个方法</strong></em>    </p>
</blockquote>
<p><strong><code>refresh()</code>：</strong> 这个方法很重要，几乎Spring所有的启动动作都会在这个方法来完成的。在这里会准备Bean工厂，为Bean工厂设置一些依赖到的接口，也会添加后置处理器，注册类的后置处理器，注册Bean工厂后置处理器，解析<code>@Import</code>、<code>@Component</code>注解、注册Bean后置处理器、初始化事件、实例化Bean等操作、发布初始化完成事件等操作；这个方法后面也会详细看</p>
</blockquote>
<p>下面通过一个图来回顾总结一下整个流程：</p>
<p><img src="/archives/81aeb1f/IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="Spring-IOC原理"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建博客详细教程</title>
    <url>/archives/8eb04e19/</url>
    <content><![CDATA[<p>经历了两天的折腾，终于搭建好了个人博客。由于第一次搭建个人博客，所以在搭建过程中也遇到了很多的问题。现在特意整理一下整个搭建过程以及中间遇到的问题。</p>
<h4 id="一、软件准备"><a href="#一、软件准备" class="headerlink" title="一、软件准备"></a>一、软件准备</h4><ul>
<li><a href="https://git-scm.com/downloads">安装Git</a></li>
</ul>
<p><img src="/archives/8eb04e19/image-20210727204933786-16274456504351.png" alt="image-20210727204933786"></p>
<p>根据系统需求下载对应的版本，这里下载windows版本</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/download/">安装Node.js</a></li>
<li>安装Hexo</li>
</ul>
<p>默认已经安装以上两个软件，接下来安装Hexo。在任意文件夹中打开<code>CMD</code>窗口执行如下指令安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>等待大概一分钟安装完毕，执行<code>hexo -v</code> 如果出现版本信息，说明安装成功。</p>
<h4 id="二、创建git远程仓库"><a href="#二、创建git远程仓库" class="headerlink" title="二、创建git远程仓库"></a>二、创建git远程仓库</h4><p>1、如果还没有github账号，需要先注册账号。如果不会注册直接百度就可以，类似的教程百度有很多；这里默认都注册过了github。接下来登录github创建仓库：如下图</p>
<p><img src="/archives/8eb04e19/image-20210727221144333.png" alt="image-20210727221144333"></p>
<blockquote>
<p><strong>特别需要注意的是 第一步中仓库名称必须是Ower.github.io 格式，其中Ower是用户名。如果不是这个格式的话，后面使用hexo生成的静态页面会识别不了</strong></p>
</blockquote>
<p>2、以上步骤完成之后，在电脑本地创建一个文件夹，存放我们的本地blog。</p>
<p><img src="/archives/8eb04e19/image-20210727222117448.png" alt="image-20210727222117448"></p>
<p>3、打开CMD命令窗口，并且cd到blog文件中执行初始化blog工程指令<code>hexo init</code></p>
<p><img src="/archives/8eb04e19/image-20210727223759193.png" alt="image-20210727223759193"></p>
<p>完毕之后目录结构如下：</p>
<p><img src="/archives/8eb04e19/image-20210727223938616.png" alt="image-20210727223938616"></p>
<blockquote>
<p>想要详细了解目录结构可以查看hexo官网 <a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p>
</blockquote>
<p>4、配置blog工程中的<code>_config.yml</code>文件</p>
<p><img src="/archives/8eb04e19/image-20210727224818946.png" alt="image-20210727224818946"></p>
<p><img src="/archives/8eb04e19/image-20210727225056195.png" alt="image-20210727225056195"></p>
<p>这里主要是设置上图中圈中的三个地方，这里解释一下三个代表什么:</p>
<ul>
<li><code>url</code>: 表示将来访问仓库博客的地址，其格式为”https://仓库名称”</li>
<li><code>theme</code>: 表示博客要使用的主题，默认使用<code>landscape</code>，如果是不想使用默认主题，可以到<a href="https://hexo.io/themes/">hexo官网</a>找自己喜欢的主题。当然如果自己有web相关基础的话也可以自己参照<a href="https://hexo.io/zh-cn/docs/themes">hexo官网自定义主题</a></li>
<li><code>type</code>: 表示博客将来要发布到哪个服务器，这里我们选择发布到<code>git</code></li>
<li><code>repo</code>: 表示发布到<code>git</code>中的哪个仓库里，这里我们是发布到上面创建的仓库中<code>https://github.com/li-huibin/li-huibin.github.io</code></li>
</ul>
<blockquote>
<p>注意这里设置的repo 地址是仓库地址，而不是https://仓库名称。应该是如下图红框中的地址，这里不能设置错了，否则会访问不到博客</p>
<p><img src="/archives/8eb04e19/image-20210727230856137.png" alt="image-20210727230856137"></p>
</blockquote>
<ul>
<li><code>branch</code>: 表示发布到仓库的哪个分支，默认<code>master</code></li>
</ul>
<p>到此为止，个人博客基本搭建完毕。接下来在<code>cmd</code>中编译工程，然后启动本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo generate</span><br><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo server</span><br></pre></td></tr></table></figure>

<p><img src="/archives/8eb04e19/image-20210727231758842.png" alt="image-20210727231758842"></p>
<p>本地服务启动后，hexo默认地址是<a href="http://localhost:4000/">http://localhost:4000</a> 。我们访问这个地址就可以看到本地的博客服务了</p>
<p><img src="/archives/8eb04e19/image-20210727231930894.png" alt="image-20210727231930894"></p>
<p>5、将本地博客发布到git仓库</p>
<p>执行如下指令将我们的本地博客发布到刚刚创建的远程git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Users\A\Desktop\lihuibin\tmp\blog&gt; hexo deploy</span><br></pre></td></tr></table></figure>

<p>然后，就可以直接在浏览器中访问<code>https://li-huibin.github.io</code>来访问博客了。到此为止博客搭建完毕。</p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo静态页面图片不显示问题</title>
    <url>/archives/e4419141/</url>
    <content><![CDATA[<p>hexo静态页面图片不显示一般有几个原因：</p>
<p>1、<code>_config.yml</code>中没有设置<code>post_asset_folder: true</code>；这个设置默认是false</p>
<p>2、没有安装插件 asset-image</p>
<p>如果在运行工程之前上面两个步骤都没有操作过，则首先需要在<code>_config.yml</code>中设置<code>post_asset_folder:true</code> 。然后在cmd中运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>由于国内网络环境，可能需要多下载几次才可以下载成功，要耐心等待。或者有条件的可以翻墙下载。</p>
<p>以上操作完毕之后重新发布工程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>

<p>页面效果如下：</p>
<p><img src="/archives/e4419141/image-20210728134047043.png"></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>html播放.m3u8格式视频</title>
    <url>/archives/e6ea49db/</url>
    <content><![CDATA[<p>播放<code>.m3u8</code>格式视频时需要借助<code>hls.js</code>，为了下载速度快点，我们直接通过国内的cdn访问<a href="https://www.bootcdn.cn/hls.js/">https://www.bootcdn.cn/hls.js/</a></p>
<p><img src="/archives/e6ea49db/image-20210926170928950.png" alt="hls.js"></p>
<p>然后编写如下html内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/hls.js/1.0.8-0.canary.7807/hls.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>.m3u8视频播放效果<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">muted</span> <span class="attr">id</span>=<span class="string">&quot;hlsVedio&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;hlsVedio&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> videoSrc = <span class="string">&#x27;https://hls.videocc.net/cef5baf690/f/cef5baf690579d94244803412596e82f.m3u8&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (Hls.isSupported()) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> hls = <span class="keyword">new</span> Hls();</span></span><br><span class="line"><span class="javascript">      hls.loadSource(videoSrc);</span></span><br><span class="line"><span class="javascript">      hls.attachMedia(video);</span></span><br><span class="line"><span class="javascript">      hls.on(Hls.Events.MANIFEST_PARSED, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(video.paused) &#123;</span></span><br><span class="line"><span class="javascript">          video.play();</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          video.pause();</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">else</span> <span class="keyword">if</span> (video.canPlayType(<span class="string">&#x27;application/vnd.apple.mpegurl&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">      video.src = videoSrc;</span></span><br><span class="line"><span class="javascript">      video.addEventListener(<span class="string">&#x27;loadedmetadata&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(video.paused) &#123;</span></span><br><span class="line"><span class="javascript">          video.play();</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          video.pause();</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行之后的效果如下图</p>
<!DOCTYPE html>
<html>
<head>
</head>
<body>
<script src="https://cdn.bootcdn.net/ajax/libs/hls.js/1.0.8-0.canary.7807/hls.js"></script>
<h3>.m3u8视频播放效果</h3>
<video controls autoplay muted id="hlsVedio"></video>
<script type="text/javascript">
  window.onload = function() {
    var video = document.getElementById('hlsVedio');
    var videoSrc = 'https://hls.videocc.net/cef5baf690/f/cef5baf690579d94244803412596e82f.m3u8';
    if (Hls.isSupported()) {
      var hls = new Hls();
      hls.loadSource(videoSrc);
      hls.attachMedia(video);
      hls.on(Hls.Events.MANIFEST_PARSED, function () {
        if(video.paused) {
          video.play();
        } else {
          video.pause();
        }
      });
    }
    else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = videoSrc;
      video.addEventListener('loadedmetadata', function () {
        if(video.paused) {
          video.play();
        } else {
          video.pause();
        }
      });
    }
  }
</script>
</body>
</html>

]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>java实现定时发布系统消息</title>
    <url>/archives/4aa75d60/</url>
    <content><![CDATA[<h2 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h2><p>管理员通过后台可以定时给系统推送消息；比如 管理员在春节放假前一周需要请假，但是公司需要在春节放假前一天通过消息推送，给所有员工拜年，这时候管理员可以提前写好拜年消息，在后台配置定时发送日期为新年前一天晚上。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="消息容器类"><a href="#消息容器类" class="headerlink" title="消息容器类"></a>消息容器类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: lhb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 消息容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-24 10:16</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNotificationsContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 消息ID-任务ID映射表 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ConcurrentHashMap&lt;Integer,String&gt; msgToTaskMapping = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 任务ID-消息ID映射表 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ConcurrentHashMap&lt;String,Integer&gt; taskToMsgMapping = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 任务缓存 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ConcurrentHashMap&lt;String, SystemNotificationHolder&gt; taskCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cache</span><span class="params">(SystemNotificationHolder release)</span> </span>&#123;</span><br><span class="line">        taskCache.put(release.getTaskId(),release);</span><br><span class="line">        taskToMsgMapping.put(release.getTaskId(),release.getSystemMessageId());</span><br><span class="line">        msgToTaskMapping.put(release.getSystemMessageId(),release.getTaskId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(SystemNotificationHolder release)</span> </span>&#123;</span><br><span class="line">        msgToTaskMapping.remove(release.getSystemMessageId());</span><br><span class="line">        taskCache.remove(release.getTaskId());</span><br><span class="line">        taskToMsgMapping.remove(release.getTaskId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(String taskId)</span> </span>&#123;</span><br><span class="line">        Integer msgId = taskToMsgMapping.getOrDefault(taskId,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (msgId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            msgToTaskMapping.remove(msgId);</span><br><span class="line">            taskCache.remove(taskId);</span><br><span class="line">            taskToMsgMapping.remove(taskId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(Integer msgId)</span> </span>&#123;</span><br><span class="line">        String taskIdStr = msgToTaskMapping.get(msgId);</span><br><span class="line">        <span class="keyword">return</span> taskCache.search(<span class="number">1</span>,(taskId,systemMessageRelease)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (taskId.equals(taskIdStr)) &#123;</span><br><span class="line">                systemMessageRelease.taskCanceled();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">notificationCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> taskCache.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消息发布类"><a href="#消息发布类" class="headerlink" title="消息发布类"></a>消息发布类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.extra.spring.SpringUtil;</span><br><span class="line"><span class="keyword">import</span> com.lhb.domain.entity.SystemNotifications;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: lhb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 系統消息发布</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-24 09:53</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemNotificationHolder</span> <span class="keyword">extends</span> <span class="title">AbstractNotificationsContainer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 任务取消状态 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> AtomicBoolean canceled = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">/** 任务ID */</span></span><br><span class="line">    <span class="keyword">private</span> String taskId;</span><br><span class="line">    <span class="comment">/** 系统消息ID */</span></span><br><span class="line">    <span class="keyword">private</span> Integer systemMessageId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SystemNotificationHolder</span><span class="params">(String taskId, Integer systemMessageId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskId = taskId;</span><br><span class="line">        <span class="keyword">this</span>.systemMessageId = systemMessageId;</span><br><span class="line">        cache(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">taskCanceled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        canceled.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTaskId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.taskId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSystemMessageId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.systemMessageId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;定时发布公告&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canceled.get()) &#123;</span><br><span class="line">                SystemNotificationsServiceImpl systemMessageService = SpringUtil.getBean(SystemNotificationsServiceImpl.class);</span><br><span class="line">                SystemNotifications systemMessage = <span class="keyword">new</span> SystemNotifications();</span><br><span class="line">                systemMessage.setId(systemMessageId);</span><br><span class="line">                systemMessage.setStatus(<span class="number">2</span>);</span><br><span class="line">                systemMessageService.updateById(systemMessage);</span><br><span class="line">                log.info(<span class="string">&quot;消息发布成功 &#123;&#125;&quot;</span>, systemMessage);</span><br><span class="line">            &#125;</span><br><span class="line">            clean(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="系统消息管理服务类"><a href="#系统消息管理服务类" class="headerlink" title="系统消息管理服务类"></a>系统消息管理服务类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.date.DateUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.lang.UUID;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> com.lhb.basic.constant.ContextHelper;</span><br><span class="line"><span class="keyword">import</span> com.lhb.basic.exception.BizException;</span><br><span class="line"><span class="keyword">import</span> com.lhb.domain.entity.SystemNotifications;</span><br><span class="line"><span class="keyword">import</span> com.lhb.model.SystemNotificationModel;</span><br><span class="line"><span class="keyword">import</span> com.lhb.domain.vo.SystemMessageReleasedVO;</span><br><span class="line"><span class="keyword">import</span> com.lhb.domain.vo.SystemMessageVO;</span><br><span class="line"><span class="keyword">import</span> com.lhb.mapper.SystemNotificationsMapper;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.ISystemNotificationsService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: lhb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 系统消息类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-18 09:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemNotificationsServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">SystemNotificationsMapper</span>, <span class="title">SystemNotifications</span>&gt; <span class="keyword">implements</span> <span class="title">ISystemNotificationsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;scheduleExecutorService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledThreadPoolExecutor scheduleExecutorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存系统推送消息(PC端系统设置-系统通知)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = BizException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveNotification</span><span class="params">(SystemNotificationModel model)</span> </span>&#123;</span><br><span class="line">        SystemNotifications entity = getEntity(model);</span><br><span class="line">        <span class="keyword">int</span> insert = baseMapper.insert(entity);</span><br><span class="line">        <span class="keyword">if</span> (insert &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SystemNotificationHolder systemMessageRelease = <span class="keyword">new</span> SystemNotificationHolder(UUID.nameUUIDFromBytes(entity.toString().getBytes()).toString(), entity.getId());</span><br><span class="line">            scheduleExecutorService.schedule(</span><br><span class="line">                    systemMessageRelease,</span><br><span class="line">                    DateUtil.betweenMs(DateUtil.date(), entity.getTime()),</span><br><span class="line">                    TimeUnit.MILLISECONDS);</span><br><span class="line">            log.info(<span class="string">&quot;系统定时公告创建成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>这里我们用了线程池。线程池配置代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.basic.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: lhb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-24 12:46</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** cpu核数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT =Runtime.getRuntime().availableProcessors();</span><br><span class="line">    <span class="comment">/** 核心线程数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT;</span><br><span class="line">    <span class="comment">/** 最大线程数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 非核心线程存活时间s */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** 线程前缀 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SCHEDULE_THREAD_NAME_PREFIX = <span class="string">&quot;lhb-msg-&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String THREAD_NAME_PREFIX = <span class="string">&quot;lhb-thread-&quot;</span>;</span><br><span class="line">    <span class="comment">/** 缓存队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;scheduleExecutorService&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScheduledThreadPoolExecutor <span class="title">scheduleExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(CORE_POOL_SIZE, customThreadFactory(SCHEDULE_THREAD_NAME_PREFIX));</span><br><span class="line">        scheduledThreadPoolExecutor.setKeepAliveTime(KEEP_ALIVE_TIME,TimeUnit.SECONDS);</span><br><span class="line">        scheduledThreadPoolExecutor.setMaximumPoolSize(MAXIMUM_POOL_SIZE);</span><br><span class="line">        scheduledThreadPoolExecutor.setRejectedExecutionHandler(customRejectedHandler());</span><br><span class="line">        scheduledThreadPoolExecutor.setRemoveOnCancelPolicy(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> scheduledThreadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;threadExecutor&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">threadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE,</span><br><span class="line">                MAXIMUM_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                workQueue,</span><br><span class="line">                customThreadFactory(THREAD_NAME_PREFIX),</span><br><span class="line">                (r, executor) -&gt; &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;线程池已满，任务加入到缓冲队列&quot;</span>);</span><br><span class="line">                    workQueue.offer(r);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ThreadFactory <span class="title">customThreadFactory</span><span class="params">(String threadNamePrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r -&gt; &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setName(threadNamePrefix + t.getId());</span><br><span class="line">            <span class="keyword">if</span> (!t.isDaemon()) &#123;</span><br><span class="line">                t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY) &#123;</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            t.setUncaughtExceptionHandler((t1, e) -&gt; log.warn(<span class="string">&quot;创建线程异常&#123;&#125;&quot;</span>,e));</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RejectedExecutionHandler <span class="title">customRejectedHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (r, executor) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executor.isShutdown()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;任务被拒绝，由主线程开始执行该任务&quot;</span>);</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.controller.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> com.lhb.basic.annation.CurrentUser;</span><br><span class="line"><span class="keyword">import</span> com.lhb.basic.annation.IgnoreLogin;</span><br><span class="line"><span class="keyword">import</span> com.lhb.basic.api.R;</span><br><span class="line"><span class="keyword">import</span> com.lhb.domain.model.SystemNotificationModel;</span><br><span class="line"><span class="keyword">import</span> com.lhb.domain.vo.SystemMessageVO;</span><br><span class="line"><span class="keyword">import</span> com.lhb.service.impl.SystemNotificationsServiceImpl;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParams;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: lhb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 系统通知控制层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-25 10:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;系统通知&quot;)</span></span><br><span class="line"><span class="meta">@IgnoreLogin</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/settings/notifications&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemNotificationsController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SystemNotificationsServiceImpl systemNotificationsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存系统公告</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;保存系统公告&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@CurrentUser</span>  <span class="comment">// 自定义注解，获取当前登录用户信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">saveNotification</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> SystemNotificationModel model)</span> </span>&#123;</span><br><span class="line">        systemNotificationsService.saveNotification(model);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试页面代码"><a href="#测试页面代码" class="headerlink" title="测试页面代码"></a>测试页面代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/semantic-ui/2.4.1/semantic.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/semantic-ui/2.4.1/semantic.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui center segment &quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 50%; align-content: center; left: 25%;top: 20%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;ui small form segment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">&quot;ui dividing header&quot;</span>&gt;</span>系统公告<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>标  题<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one field&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;公告标题&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SSSSS&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>内  容<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one field&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;公告内容&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>发布日期<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one field&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;field&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">name</span>=<span class="string">&quot;time&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;2021-10-10 12:20:20&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui primary button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">title</span>:<span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>:<span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">submit</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        data.title = $(<span class="string">&quot;#title&quot;</span>).val();</span></span><br><span class="line"><span class="javascript">        data.message = $(<span class="string">&quot;#message&quot;</span>).val();</span></span><br><span class="line"><span class="javascript">        data.time = $(<span class="string">&quot;#time&quot;</span>).val().replace(<span class="string">&quot;T&quot;</span>,<span class="string">&quot; &quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/settings/notifications/all&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>:data,</span></span><br><span class="line"><span class="javascript">            <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">data</span>: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>,data);</span></span><br><span class="line"><span class="javascript">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>,data);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/4aa75d60/image-20211130123221213.png" alt="测试页面"></p>
]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>maven打包main可运行jar包</title>
    <url>/archives/15bfa942/</url>
    <content><![CDATA[<p>在pom.xml文件中加入以下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.chat.client.ServerStarter<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span>  <span class="comment">&lt;!--修改这里面为main的全限定类名--&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/15bfa942/image-20211011142322612.png" alt="打包"></p>
<p>运行时cd到jar包所在位置执行如下命令，即可运行:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -jar Server-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>解决方案</category>
      </categories>
      <tags>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>netty实现简单聊天室功能</title>
    <url>/archives/8839ad77/</url>
    <content><![CDATA[<p>首先看一下项目目录结构</p>
<p><img src="/archives/8839ad77/image-20211011125748872.png" alt="聊天室目录结构"></p>
<p>从目录结构看，整个项目比较简单，总体由一个服务端启动器、客户端启动器、以及两个Handler组成，下面来逐个看一下代码。</p>
<h2 id="ServerStarter-聊天室服务端启动代码"><a href="#ServerStarter-聊天室服务端启动代码" class="headerlink" title="ServerStarter 聊天室服务端启动代码"></a>ServerStarter 聊天室服务端启动代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.chatRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhb.chatRoom.handler.NettyServerHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GenericFutureListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Class</span> ServerStarter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 服务启动类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lihuibin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/10 17:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 更新记录:</span></span><br><span class="line"><span class="comment"> * 更新时间        更新人        更新位置        更新内容</span></span><br><span class="line"><span class="comment"> * 2021/10/10       lihuibin       新建           新建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStarter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组bossGroup和workerGroup，含有的子线程NioEventLoop的个数默认为cpu核数的两倍</span></span><br><span class="line">        <span class="comment">// bossGroup只是处理连接请求，真正的和客户端业务处理，会交给workerGroup完成</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务器端的启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 使用链式编程来配置参数</span></span><br><span class="line">            <span class="comment">// 设置两个线程组</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 初始化服务器连接队列大小,服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接</span></span><br><span class="line">                    <span class="comment">// 多个客户端同时来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    <span class="comment">//让客户端保持长期活动状态</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// 创建通道初始化对象，设置初始化参数</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 对workerGroup的SocketChannel设置处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty server start....&quot;</span>);</span><br><span class="line">            <span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况</span></span><br><span class="line">            <span class="comment">// 启动服务其（并绑定端口），bind是异步操作，sync方法是等待异步操作执行完毕</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 给cf注册监听器，监听器我们关心的事件</span></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (channelFuture.isSuccess()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口9000成功&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;监听端口9000失败&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 对通道关闭进行监听，closeFuture是异步操作，监听通道关闭</span></span><br><span class="line">            <span class="comment">// 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">            cf.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future.isCancelled())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器正在关闭..&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(future.isCancellable())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务器已经关闭..OK&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NettyServerHandler-服务端处理器"><a href="#NettyServerHandler-服务端处理器" class="headerlink" title="NettyServerHandler 服务端处理器"></a>NettyServerHandler 服务端处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.chatRoom.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Class</span> NettyServerHandler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 自定义Handler需要继承netty规定好的某个HandlerAdapter（规范）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lihuibin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/10 17:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 更新记录:</span></span><br><span class="line"><span class="comment"> * 更新时间        更新人        更新位置        更新内容</span></span><br><span class="line"><span class="comment"> * 2021/10/10       lihuibin       新建           新建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GlobalEventExcutor.INSTANCE是全局的时间执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象，含有通道channel，管道pipline</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        if (!channelGroup.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//            for (Channel channel : channelGroup) &#123;</span></span><br><span class="line"><span class="comment">//                if (channel != ctx.channel()) &#123;</span></span><br><span class="line"><span class="comment">//                    channel.writeAndFlush(&quot;【&quot;+ ctx.channel().remoteAddress() +&quot;】: &quot; + msg + &quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    channel.writeAndFlush(&quot;【发送消息】: &quot; + msg + &quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channelHandlerContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!channelGroup.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channelGroup) &#123;</span><br><span class="line">                <span class="keyword">if</span> (channel != channelHandlerContext.channel()) &#123;</span><br><span class="line">                    channel.writeAndFlush(<span class="string">&quot;【&quot;</span>+ channelHandlerContext.channel().remoteAddress() +<span class="string">&quot;】: &quot;</span> + msg + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    channel.writeAndFlush(<span class="string">&quot;【发送消息】: &quot;</span> + msg + <span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">&quot; 上线了&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!channelGroup.isEmpty()) &#123;</span><br><span class="line">            channelGroup.writeAndFlush(<span class="string">&quot;【&quot;</span>+ ctx.channel().remoteAddress() +<span class="string">&quot;】 &quot;</span> + sdf.format(<span class="keyword">new</span> Date(System.currentTimeMillis())) + <span class="string">&quot; 上线了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channelGroup.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!channelGroup.isEmpty()) &#123;</span><br><span class="line">            channelGroup.remove(ctx.channel());</span><br><span class="line">            channelGroup.writeAndFlush(ctx.channel().remoteAddress() + <span class="string">&quot; 下线了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ClientStarter客户端启动器代码"><a href="#ClientStarter客户端启动器代码" class="headerlink" title="ClientStarter客户端启动器代码"></a>ClientStarter客户端启动器代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.chatRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhb.chatRoom.handler.NettyClientHandler;</span><br><span class="line"><span class="keyword">import</span> com.lhb.chatRoom.test.ClientMessageHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GenericFutureListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Class</span> ClientStarter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 客户端启动类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lihuibin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/10 18:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 更新记录:</span></span><br><span class="line"><span class="comment"> * 更新时间        更新人        更新位置        更新内容</span></span><br><span class="line"><span class="comment"> * 2021/10/10       lihuibin       新建           新建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientStarter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            <span class="comment">// 注意客户端使用的不是ServerBootstrap 而是Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">// 设置相关参数</span></span><br><span class="line">            <span class="comment">// 设置线程组</span></span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    <span class="comment">// 使用NioSocketChannel作为客户端的通道实现</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//加入处理器</span></span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;netty client start...&quot;</span>);</span><br><span class="line">            <span class="comment">// 启动客户端去链接服务器端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            channelFuture.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(future.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端启动中...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(future.isDone())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端启动成功...OK！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;*******************************&quot;</span>);</span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            <span class="comment">//获取channel</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">                String str = scanner.nextLine();</span><br><span class="line">                channel.writeAndFlush(str);</span><br><span class="line">            &#125;</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NettyClientHandler客户端处理器"><a href="#NettyClientHandler客户端处理器" class="headerlink" title="NettyClientHandler客户端处理器"></a>NettyClientHandler客户端处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.chatRoom.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Class</span> NettyClientHandler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 客户端处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lihuibin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/10/10 18:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 更新记录:</span></span><br><span class="line"><span class="comment"> * 更新时间        更新人        更新位置        更新内容</span></span><br><span class="line"><span class="comment"> * 2021/10/10       lihuibin       新建           新建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接服务器完成就会触发该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;channelActive&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时就会触发，即服务端发送数据给客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(msg);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时就会触发，即服务端发送数据给客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channelHandlerContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="启动程序验证"><a href="#启动程序验证" class="headerlink" title="启动程序验证"></a>启动程序验证</h2><p>启动一个ServerStarter服务端和三个ClientStarter客户端</p>
<p><img src="/archives/8839ad77/image-20211011130807885.png" alt="ServerStarter服务端"></p>
<p><img src="/archives/8839ad77/image-20211011130831480.png" alt="ClientStarter客户端1"></p>
<p><img src="/archives/8839ad77/image-20211011130855559.png" alt="ClientStarter客户端2"></p>
<p><img src="/archives/8839ad77/image-20211011130916760.png" alt="ClientStarter客户端3"></p>
<p><img src="/archives/8839ad77/image-20211011131049097.png" alt="客户端下线通知"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>invokeBeanDefinitionRegistryPostProcessors方法解析</title>
    <url>/archives/8d05e930/</url>
    <content><![CDATA[<p>在上一篇<a href="/archives/e74be873">《Spring-IOC原理之invokeBeanFactoryPostProcessor详解》</a>中我们提到了一个方法<code>invokeBeanDefinitionRegistryPostProcessors()</code>。也说了这个方法最终会调用<code>ConfigurationClassPostProcessor</code>类中的<code>postProcessBeanDefinitionRegistry</code>方法。并且在这个方法中会解析<code>@Import</code>、<code>@Component</code>等注解和创建<code>CGLIB</code>动态代理。那么这一篇我们来详细看一下这个调用链中的方法。</p>
<p>先找到<code>refresh()</code>方法中的<code>invokeBeanFactoryPostProcessors()</code>，然后找到方法中的<code>invokeBeanDefinitionRegistryPostProcessors</code>方法。</p>
<p><img src="/archives/8d05e930/image-20210828140340723.png" alt="PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors"></p>
<p>然后<code>Ctrl+鼠标左键</code>进入到该方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">		<span class="comment">/** 这里调用ConfigutationClassPostProcessor处理beanDefinitionMap中的bean定义 */</span></span><br><span class="line">		postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环遍历了传进来的<code>postProcessors</code>，不过<code>postProcessors</code>中只有一个类是<code>ConfigurationClassPostProcessor</code>。然后调用<code>postProcessBeanDefinitionRegistry</code>。</p>
<p><img src="/archives/8d05e930/image-20210828141408341.png" alt="Debug-invokeBeanDefinitionRegistryPostProcessors"></p>
<blockquote>
<p>这里还有一个点，就是<code>postProcessBeanDefinitionRegistry</code>方法，这个方法是<code>BeanDefinitionRegistryPostProcessor</code>接口中的方法，所以要想看方法内的实现逻辑只能找实现类中该方法的实现逻辑；通过上面的调试图片我们可以知道，<code>postProcessor</code>是<code>ConfigurationClassPostProcessor</code>类型，而<code>ConfigurationClassPostProcessor</code>切好也实现了<code>BeanDefinitionRegistryPostProcessors</code>接口，当然也实现了这个接口中的方法。所以这里我们只要去<code>ConfigurationClassPostProcessor</code>类中去找方法即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 这里会解析配置类的一些注解，例如<span class="doctag">@Configutation</span>、<span class="doctag">@Component</span>、<span class="doctag">@Import</span>等配置注解 */</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>postProcessBeanDefinitionRegistry</code>方法中，我们直接看到最后一行，调用了<code>processConfigBeanDefinitions(registry)</code>，这个方法主要是解析<code>@Component</code>、<code>@Import</code>等配置注解。<a href="/archives/79103379">想要了解<code>processConfigBeanDefinitioins</code>中具体流程可以查看这一篇。</a></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>pyecharts中显示浙江省所有县市区地图</title>
    <url>/archives/1610d362/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇<a href="/archives/5c618354/">《pyecharts中自定义geojson来创建地图》</a>介绍了怎么通过自定义geojson来生成我们自定义的地图，这一篇我们来看看怎么通过自定义geojson生成全省各县市区的地图。</p>
<blockquote>
<p>PS： 如果使用pyecharts自带的库全省的地图最小显示到市级别，无法显示县区；如果遇到的特殊需求，显然使用默认pyecharts库的结果是无法满足的。这就需要我们重写pyecharts的库文件来实现我们的需求。</p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、首先需要创建省以及各市的geojson数据文件，我们这里以浙江省以为例，首先创建zhejiang_geojson.json文件来存放浙江省中所有的市信息，然后在依次创建浙江省杭州市下的区县信息hangzhou_geojson.json,同样的操作创建其他市的geojson信息。这里省略。如果不知道怎么创建geojson数据，可以参考上一篇<a href="/archives/5c618354/">《pyecharts中自定义geojson来创建地图》</a></p>
<p><img src="/archives/1610d362/image-20220119141823976.png" alt="创建全省、市 geojson"></p>
<p>接着创建一份zhejiang_cities_districts_geojson.json，将全省geojson(zhejiang_geojson.json)以及各市geojson(hangzhou_geojson.json、huzhou_geojson.json……)拷贝到zhejiang_cities_districts_geojson.json文件中，需要注意json格式要正确</p>
<p>2、编写python代码创建自定义地图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span>(<span class="params">rge, start: <span class="built_in">int</span> = <span class="number">20</span>, end: <span class="built_in">int</span> = <span class="number">150</span></span>) -&gt; <span class="built_in">list</span>:</span></span><br><span class="line">    ar = [random.randint(start, end) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rge)]</span><br><span class="line">    <span class="built_in">print</span>(ar)</span><br><span class="line">    <span class="keyword">return</span> ar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hangzhou = [<span class="string">&quot;滨江区&quot;</span>, <span class="string">&quot;淳安县&quot;</span>, <span class="string">&quot;富阳区&quot;</span>, <span class="string">&quot;拱墅区&quot;</span>, <span class="string">&quot;建德市&quot;</span>, <span class="string">&quot;临安区&quot;</span>, <span class="string">&quot;临平区&quot;</span>, <span class="string">&quot;钱塘区&quot;</span>, <span class="string">&quot;上城区&quot;</span>, <span class="string">&quot;桐庐县&quot;</span>, <span class="string">&quot;西湖区&quot;</span>, <span class="string">&quot;萧山区&quot;</span>, <span class="string">&quot;临平区&quot;</span>, <span class="string">&quot;余杭区&quot;</span>]</span><br><span class="line">ningbo = [<span class="string">&quot;海曙区&quot;</span>, <span class="string">&quot;江北区&quot;</span>, <span class="string">&quot;北仑区&quot;</span>, <span class="string">&quot;镇海区&quot;</span>, <span class="string">&quot;鄞州区&quot;</span>, <span class="string">&quot;奉化区&quot;</span>, <span class="string">&quot;象山县&quot;</span>, <span class="string">&quot;宁海县&quot;</span>, <span class="string">&quot;余姚市&quot;</span>, <span class="string">&quot;慈溪市&quot;</span>]</span><br><span class="line">wenzhou = [<span class="string">&quot;鹿城区&quot;</span>, <span class="string">&quot;龙湾区&quot;</span>, <span class="string">&quot;瓯海区&quot;</span>, <span class="string">&quot;洞头区&quot;</span>, <span class="string">&quot;永嘉县&quot;</span>, <span class="string">&quot;平阳县&quot;</span>, <span class="string">&quot;苍南县&quot;</span>, <span class="string">&quot;文成县&quot;</span>, <span class="string">&quot;泰顺县&quot;</span>, <span class="string">&quot;瑞安市&quot;</span>, <span class="string">&quot;乐清市&quot;</span>, <span class="string">&quot;龙港市&quot;</span>]</span><br><span class="line">jiaxing = [<span class="string">&quot;南湖区&quot;</span>, <span class="string">&quot;秀洲区&quot;</span>, <span class="string">&quot;嘉善县&quot;</span>, <span class="string">&quot;海盐县&quot;</span>, <span class="string">&quot;海宁市&quot;</span>, <span class="string">&quot;平湖市&quot;</span>, <span class="string">&quot;桐乡市&quot;</span>]</span><br><span class="line">huzhou = [<span class="string">&quot;吴兴区&quot;</span>, <span class="string">&quot;南浔区&quot;</span>, <span class="string">&quot;德清县&quot;</span>, <span class="string">&quot;长兴县&quot;</span>, <span class="string">&quot;安吉县&quot;</span>]</span><br><span class="line">shaoxing = [<span class="string">&quot;越城区&quot;</span>, <span class="string">&quot;柯桥区&quot;</span>, <span class="string">&quot;上虞区&quot;</span>, <span class="string">&quot;新昌县&quot;</span>, <span class="string">&quot;诸暨市&quot;</span>, <span class="string">&quot;嵊州市&quot;</span>]</span><br><span class="line">jinhua = [<span class="string">&quot;婺城区&quot;</span>, <span class="string">&quot;武义县&quot;</span>, <span class="string">&quot;浦江县&quot;</span>, <span class="string">&quot;磐安县&quot;</span>, <span class="string">&quot;兰溪市&quot;</span>, <span class="string">&quot;义乌市&quot;</span>, <span class="string">&quot;东阳市&quot;</span>, <span class="string">&quot;永康市&quot;</span>, <span class="string">&quot;金东区&quot;</span>]</span><br><span class="line">quzhou = [<span class="string">&quot;柯城区&quot;</span>, <span class="string">&quot;衢江区&quot;</span>, <span class="string">&quot;常山县&quot;</span>, <span class="string">&quot;开化县&quot;</span>, <span class="string">&quot;龙游县&quot;</span>, <span class="string">&quot;江山市&quot;</span>]</span><br><span class="line">zhoushan = [<span class="string">&quot;定海区&quot;</span>, <span class="string">&quot;普陀区&quot;</span>, <span class="string">&quot;岱山县&quot;</span>, <span class="string">&quot;嵊泗县&quot;</span>]</span><br><span class="line">taizhou = [<span class="string">&quot;椒江区&quot;</span>, <span class="string">&quot;黄岩区&quot;</span>, <span class="string">&quot;路桥区&quot;</span>, <span class="string">&quot;三门县&quot;</span>, <span class="string">&quot;天台县&quot;</span>, <span class="string">&quot;仙居县&quot;</span>, <span class="string">&quot;温岭市&quot;</span>, <span class="string">&quot;临海市&quot;</span>, <span class="string">&quot;玉环市&quot;</span>]</span><br><span class="line">lishui = [<span class="string">&quot;莲都区&quot;</span>, <span class="string">&quot;青田县&quot;</span>, <span class="string">&quot;缙云县&quot;</span>, <span class="string">&quot;遂昌县&quot;</span>, <span class="string">&quot;松阳县&quot;</span>, <span class="string">&quot;云和县&quot;</span>, <span class="string">&quot;庆元县&quot;</span>, <span class="string">&quot;景宁畲族自治县&quot;</span>, <span class="string">&quot;龙泉市&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浙江省-市 映射表</span></span><br><span class="line">zhejiang_dic = &#123;</span><br><span class="line">    <span class="string">&#x27;hangzhou&#x27;</span>: <span class="string">&quot;杭州市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;ningbo&#x27;</span>: <span class="string">&quot;宁波市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;wenzhou&#x27;</span>: <span class="string">&quot;温州市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;jiaxing&#x27;</span>: <span class="string">&quot;嘉兴市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;huzhou&#x27;</span>: <span class="string">&quot;湖州市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;shaoxing&#x27;</span>: <span class="string">&quot;绍兴市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;jinhua&#x27;</span>: <span class="string">&quot;金华市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;quzhou&#x27;</span>: <span class="string">&quot;衢州市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;zhoushan&#x27;</span>: <span class="string">&quot;舟山市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;taizhou&#x27;</span>: <span class="string">&quot;台州市&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;lishui&#x27;</span>: <span class="string">&quot;丽水市&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 市-区县 映射表</span></span><br><span class="line">zhejiang_city_dic = &#123;</span><br><span class="line">    <span class="string">&#x27;hangzhou&#x27;</span>: hangzhou,</span><br><span class="line">    <span class="string">&#x27;ningbo&#x27;</span>: ningbo,</span><br><span class="line">    <span class="string">&#x27;wenzhou&#x27;</span>: wenzhou,</span><br><span class="line">    <span class="string">&#x27;jiaxing&#x27;</span>: jiaxing,</span><br><span class="line">    <span class="string">&#x27;huzhou&#x27;</span>: huzhou,</span><br><span class="line">    <span class="string">&#x27;shaoxing&#x27;</span>: shaoxing,</span><br><span class="line">    <span class="string">&#x27;jinhua&#x27;</span>: jinhua,</span><br><span class="line">    <span class="string">&#x27;quzhou&#x27;</span>: quzhou,</span><br><span class="line">    <span class="string">&#x27;zhoushan&#x27;</span>: zhoushan,</span><br><span class="line">    <span class="string">&#x27;taizhou&#x27;</span>: taizhou,</span><br><span class="line">    <span class="string">&#x27;lishui&#x27;</span>: lishui</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区县-数据映射 导入数据时全部将数据放在这个变量中</span></span><br><span class="line">dic_data = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在导出浙江全省城市地图...&quot;</span>)</span><br><span class="line">    html_path = <span class="string">&quot;./html/map_zhejiang_all.html&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(html_path):</span><br><span class="line">        os.remove(html_path)</span><br><span class="line">    <span class="comment"># 统计全省区县数量,并合并全省区县</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./geojson/zhejiang_cities_districts_geojson.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        stream = file.read()</span><br><span class="line"></span><br><span class="line">    cities_dic = []</span><br><span class="line">    cities_dic_data = []</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> city <span class="keyword">in</span> zhejiang_city_dic.values():</span><br><span class="line">        <span class="keyword">for</span> dic <span class="keyword">in</span> city.values():</span><br><span class="line">            cities_dic.append(dic)</span><br><span class="line">            cities_dic_data.append(random.randint(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line">        cities_dic.append(zhejiang_city_dic.keys()[idx])</span><br><span class="line">        cities_dic_data.append(random.randint(<span class="number">1</span>, <span class="number">100</span>))</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    map0 = Map(init_opts=opts.InitOpts(width=<span class="string">&#x27;900px&#x27;</span>, height=<span class="string">&#x27;800px&#x27;</span>)) \</span><br><span class="line">        .add_js_funcs(<span class="string">&quot;echarts.registerMap(&#x27;浙江省&#x27;,&#123;&#125;);&quot;</span>.<span class="built_in">format</span>(stream)) \</span><br><span class="line">        .add(<span class="string">&quot;商家A&quot;</span>, [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>(cities_dic, cities_dic_data)],</span><br><span class="line">             <span class="string">&quot;浙江&quot;</span>, label_opts=opts.LabelOpts(font_size=<span class="number">10</span>)) \</span><br><span class="line">        .set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(title=<span class="string">&quot;Map-浙江省地图&quot;</span>), visualmap_opts=opts.VisualMapOpts(max_=<span class="number">100</span>, is_piecewise=<span class="literal">True</span>)</span><br><span class="line">    )</span><br><span class="line">    map0.render(html_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;浙江全省城市地图导出完成，文件路径:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(html_path))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、运行</p>
<p>运行之后会在html文件夹下生成一个map_zhejiang_all.html文件，打开文件看结果</p>
<p><img src="/archives/1610d362/image-20220119144203286.png" alt="全省各市县区地图"></p>
<h3 id="完整工程代码"><a href="#完整工程代码" class="headerlink" title="完整工程代码"></a>完整工程代码</h3><p>工程代码在<a href="https://github.com/li-huibin/pyecharts">github</a> 需要的可以自提。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyecharts</tag>
      </tags>
  </entry>
  <entry>
    <title>pyecharts实现全省各市区县数据动态显示地图</title>
    <url>/archives/45e4dd0d/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇<a href="/archives/1610d362/">《pyecharts中显示浙江省所有县市区地图》</a>实现了怎么通过自定义geojson来实现全省各市区县地图显示，这一篇我们就来实现怎么用我们创建的全省市区县地图将各县区数据指标动态的渲染上来。</p>
<blockquote>
<p><strong>注意： 一下两种情况需要从【准备 】阶段开始按步骤阅读</strong></p>
<ol>
<li>使用自定义geojson来创建地图</li>
<li>pyecharts原生库中的地理信息、城市行政划分和目前实际划分不一致，需要我们重写assets/maps/中的js文件</li>
</ol>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1、<a href="https://github.com/pyecharts/pyecharts-assets">下载pyecharts-assets</a> 源码包，并解压</p>
<p><img src="/archives/45e4dd0d/image-20220119150948445.png" alt="pyecharts-assets解压"></p>
<p>2、进入assets/maps/ 找到zhe4_jiang1_hang2_zhou1.js文件，接下来修改这个文件中的geojson信息。</p>
<blockquote>
<p>这一步不是必须要做的。我这里做是因为杭州市重新划分了行政区域后，pyecharts官方没有及时更新zhe4_jiang1_hang2_zhou1.js中的geojson信息，所以我这里要做修改。如果其他地区有更新，同理只要修改对应地区的js中geojson信息即可</p>
</blockquote>
<p>打开zhe4_jiang1_hang2_zhou1.js文件，使用最新的hangzhou_geojson.json (<a href="/archives/5c618354/">怎么得到最新的hangzhou_geojson.json，可以参考以前文章《pyecharts中自定义geojson创建地图》</a>) 替换掉下图红色括号中的内容，保存文件。</p>
<p><img src="/archives/45e4dd0d/image-20220119152954257.png" alt="替换掉红色括号中的内容"></p>
<p>3、使用命令行工具进入pyecharts-assets,并启动服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> pyecharts-assets</span><br><span class="line">$ python -m http.server</span><br></pre></td></tr></table></figure>

<p>4、在代码顶部设置host</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只需要在顶部声明 CurrentConfig.ONLINE_HOST 即可</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> CurrentConfig</span><br><span class="line"></span><br><span class="line">CurrentConfig.ONLINE_HOST = <span class="string">&quot;http://127.0.0.1:8000/assets/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来所有图形的静态资源文件都会来自刚启动的服务器</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="built_in">map</span> = Map()</span><br></pre></td></tr></table></figure>

<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map, Timeline, Geo</span><br><span class="line"><span class="comment"># 如果不涉及到更改assets/maps/文件夹下的js文件，则一下两行需要删除</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> CurrentConfig</span><br><span class="line">CurrentConfig.ONLINE_HOST = <span class="string">&quot;http://127.0.0.1:8000/assets/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成全省动态图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zhejiang_sync_data</span>(<span class="params">path</span>):</span></span><br><span class="line">	width = <span class="string">&#x27;1000px&#x27;</span></span><br><span class="line">	height = <span class="string">&#x27;900px&#x27;</span></span><br><span class="line">	tl = Timeline(init_opts=opts.InitOpts(width=width, height=height)) \</span><br><span class="line">		.add_schema(orient=<span class="string">&#x27;horizontal&#x27;</span>, is_auto_play=<span class="literal">True</span>, is_timeline_show=<span class="literal">True</span>)</span><br><span class="line">	wb = xlrd.open_workbook(path)</span><br><span class="line">	<span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(wb.sheets())):</span><br><span class="line">		<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./geojson/zhejiang_cities_districts_geojson.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">			stream = file.read()</span><br><span class="line">		keys = []</span><br><span class="line">		values = []</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(wb.sheet_by_index(idx).nrows):</span><br><span class="line">			<span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">				keys.append(wb.sheet_by_index(idx).cell(i, <span class="number">1</span>).value)</span><br><span class="line">				values.append(wb.sheet_by_index(idx).cell(i, <span class="number">6</span>).value)</span><br><span class="line"></span><br><span class="line">		map0 = Map(init_opts=opts.InitOpts(width=width, height=height)) \</span><br><span class="line">			.add_js_funcs(<span class="string">&quot;echarts.registerMap(&#x27;浙江省&#x27;,&#123;&#125;);&quot;</span>.<span class="built_in">format</span>(stream)) \</span><br><span class="line">			.add(<span class="string">&quot;商家A&quot;</span>, [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values)], <span class="string">&quot;浙江&quot;</span>, min_scale_limit=<span class="number">1</span>) \</span><br><span class="line">			.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;Map-浙江省地图&quot;</span>),</span><br><span class="line">							 visualmap_opts=opts.VisualMapOpts(max_=<span class="number">100</span>, is_piecewise=<span class="literal">True</span>)</span><br><span class="line">							 )</span><br><span class="line">		tl.add(map0, <span class="string">&quot;&#123;&#125;年&quot;</span>.<span class="built_in">format</span>(idx))</span><br><span class="line">	tl.render(<span class="string">&quot;./html/timeline_map.html&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  zhejiang_sync_data(<span class="string">&quot;data.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 如果不涉及到更改assets/maps/文件夹下的js文件，则一下两行需要删除</p>
<p>from pyecharts.globals import CurrentConfig<br>CurrentConfig.ONLINE_HOST = “<a href="http://127.0.0.1:8000/assets/&quot;">http://127.0.0.1:8000/assets/&quot;</a></p>
</blockquote>
<h2 id="运行代码结果"><a href="#运行代码结果" class="headerlink" title="运行代码结果"></a>运行代码结果</h2><p><img src="/archives/45e4dd0d/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.gif" alt="代码运行结果"></p>
<h3 id="完整工程代码"><a href="#完整工程代码" class="headerlink" title="完整工程代码"></a>完整工程代码</h3><p>工程代码在<a href="https://github.com/li-huibin/pyecharts">github</a> 需要的可以自提。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyecharts</tag>
      </tags>
  </entry>
  <entry>
    <title>redis主从架构搭建</title>
    <url>/archives/ba77e58/</url>
    <content><![CDATA[<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><blockquote>
<p>搭建采用虚拟机来搭建，所有的操作都是在虚拟机中操作的</p>
</blockquote>
<h3 id="1、CentOs镜像下载"><a href="#1、CentOs镜像下载" class="headerlink" title="1、CentOs镜像下载"></a>1、<a href="https://www.centos.org/download/"><code>CentOs</code>镜像下载</a></h3><p><img src="/archives/ba77e58/image-20210914113157200.png" alt="image-20210914113157200"></p>
<p><img src="/archives/ba77e58/image-20210914113220179.png" alt="image-20210914113220179"></p>
<p>这里选择一个距离自己比较近的镜像源，这样下载速度快点。</p>
<p><img src="/archives/ba77e58/image-20210914113304957.png" alt="image-20210914113304957"></p>
<h3 id="2、VMWare下载安装"><a href="#2、VMWare下载安装" class="headerlink" title="2、VMWare下载安装"></a>2、<code>VMWare下载安装</code></h3><p>2.1、<a href="https://www.vmware.com/products/workstation-player/workstation-player-evaluation.html">下载<code>vmware workstation16 player</code></a></p>
<p><img src="/archives/ba77e58/image-20210914112126565.png" alt="vmware下载"></p>
<p>根据需求下载对应版本，我们采用的是<code>Windows</code>版本，下载好之后安装，这里不列举安装步骤了，默认已经安装好。</p>
<p>2.2、安装省略，默认已经安装好</p>
<p>2.3、破解，参考之前写的一个博客<a href="/archives/59b9c4e6/">《vmare_workstation16许可证秘钥》</a></p>
<h3 id="3、创建虚拟机"><a href="#3、创建虚拟机" class="headerlink" title="3、创建虚拟机"></a>3、创建虚拟机</h3><p>创建过程也按照默认流程操作即可，只是在创建完毕之后，启动虚拟机时可能会遇到报错</p>
<blockquote>
<p>无法打开内核设备“.\VMCIDev\VMX”: 系统找不到指定的文件。你想要在安装 VMware Workstation 前重启吗?</p>
</blockquote>
<p>对于这个问题可以通过以下方法来解决：</p>
<ul>
<li>找到对应虚拟机的.vmx文件，通过记事本打开该文件</li>
<li>找到<code>vmci0.present=TRUE</code>这一行，将<code>TRUE</code>改为<code>FALSE</code>或者直接删除这一行</li>
<li>保存修改好的.vmx文件,并重启虚拟机</li>
</ul>
<h3 id="4、在虚拟机Centos系统中安装redis"><a href="#4、在虚拟机Centos系统中安装redis" class="headerlink" title="4、在虚拟机Centos系统中安装redis"></a>4、在虚拟机Centos系统中安装redis</h3><p>参考博文<a href="/archives/a813391e/">《Linux安装配置Redis》</a>，这里介绍了。</p>
<h3 id="5、主从架构搭建"><a href="#5、主从架构搭建" class="headerlink" title="5、主从架构搭建"></a>5、主从架构搭建</h3><p>以上一个步骤完成之后，接下来就开始搭建我们的redis主从架构了，首先我们搭建一主两从，搭建步骤参考步骤4；所以需要三台redis服务器，一台端口为6379作为主节点，另外两台端口分别为6380、6381作为两台从节点。</p>
<p><img src="/archives/ba77e58/image-20210924094756516.png" alt="主从架构"></p>
<p>5.1、首先来配置主节点(6379)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">logfile &quot;/home/redis/build/log/6379.log&quot;</span><br></pre></td></tr></table></figure>

<p>5.2 配置端口号为6380的从节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6380</span><br><span class="line">daemonize yes</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">logfile &quot;/home/redis/build/log/6380.log&quot;</span><br><span class="line">replicaof 192.168.34.128 6379  # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class="line">replica-read-only yes  # 配置从节点只读</span><br></pre></td></tr></table></figure>

<p> 5.3 配置端口为6381的从节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6381</span><br><span class="line">daemonize yes</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">logfile &quot;/home/redis/build/log/6381.log&quot;</span><br><span class="line">replicaof 192.168.34.128 6379  # 从本机6379的redis实例复制数据，Redis 5.0之前使用slaveof</span><br><span class="line">replica-read-only yes  # 配置从节点只读</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>配置以上主从节点都配置完成之后，还不能够同步成功。因为此时Centos的防火墙还处于打开状态，从节点是访问不到主节点，所以我们需要关闭防火墙，执行以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --state      <span class="comment">##查看防火墙状态</span></span><br><span class="line">running                     <span class="comment">##防火墙开启</span></span><br><span class="line"></span><br><span class="line">$ systemctl stop firewalld  <span class="comment">##关闭防火墙</span></span><br><span class="line">$ firewall-cmd --state</span><br><span class="line">not running                 <span class="comment">##防火墙关闭</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="启动主从节点"><a href="#启动主从节点" class="headerlink" title="启动主从节点"></a>启动主从节点</h3><ul>
<li>先启动主节点</li>
<li>再启动从节点</li>
</ul>
<h3 id="检查主从信息"><a href="#检查主从信息" class="headerlink" title="检查主从信息"></a>检查主从信息</h3><p><img src="/archives/ba77e58/image-20210914150857692.png" alt="image-20210914150857692"></p>
<blockquote>
<p>主节点：192.168.49.128:6379</p>
<p>从节点：192.168.49.129:6381 ，192.168.49.130:6380</p>
</blockquote>
<h3 id="验证同步数据"><a href="#验证同步数据" class="headerlink" title="验证同步数据"></a>验证同步数据</h3><p>登录主节点(192.168.49.128)客户端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -h 192.168.49.128</span><br></pre></td></tr></table></figure>

<p>在主节点客户端中添加测试数据;</p>
<p><img src="/archives/ba77e58/image-20210914151255794.png" alt="主节点192.168.49.128:6379"></p>
<p>登录从节点(192.168.49.129)客户端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -h 192.168.49.129 -p 6381</span><br></pre></td></tr></table></figure>

<p>在从节点客户端中执行<code>keys *</code>查看数据同步情况，如下图</p>
<p><img src="/archives/ba77e58/image-20210914151512277.png" alt="从节点192.168.49.129:6381"></p>
<p>登录从节点(192.168.49.130)客户端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/redis/build/bin/redis-cli -h 192.168.49.130 -p 6380</span><br></pre></td></tr></table></figure>

<p>在从节点客户端中执行<code>keys *</code>查看数据同步情况，如下图</p>
<p><img src="/archives/ba77e58/image-20210914151605027.png" alt="从节点192.168.49.130:6380"></p>
<p>redis主从数据同步成功，主从配置成功。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>vmare_workstation16许可证秘钥</title>
    <url>/archives/59b9c4e6/</url>
    <content><![CDATA[<p><code>vmare workstation16 player</code>虚拟机许可秘钥</p>
<blockquote>
<p>ZF3R0-FHED2-M80TY-8QYGC-NPKYF<br>YF390-0HF8P-M81RQ-2DXQE-M2UT6<br>ZF71R-DMX85-08DQY-8YMNC-PPHV8</p>
</blockquote>
<p>如果上面三个已经失效可以使用下面这个秘钥</p>
<blockquote>
<p>FA1M0-89YE3-081TQ-AFNX9-NKUC0</p>
</blockquote>
]]></content>
      <categories>
        <category>软件破解</category>
      </categories>
      <tags>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树增删改查操作</title>
    <url>/archives/6d5957d3/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>通过代码实现下面二叉树的构建，并且实现二叉树的增删改查操作。<br><img src="/archives/6d5957d3/image-20211114225038889.png" alt="二叉树"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>定义二叉树结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 数据 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> data;</span><br><span class="line">  <span class="comment">/** 左子树节点 */</span></span><br><span class="line">	<span class="keyword">private</span> TreeNode left;</span><br><span class="line">  <span class="comment">/** 右子树节点 */</span></span><br><span class="line">	<span class="keyword">private</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">char</span> data, TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(TreeNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(TreeNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树操作类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二叉树相关操作，增删改查</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeOptional</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前序遍历 根左右  </span></span><br><span class="line">	<span class="comment">// 时间复杂度O(2n) =&gt; O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			print(root);</span><br><span class="line">			<span class="keyword">if</span> (root.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				pre(root.getLeft());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (root.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				pre(root.getRight());				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中序遍历 左根右</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mid</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mid(root.getLeft());</span><br><span class="line">			&#125;</span><br><span class="line">			print(root);</span><br><span class="line">			<span class="keyword">if</span> (root.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mid(root.getRight());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后序遍历 左右根</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				post(root.getLeft());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(root.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				post(root.getRight());</span><br><span class="line">			&#125;</span><br><span class="line">			print(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(root, <span class="string">&quot;二叉树不能为空&quot;</span>);</span><br><span class="line">		Assert.notNull(node, <span class="string">&quot;添加的节点不能为空&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(node.getData() &lt;= root.getData()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				root.setLeft(node);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				add(root.getLeft(),node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				root.setRight(node);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				add(root.getRight(),node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(TreeNode root,TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (rmNode.getLeft() == <span class="keyword">null</span> &amp;&amp; rmNode.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			rmLeafNode(root,rmNode);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rmNode.getLeft() == <span class="keyword">null</span> &amp;&amp; rmNode.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			rmNodeWithRightNode(root,rmNode);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rmNode.getLeft() != <span class="keyword">null</span> &amp;&amp; rmNode.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			rmNodeWithLeftNode(root,rmNode);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rmNode.getLeft() != <span class="keyword">null</span> &amp;&amp; rmNode.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			rmNode(root,rmNode);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 寻找当前节点的父节点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> TreeNode <span class="title">getParentNode</span><span class="params">(TreeNode root,TreeNode node)</span> </span>&#123;</span><br><span class="line">		TreeNode treeNode = root;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; root.getLeft() != <span class="keyword">null</span> &amp;&amp; root.getLeft().getData() == node.getData()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;left = &quot;</span> + root);</span><br><span class="line">			<span class="keyword">return</span> treeNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; root.getRight() != <span class="keyword">null</span> &amp;&amp; root.getRight().getData() == node.getData()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Right = &quot;</span> + root.getData());</span><br><span class="line">			<span class="keyword">return</span> treeNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root.getData() &gt;= node.getData() ? getParentNode(root.getLeft(), node) : getParentNode(root.getRight(), node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除叶子节点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmLeafNode</span><span class="params">(TreeNode root,TreeNode rmNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		TreeNode parentNode = getParentNode(root,rmNode);</span><br><span class="line">		<span class="keyword">if</span> (parentNode.getLeft() != <span class="keyword">null</span> &amp;&amp; parentNode.getLeft().getData() == rmNode.getData()) &#123;</span><br><span class="line">			parentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (parentNode.getRight() != <span class="keyword">null</span> &amp;&amp; parentNode.getRight().getData() == rmNode.getData()) &#123;</span><br><span class="line">			parentNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点，该节点只有左子树有叶子节点，右子树没有节点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmNodeWithLeftNode</span><span class="params">(TreeNode root, TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">		TreeNode leftNode = rmNode.getLeft();</span><br><span class="line">		rmNode.setData(leftNode.getData());</span><br><span class="line">		rmNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">		rmNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点，该节点只有右子树有叶子节点，左子树为空</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmNodeWithRightNode</span><span class="params">(TreeNode root, TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">		TreeNode rightNode = rmNode.getRight();</span><br><span class="line">		rmNode.setData(rightNode.getData());</span><br><span class="line">		rmNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">		rmNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点，该节点既有左子树又有右子树</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmNode</span><span class="params">(TreeNode root, TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">		TreeNode parentNode = getParentNode(root, rmNode);</span><br><span class="line">		TreeNode firstMaxNode = findFirstMax(rmNode);</span><br><span class="line">		TreeNode firstMaxParentNode = getParentNode(rmNode, firstMaxNode);</span><br><span class="line">		<span class="keyword">if</span> (parentNode.getLeft().getData() == rmNode.getData()) &#123;</span><br><span class="line">			parentNode.setLeft(firstMaxNode);</span><br><span class="line">			firstMaxNode.setLeft(rmNode.getLeft());</span><br><span class="line">			firstMaxNode.setRight(rmNode.getRight());</span><br><span class="line">			firstMaxParentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (parentNode.getRight().getData() == rmNode.getData()) &#123;</span><br><span class="line">			parentNode.setRight(firstMaxNode);</span><br><span class="line">			firstMaxNode.setLeft(rmNode.getLeft());</span><br><span class="line">			firstMaxNode.setRight(rmNode.getRight());</span><br><span class="line">			firstMaxParentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 添加节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(root, <span class="string">&quot;二叉树不能为空&quot;</span>);</span><br><span class="line">		Assert.notNull(node, <span class="string">&quot;添加的节点不能为空&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(node.getData() &lt;= root.getData()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				root.setLeft(node);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				add(root.getLeft(),node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">				root.setRight(node);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				add(root.getRight(),node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 寻找当前节点的父节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">getParentNode</span><span class="params">(TreeNode root,TreeNode node)</span> </span>&#123;</span><br><span class="line">		TreeNode treeNode = root;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; root.getLeft() != <span class="keyword">null</span> &amp;&amp; root.getLeft().getData() == node.getData()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;left = &quot;</span> + root);</span><br><span class="line">			<span class="keyword">return</span> treeNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp; root.getRight() != <span class="keyword">null</span> &amp;&amp; root.getRight().getData() == node.getData()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Right = &quot;</span> + root.getData());</span><br><span class="line">			<span class="keyword">return</span> treeNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root.getData() &gt;= node.getData() ? getParentNode(root.getLeft(), node) : getParentNode(root.getRight(), node);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层次遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; tree = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        tree.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!tree.isEmpty()) &#123;</span><br><span class="line">            TreeNode remove = tree.remove();</span><br><span class="line">            list.add(remove);</span><br><span class="line">            <span class="keyword">if</span> (remove.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tree.add(remove.getLeft());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (remove.getRight() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tree.add(remove.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 删除叶子节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rmLeafNode</span><span class="params">(TreeNode root,TreeNode rmNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		TreeNode parentNode = getParentNode(root,rmNode);</span><br><span class="line">		<span class="keyword">if</span> (parentNode.getLeft() != <span class="keyword">null</span> &amp;&amp; parentNode.getLeft().getData() == rmNode.getData()) &#123;</span><br><span class="line">			parentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (parentNode.getRight() != <span class="keyword">null</span> &amp;&amp; parentNode.getRight().getData() == rmNode.getData()) &#123;</span><br><span class="line">			parentNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到第一个大于要删除节点的那个节点</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> TreeNode <span class="title">findFirstMax</span><span class="params">(TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">		TreeNode firstMaxNode = rmNode.getRight();</span><br><span class="line">		<span class="keyword">while</span>(firstMaxNode != <span class="keyword">null</span> &amp;&amp; firstMaxNode.getLeft() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(firstMaxNode.getLeft().getData() &lt; firstMaxNode.getData()) &#123;</span><br><span class="line">				firstMaxNode = firstMaxNode.getLeft();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> firstMaxNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.print(node.getData());	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试主类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TreeNode node_D = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;D&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_F = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;F&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_G = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;G&#x27;</span>,node_F,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_B = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;B&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_L = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;L&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_M = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;M&#x27;</span>,node_L,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_A = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;A&#x27;</span>,<span class="keyword">null</span>,node_B);</span><br><span class="line">		TreeNode node_C = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;C&#x27;</span>,node_A,node_D);</span><br><span class="line">		TreeNode node_E = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;E&#x27;</span>,node_C,node_G);</span><br><span class="line">		TreeNode root_H = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;H&#x27;</span>,node_E,node_M);</span><br><span class="line"></span><br><span class="line">		BinaryTreeOptional treeOption = <span class="keyword">new</span> BinaryTreeOptional();</span><br><span class="line">		<span class="comment">// 前序遍历</span></span><br><span class="line">		System.out.print(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">		treeOption.pre(root_H);</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">// 中序遍历</span></span><br><span class="line">		System.out.print(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">		treeOption.mid(root_H);</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">// 后序遍历</span></span><br><span class="line">		System.out.print(<span class="string">&quot;后序遍历: &quot;</span>);</span><br><span class="line">		treeOption.post(root_H);</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">// 添加节点</span></span><br><span class="line">		TreeNode node_K = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;K&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_I = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;I&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_N = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;N&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_W = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;W&#x27;</span>,node_N,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_X = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;X&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		TreeNode node_Y = <span class="keyword">new</span> TreeNode(<span class="string">&#x27;Y&#x27;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;添加节点: &quot;</span> + node_K.getData() + <span class="string">&quot;,&quot;</span> + node_I.getData());</span><br><span class="line">		treeOption.add(root_H, node_K);</span><br><span class="line">		treeOption.add(root_H, node_W);</span><br><span class="line">		treeOption.add(root_H, node_X);</span><br><span class="line">		treeOption.add(root_H, node_Y);</span><br><span class="line">		System.out.print(<span class="string">&quot;添加节点后的前序遍历是：&quot;</span>);</span><br><span class="line">		treeOption.mid(root_H);</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">// 删除叶子节点</span></span><br><span class="line">		<span class="comment">// treeOption.remove(root_H, node_G);</span></span><br><span class="line">		<span class="comment">// System.out.print(&quot;前序遍历：&quot;);</span></span><br><span class="line">		<span class="comment">// treeOption.pre(root_H);</span></span><br><span class="line">		<span class="comment">// System.out.println();</span></span><br><span class="line"></span><br><span class="line">		TreeNode s = treeOption.findFirstMax(node_E);</span><br><span class="line">		System.out.println(<span class="string">&quot;第一个比根节点大的数： &quot;</span> + s.getData());</span><br><span class="line">		treeOption.rmLeafNode(root_H, node_G);</span><br><span class="line">		System.out.print(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">		treeOption.pre(root_H);</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除中间节点</span></span><br><span class="line">		treeOption.remove(root_H, node_M);</span><br><span class="line">		System.out.print(<span class="string">&quot;删除中间节点后的前序遍历是：&quot;</span>);</span><br><span class="line">		treeOption.pre(root_H);</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.print(<span class="string">&quot;删除中间节点后的中序序遍历是：&quot;</span>);</span><br><span class="line">		treeOption.mid(root_H);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在删除二叉树的节点是需要注意的是，二叉树节点删除有四种情况，分别是：</p>
<ol>
<li>要删除的节点是叶子节点</li>
<li>要删除的节点左子树为空，右子树不为空</li>
<li>要删除的节点左子树不为空，右子树为空</li>
<li>要删除的节点左子树不为空，右子树也不为空</li>
</ol>
<p>第一种情况比较简单，直接删除节点即可。如下图，如果删除叶子节点B，则直接将节点A的右子树设置为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A.right = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>



<p><img src="/archives/6d5957d3/image-20211120144141294.png" alt="删除叶子节点"></p>
<p>删除叶子节点代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmLeafNode</span><span class="params">(TreeNode root,TreeNode rmNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	TreeNode parentNode = getParentNode(root,rmNode);</span><br><span class="line">	<span class="keyword">if</span> (parentNode.getLeft() != <span class="keyword">null</span> &amp;&amp; parentNode.getLeft().getData() == rmNode.getData()) &#123;</span><br><span class="line">		parentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (parentNode.getRight() != <span class="keyword">null</span> &amp;&amp; parentNode.getRight().getData() == rmNode.getData()) &#123;</span><br><span class="line">		parentNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：“要删除的节点左子树为空，右子树不为空”。</p>
<p>删除节点G，因为节点G只有右子树节点，所以删除G节点时，需要将G的右节点F设置到G节点位置，删除G节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E.right = G.right;</span><br><span class="line">G.right = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/archives/6d5957d3/%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA.png" alt="要删除的节点左子树为空，右子树不为空"></p>
<p>删除节点G完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点，该节点只有右子树有叶子节点，左子树为空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmNodeWithRightNode</span><span class="params">(TreeNode root, TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">	TreeNode rightNode = rmNode.getRight();</span><br><span class="line">	rmNode.setData(rightNode.getData());</span><br><span class="line">	rmNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">	rmNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种：“要删除的节点左子树不为空，右子树为空”</p>
<p>例如删除节点L，删除步骤和第二种情况步骤基本一样；将L节点的左子树与K节点的连接断开，并且将M节点（L节点的父节点）的左子树节点设置为K，即可删除L节点。</p>
<p><img src="/archives/6d5957d3/%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%BA%E7%A9%BA.png" alt="要删除的节点左子树不为空，右子树为空"></p>
<p>删除节点完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点，该节点只有左子树有叶子节点，右子树没有节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmNodeWithLeftNode</span><span class="params">(TreeNode root, TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">	TreeNode leftNode = rmNode.getLeft();</span><br><span class="line">	rmNode.setData(leftNode.getData());</span><br><span class="line">	rmNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">	rmNode.setRight(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四种：“要删除的节点左子树和右子树都不为空”</p>
<p>例如删除节点M，因为节点M既有左子树，又有右子树。所以在删除节点M的时候需要在M节点的右子树下找到地第一个大于M节点的节点，即N节点。然后将N节点放在M节点的位置，删除M节点。</p>
<p><img src="/archives/6d5957d3/%E5%B7%A6%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA%EF%BC%8C%E5%8F%B3%E5%AD%90%E6%A0%91%E4%B8%8D%E4%B8%BA%E7%A9%BA.png" alt="左子树不为空，右子树不为空"></p>
<p>删除代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点，该节点既有左子树又有右子树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">rmNode</span><span class="params">(TreeNode root, TreeNode rmNode)</span> </span>&#123;</span><br><span class="line">	TreeNode parentNode = getParentNode(root, rmNode);</span><br><span class="line">	TreeNode firstMaxNode = findFirstMax(rmNode);</span><br><span class="line">	TreeNode firstMaxParentNode = getParentNode(rmNode, firstMaxNode);</span><br><span class="line">	<span class="keyword">if</span> (parentNode.getLeft().getData() == rmNode.getData()) &#123;</span><br><span class="line">		parentNode.setLeft(firstMaxNode);</span><br><span class="line">		firstMaxNode.setLeft(rmNode.getLeft());</span><br><span class="line">		firstMaxNode.setRight(rmNode.getRight());</span><br><span class="line">		firstMaxParentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (parentNode.getRight().getData() == rmNode.getData()) &#123;</span><br><span class="line">		parentNode.setRight(firstMaxNode);</span><br><span class="line">		firstMaxNode.setLeft(rmNode.getLeft());</span><br><span class="line">		firstMaxNode.setRight(rmNode.getRight());</span><br><span class="line">		firstMaxParentNode.setLeft(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>使用栈数据结构实现简易计算器算法</title>
    <url>/archives/12e6bc0/</url>
    <content><![CDATA[<p>首先看一下设计思路：</p>
<p><img src="/archives/12e6bc0/%E6%A0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8.png" alt="栈数据结构实现简易计算器"></p>
<p>具体代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: netty-chat 数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-01 15:02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 操作数栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 符号栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Character&gt; operatorStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">calculate</span><span class="params">(String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; des.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 如果读取出来的是数字，直接将数字加入到操作数栈，否则加入的符号栈中</span></span><br><span class="line">            <span class="keyword">if</span> (Character.getType(des.charAt(i)) == <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="comment">// 读取出来的是ASCII码，需要减去48才是真正是数字</span></span><br><span class="line">                numberStack.push(Integer.valueOf(des.charAt(i)-<span class="number">48</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果符号栈为空，则直接加入到符号栈中</span></span><br><span class="line">                <span class="keyword">if</span> (operatorStack.isEmpty()) &#123;</span><br><span class="line">                    operatorStack.push(des.charAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果符号栈不为空，则比较符号栈栈顶符号和截取出来的符号的优先级，如果小于栈顶符号优先级，则取出栈顶符号和操作数栈中的两个数字做运算，</span></span><br><span class="line">                    <span class="comment">// 并将最后运算结果重新加入到操作数栈中，同时将此刻解析到的符号加入到符号栈中</span></span><br><span class="line">                    <span class="keyword">if</span> (priority(des.charAt(i)) &lt;= priority(operatorStack.peek())) &#123;</span><br><span class="line">                        Integer sec = numberStack.pop();</span><br><span class="line">                        Integer fir = numberStack.pop();</span><br><span class="line">                        Character operator = operatorStack.pop();</span><br><span class="line">                        <span class="keyword">int</span> result = <span class="keyword">this</span>.cal(fir, sec, operator);</span><br><span class="line">                        numberStack.push(result);</span><br><span class="line">                        operatorStack.push(des.charAt(i));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        operatorStack.push(des.charAt(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理符号栈中剩余的还没有做运算的符号</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (operatorStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Integer sec = numberStack.pop();</span><br><span class="line">            Integer fir = numberStack.pop();</span><br><span class="line">            Character operator = operatorStack.pop();</span><br><span class="line">            <span class="keyword">int</span> result = cal(fir, sec, operator);</span><br><span class="line">            numberStack.push(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后留在操作数栈中的数字，就是最后表达式的运算结果</span></span><br><span class="line">        <span class="keyword">return</span> numberStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取操作数优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operator 操作数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">char</span> operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (operator == <span class="string">&#x27;*&#x27;</span> || operator == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator == <span class="string">&#x27;+&#x27;</span> || operator == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 做计算操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operator)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                result = a + b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                result = a - b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                result = a * b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                result = a / b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer calculate = <span class="keyword">new</span> CalculateStack().calculate(<span class="string">&quot;8+4*3-6/2+1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8+4*3-6/2+1 = &quot;</span> + calculate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/archives/12e6bc0/image-20211101162442155.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>利用数组实现队列操作</title>
    <url>/archives/ace10538/</url>
    <content><![CDATA[<p>题目：利用数组来实现队列的入队，出队，队列扩容等操作，写出具体实现代码。</p>
<blockquote>
<p>解析：</p>
<p>首先应该知道队列最大的特点就是先进先出(FIFO)，所以这里也就限制了队列只能进行入队，并且只能是从尾部入队，不能随意插入；出队也只能是从头开始一次出队；知道了这个特点就可以开始写代码了</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: netty-chat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-02 09:17</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] data;   <span class="comment">// 队列数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">2</span>&lt;&lt;<span class="number">4</span>; <span class="comment">// 队列初始化大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;    <span class="comment">// 对头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapcity = <span class="number">2</span>&lt;&lt;<span class="number">5</span>;  <span class="comment">// 队列最大容量，超过这个最大容量，队列将不会再进行扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里时间复杂度最好为O(1)，即不进行扩容操作，最坏是在最后一步进行扩容操作，此时扩容的时候时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">                <span class="comment">// 队列满时进行扩容操作，扩容大小为原来容量的2倍</span></span><br><span class="line">                <span class="keyword">this</span>.resize();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.data[tail] = data;</span><br><span class="line">            tail++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列是否已满</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.tail &gt;= <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 扩容时的容量是原来容量的二倍</span></span><br><span class="line">        <span class="keyword">this</span>.size *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt;= <span class="keyword">this</span>.maxCapcity) &#123;</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="keyword">this</span>.maxCapcity;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] temp = <span class="keyword">new</span> Object[<span class="keyword">this</span>.size];</span><br><span class="line">        <span class="keyword">int</span> tailTmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; head &lt; tail; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            temp[i] = <span class="keyword">this</span>.data[head++];</span><br><span class="line">            tailTmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.data = temp;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = tailTmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object datum = <span class="keyword">this</span>.data[head];</span><br><span class="line">        <span class="keyword">this</span>.data[head++] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (T)datum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ArrayQueue&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + Arrays.toString(data) +</span><br><span class="line">                <span class="string">&quot;, size=&quot;</span> + size +</span><br><span class="line">                <span class="string">&quot;, tail=&quot;</span> + tail +</span><br><span class="line">                <span class="string">&quot;, head=&quot;</span> + head +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayQueue&lt;Integer&gt; arrayQueue = <span class="keyword">new</span> ArrayQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">1</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">2</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">3</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">4</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">5</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">6</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">7</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">8</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">9</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">10</span>);</span><br><span class="line">        arrayQueue.add(<span class="number">11</span>);</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.remove());</span><br><span class="line">        System.out.println(arrayQueue.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行上述代码可以看到如下结果:</p>
<p><img src="/archives/ace10538/image-20211102104159677.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法——背包问题</title>
    <url>/archives/9e50665b/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>小偷去某商店盗窃，带有一个背包，容量是50kg,现在有以下物品（物品不能切分，且只有一个），请问小偷应该怎么拿才能得到最大的价值？</p>
<table>
<thead>
<tr>
<th align="center">物品</th>
<th align="center">重量</th>
<th align="center">价值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物品1</td>
<td align="center">10kg</td>
<td align="center">60元</td>
</tr>
<tr>
<td align="center">物品2</td>
<td align="center">20kg</td>
<td align="center">100元</td>
</tr>
<tr>
<td align="center">物品3</td>
<td align="center">40kg</td>
<td align="center">120元</td>
</tr>
</tbody></table>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我们把50kg的袋子，拆分成5份，里面的表格就表示 <strong>当前重量下能装的最多的钱</strong>，第一列表示要装的物品</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">10kg</th>
<th align="center">20kg</th>
<th align="center">30kg</th>
<th align="center">40kg</th>
<th align="center">50kg</th>
</tr>
</thead>
<tbody><tr>
<td align="center">物品1</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">物品2</td>
<td align="center">60</td>
<td align="center">100</td>
<td align="center">160</td>
<td align="center">160</td>
<td align="center">160</td>
</tr>
<tr>
<td align="center">物品3</td>
<td align="center">60</td>
<td align="center">100</td>
<td align="center">160</td>
<td align="center">160</td>
<td align="center">180</td>
</tr>
</tbody></table>
<p>加入物品1：</p>
<ol>
<li>只有物品1时，无论袋子有多大容量，那么能得到的做多的钱就是为物品1的价值，即60元。</li>
</ol>
<p>加入物品2：</p>
<ol>
<li>当袋子容量为10kg时，只能装下物品1，所以最多钱也就是60</li>
<li>当袋子容量为20kg时，可以装下物品1或者物品2，但是物品1的钱要比物品2的钱少，所以装物品2更划算，所以最多钱也就是100</li>
<li>当袋子容量为30kg时，可以同时装下物品1和物品2，此时最多钱也就是160</li>
<li>当袋子容量为40kg时，同3</li>
<li>当袋子容量为50kg时，同3</li>
</ol>
<p>加入物品3：</p>
<ol>
<li>袋子容量为10kg时，装不下，所以最多钱还是60</li>
<li>袋子容量为20kg时，装不下物品3，只能选择钱比较多的物品2，此时钱最多为100</li>
<li>袋子容量为30kg时，装不下物品3，所以延续上次选择的160</li>
<li>袋子容量为40kg时，此时可以选择装物品4或者装物品1+物品2；显然物品1+物品2所得到的钱(160)要比只装物品3(120)得到的钱多，所以选择装物品1+物品2，所以钱做多为160</li>
<li>袋子容量为50kg时，可以装下物品1+物品2、物品1+物品3；显然物品1+物品3所得到的钱(180)要比物品1+物品2所得到的钱(160)多，所以选择装物品1+物品3，所以钱做多为180</li>
</ol>
<p>由上述过程可以推出状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Max(money[i] + res[i - 1][w-weight[i]],res[i - 1][w])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>money[i]: 表示第i个物品的价值</p>
<p>w: 当前背包总容量</p>
<p>res[i - 1][w - weight[i]]：表示当前物品没有装入背包中时，背包中可以装下物品的最大价值</p>
<p>weight[i]: 第i个物品的重量</p>
<p>res[i - 1][w]: 当前物物品没有装时，背包中物品价值</p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#x27;main&#x27; method must be in a class &#x27;Rextester&#x27;.</span></span><br><span class="line"><span class="comment">//Compiler version 1.8.0_111</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rextester</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">		dynamicAlgorithm();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dynamicAlgorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 背包总重量</span></span><br><span class="line">		<span class="keyword">int</span> w = <span class="number">50</span>;</span><br><span class="line">		<span class="comment">// 物品个数</span></span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">		<span class="comment">// 每个物品的重量</span></span><br><span class="line">		<span class="keyword">int</span>[] weights = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">40</span>&#125;;</span><br><span class="line">		<span class="comment">// 每个物品的价值</span></span><br><span class="line">		<span class="keyword">int</span>[] money = &#123;<span class="number">60</span>,<span class="number">100</span>,<span class="number">120</span>&#125;;</span><br><span class="line">		<span class="comment">// 这个二维数组就是表示上面表格中的内容</span></span><br><span class="line">		<span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][w + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 每次加的物品</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="comment">// 分割的背包</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= w; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(j &gt;= weights[i - <span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">int</span> value = Math.max(money[i - <span class="number">1</span>] + res[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]],res[i - <span class="number">1</span>][j]);</span><br><span class="line">					res[i][j] = value;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					res[i][j] = res[i - <span class="number">1</span>][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找路径</span></span><br><span class="line">		<span class="keyword">int</span> row = res.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> col = res[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(row &gt; <span class="number">0</span> &amp;&amp; col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 从最后一个背包中开始找路径，如果最后一个背包中的物品价值和装了前一个物品的背包价值一样，说明最后一个物品</span></span><br><span class="line">			<span class="comment">// 装和不装一样，那么就应该从倒数第二个背包开始寻找(row--)，一次类推</span></span><br><span class="line">			<span class="keyword">if</span>(res[row][col] == res[row - <span class="number">1</span>][col]) &#123;</span><br><span class="line">				row -= <span class="number">1</span> ;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果当前背包中价值和前一个背包价值不一样，则说明当前背包中新装了物品，当然新装的物品就时当前的物品，</span></span><br><span class="line">				<span class="comment">// 所以用当前背包容量 - 前一个背包容量，就是当前物品的重量，那么剩余的背包容量，就是能装下的物品的最大价值</span></span><br><span class="line">				<span class="comment">// 所以下一次应该从第cole - weights[--row]个背包开始找</span></span><br><span class="line">				System.out.println(<span class="string">&quot;选择重量为：&quot;</span> + weights[row - <span class="number">1</span>]+<span class="string">&quot;的物品&quot;</span>);</span><br><span class="line">				<span class="comment">// --row 是因为包含了背包边界（即数组边界）,</span></span><br><span class="line">				col = col - weights[--row];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/archives/b0c16ae4/</url>
    <content><![CDATA[<h2 id="哈夫曼树-Huffman-Tree-描述"><a href="#哈夫曼树-Huffman-Tree-描述" class="headerlink" title="哈夫曼树(Huffman Tree)描述"></a>哈夫曼树(Huffman Tree)描述</h2><p>哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶子节点的权值乘上其到根节点的路径长度(若根节点为0层，叶节点到根节点的路径长度为叶节点的层数)。</p>
<p>在哈夫曼树中，权重越大的节点越接近根节点。</p>
<h2 id="哈夫曼树相关术语"><a href="#哈夫曼树相关术语" class="headerlink" title="哈夫曼树相关术语"></a>哈夫曼树相关术语</h2><p><strong>路径：</strong> 在一棵树中，从一个节点往下可以到达的孩子节点或者孙子节点之间的通路，称为路径。图1中，从根节点到节点a之间的通路就是一条路径。</p>
<p><strong>路径长度：</strong> 在一条路径中，没经过一个节点，路径长度就要加1。例如在一棵树中，规定根节点所在层数为1层，那么从根节点到第i层节点的路径长度为i - 1。图1中从根节点到节点c的路径长度为3。</p>
<p><strong>节点的权：</strong> 给每个节点赋予一个新的值，这个值就是节点的权。例如，图1中节点a的权7，节点b的权为5。</p>
<p><strong>节点的带权路径长度：</strong> 指的是根节点到该节点之间的路径长度与该节点的权的乘积。例如，图1中节点b的带权路径长度为 2 * 5 = 10</p>
<p>整棵树的带权路径长度为树中所有叶子节点的带权路径长度之和。通常用<code>WPL</code>来表示。例如图1中所示的树的带权路径长度为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WPL = <span class="number">7</span> * <span class="number">1</span> + <span class="number">5</span> * <span class="number">2</span> + <span class="number">2</span> * <span class="number">3</span> + <span class="number">4</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/b0c16ae4/%E5%9B%BE1%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="图1 哈夫曼树"></p>
<h2 id="哈夫曼树应用"><a href="#哈夫曼树应用" class="headerlink" title="哈夫曼树应用"></a>哈夫曼树应用</h2><ol>
<li><strong>哈夫曼编码：</strong> 在数据通信中用来信息加密</li>
<li><strong>哈夫曼译码：</strong> 如果数据通过哈夫曼编码加密，那么接收到数据之后，可以通过哈夫曼译码进行解密。</li>
<li><strong>无损压缩：</strong> 可以通过哈夫曼编码对数据进行压缩</li>
</ol>
<blockquote>
<p>哈夫曼加密是可逆操作，加密后的密文可以通过解密还原原始数据。</p>
</blockquote>
<h2 id="哈夫曼树的构建过程"><a href="#哈夫曼树的构建过程" class="headerlink" title="哈夫曼树的构建过程"></a>哈夫曼树的构建过程</h2><p>对于给定的有各自权重的n个节点，构建步骤如下：</p>
<ol>
<li>在n个带权重的节点中，选择两个权重最小的节点，组成一棵新的二叉树，且新树的根节点权值为最小两个节点权值的和。</li>
<li>从n个带权重节点中删除步骤1中取出的两个节点，并且将新组成的树的根节点加入到n个带权重节点中。以此类推</li>
<li>重复执行步骤1和步骤2。直到构建完成一棵树。</li>
</ol>
<p><img src="/archives/b0c16ae4/%E5%9B%BE2%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="图2 哈夫曼树构建过程"></p>
<p>将构建好的哈夫曼树，每个节点的左子树编码为0，右子树编码为1。这样就可以实现哈夫曼编码，以及数据压缩。</p>
<p><img src="/archives/b0c16ae4/image-20211122155328007.png" alt="图3 哈夫曼编码"></p>
<p>如上图3所示。每个字母都会唯一对应一个编码，这样就可以实现加密</p>
<p>a——0</p>
<p>b——010</p>
<p>c——110</p>
<p>d——111</p>
<h2 id="哈夫曼树代码实现"><a href="#哈夫曼树代码实现" class="headerlink" title="哈夫曼树代码实现"></a>哈夫曼树代码实现</h2><p>定义哈夫曼树节点结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼树节点结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 节点数据 */</span></span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="comment">/** 节点权重 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="comment">/** 左节点 */</span></span><br><span class="line">    <span class="keyword">private</span> HuffmanNode left;</span><br><span class="line">    <span class="comment">/** 右节点 */</span></span><br><span class="line">    <span class="keyword">private</span> HuffmanNode right;</span><br><span class="line">    <span class="comment">/** 父节点，遍历会用 */</span></span><br><span class="line">    <span class="keyword">private</span> HuffmanNode parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuffmanNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HuffmanNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuffmanNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HuffmanNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HuffmanNode <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(HuffmanNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>哈夫曼树相关操作类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 根节点 */</span></span><br><span class="line">    <span class="keyword">private</span> HuffmanNode root;</span><br><span class="line">    <span class="comment">/** 叶子节点，用于后期权重计算 */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HuffmanNode&gt; leafNodes;</span><br><span class="line">    <span class="comment">/** 每个数据的权重映射表 */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Integer&gt; weightMapping;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanTree</span><span class="params">(Map&lt;Character, Integer&gt; weightMapping)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weightMapping = weightMapping;</span><br><span class="line">        <span class="keyword">this</span>.leafNodes = <span class="keyword">new</span> ArrayList&lt;HuffmanNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建哈夫曼树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createHuffmanTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Character[] keys = weightMapping.keySet().toArray(<span class="keyword">new</span> Character[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 初始化一个优先队列</span></span><br><span class="line">        PriorityQueue&lt;HuffmanNode&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;HuffmanNode&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character character : keys) &#123;</span><br><span class="line">            HuffmanNode node = <span class="keyword">new</span> HuffmanNode();</span><br><span class="line">            node.setData(character.toString());</span><br><span class="line">            node.setWeight(weightMapping.get(character));</span><br><span class="line">            priorityQueue.add(node);</span><br><span class="line">            <span class="keyword">this</span>.leafNodes.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = priorityQueue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            HuffmanNode nodeLeft = priorityQueue.poll();</span><br><span class="line">            HuffmanNode nodeRight = priorityQueue.poll();</span><br><span class="line"></span><br><span class="line">            HuffmanNode newNode = <span class="keyword">new</span> HuffmanNode();</span><br><span class="line">            newNode.setData(nodeLeft.getData() + nodeRight.getData());</span><br><span class="line">            newNode.setWeight(nodeLeft.getWeight() + nodeRight.getWeight());</span><br><span class="line">            newNode.setLeft(nodeLeft);</span><br><span class="line">            newNode.setRight(nodeRight);</span><br><span class="line">            nodeLeft.setParent(newNode);</span><br><span class="line">            nodeRight.setParent(newNode);</span><br><span class="line"></span><br><span class="line">            priorityQueue.add(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 弹出的就是根节点</span></span><br><span class="line">        <span class="keyword">this</span>.root = priorityQueue.poll();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对叶子节点进行编码操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回叶子节点编码表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">encoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, String&gt; codMapping = <span class="keyword">new</span> HashMap&lt;Character,String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (HuffmanNode huffmanNode : <span class="keyword">this</span>.leafNodes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(huffmanNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                HuffmanNode currentNode = huffmanNode;</span><br><span class="line">                <span class="keyword">char</span> cData = huffmanNode.getData().charAt(<span class="number">0</span>);</span><br><span class="line">                String code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明当前节点是左子树节点</span></span><br><span class="line">                    <span class="keyword">if</span> (currentNode != <span class="keyword">null</span> &amp;&amp; currentNode.getParent() != <span class="keyword">null</span> &amp;&amp; currentNode == currentNode.getParent().getLeft()) &#123;</span><br><span class="line">                        code = <span class="string">&quot;0&quot;</span> + code;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        code = <span class="string">&quot;1&quot;</span> + code;</span><br><span class="line">                    &#125;</span><br><span class="line">                    currentNode = currentNode.getParent();</span><br><span class="line">                &#125; <span class="keyword">while</span>(currentNode.getParent() != <span class="keyword">null</span>); <span class="comment">// 表示循环到根节点，停止循环</span></span><br><span class="line">                codMapping.put(cData, code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> codMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试运行主类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; weights = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        weights.put(<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">        weights.put(<span class="string">&#x27;b&#x27;</span>, <span class="number">24</span>);</span><br><span class="line">        weights.put(<span class="string">&#x27;c&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">        weights.put(<span class="string">&#x27;d&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">        weights.put(<span class="string">&#x27;e&#x27;</span>, <span class="number">34</span>);</span><br><span class="line">        weights.put(<span class="string">&#x27;f&#x27;</span>, <span class="number">4</span>);</span><br><span class="line">        weights.put(<span class="string">&#x27;g&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">        HuffmanTree huffmanTree = <span class="keyword">new</span> HuffmanTree(weights);</span><br><span class="line">        <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">        huffmanTree.createHuffmanTree();</span><br><span class="line">        <span class="comment">// 对哈夫曼树节点进行编码</span></span><br><span class="line">        Map&lt;Character,String&gt; code = huffmanTree.encoding();</span><br><span class="line">        System.out.println(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title>在pyecharts中自定义geojson创建地图</title>
    <url>/archives/5c618354/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>客户要求使用地图展示全省用电量，这里自然是想到了使用pyecharts来做地图，然后渲染数据；然而一切进展的很坎坷，在展示杭州地图时因为在2021年杭州重新调整了行政区域，pyecharts中也没有及时的更新相关数据，所以导致生成出来的杭州地图行政划分是错的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自己生成一份最新的geojson数据，然后手动注册地图；具体步骤如下：</p>
<p>1、在<a href="http://datav.aliyun.com/portal/school/atlas/area_selector">阿里云数据可视化平台</a> 中选择要显示的区域，然后点击复制选中城市的json数据</p>
<p><img src="/archives/5c618354/image-20220119121948189.png" alt="阿里云数据可视化平台"></p>
<p>2、在<a href="http://geojson.io/#map=9/30.2353/122.2587">http://geojson.io/#map=9/30.2353/122.2587</a> 网站中粘贴在步骤1中复制的数据，网站会自动转成geojson格式的数据</p>
<p><img src="/archives/5c618354/image-20220119122802421.png" alt="geojson数据格式化"></p>
<p>3、在工程中新建json文件“hangzhou_geojson.json”，并将步骤2中转化好的geojson数据复制到“hangzhou_geojson.json”中保存</p>
<p><img src="/archives/5c618354/image-20220119123123825.png" alt="创建hangzhou_geojson.json"></p>
<p>4、编写python代码创建我们自定义地图</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">values</span>(<span class="params">rge, start: <span class="built_in">int</span> = <span class="number">20</span>, end: <span class="built_in">int</span> = <span class="number">150</span></span>) -&gt; <span class="built_in">list</span>:</span></span><br><span class="line">    ar = [random.randint(start, end) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rge)]</span><br><span class="line">    <span class="built_in">print</span>(ar)</span><br><span class="line">    <span class="keyword">return</span> ar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    hangzhou = [<span class="string">&quot;滨江区&quot;</span>, <span class="string">&quot;淳安县&quot;</span>, <span class="string">&quot;富阳区&quot;</span>, <span class="string">&quot;拱墅区&quot;</span>, <span class="string">&quot;建德市&quot;</span>, <span class="string">&quot;临安区&quot;</span>, <span class="string">&quot;临平区&quot;</span>, <span class="string">&quot;钱塘区&quot;</span>, <span class="string">&quot;上城区&quot;</span>, <span class="string">&quot;桐庐县&quot;</span>, <span class="string">&quot;西湖区&quot;</span>, <span class="string">&quot;萧山区&quot;</span>, <span class="string">&quot;临平区&quot;</span>, <span class="string">&quot;余杭区&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在导出&#123;&#125;地图...&quot;</span>)</span><br><span class="line">    html_path = <span class="string">&quot;./html/map_hangzhou.html&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(html_path):</span><br><span class="line">        os.remove(html_path)</span><br><span class="line">    geojson_path = <span class="string">&quot;./geojson/hangzhou_geojson.json&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(geojson_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        stream = file.read()</span><br><span class="line">    Map().add_js_funcs(<span class="string">&quot;echarts.registerMap(&#x27;杭州市&#x27;,&#123;&#125;);&quot;</span>, stream) \</span><br><span class="line">        .add(<span class="string">&quot;商家A&quot;</span>, [<span class="built_in">list</span>(z) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">zip</span>(hangzhou, values(<span class="built_in">len</span>(hangzhou), <span class="number">20</span>, <span class="number">150</span>))], <span class="string">&quot;杭州&quot;</span>) \</span><br><span class="line">        .set_global_opts(</span><br><span class="line">        title_opts=opts.TitleOpts(title=<span class="string">&quot;Map-&#123;&#125;地图&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;杭州&quot;</span>)),</span><br><span class="line">        visualmap_opts=opts.VisualMapOpts()</span><br><span class="line">    ) \</span><br><span class="line">        .render(html_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;地图导出完成，文件路径:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;杭州&quot;</span>, html_path))</span><br></pre></td></tr></table></figure>

<p>5、运行代码结果</p>
<p><img src="/archives/5c618354/image-20220119123956337.png" alt="运行结果"></p>
<h3 id="完整工程代码"><a href="#完整工程代码" class="headerlink" title="完整工程代码"></a>完整工程代码</h3><p>工程代码在<a href="https://github.com/li-huibin/pyecharts">github</a> 需要的可以自提</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyecharts</tag>
      </tags>
  </entry>
  <entry>
    <title>手写LinkedList（简易版）</title>
    <url>/archives/f9405533/</url>
    <content><![CDATA[<p>MyLinked代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: netty-chat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-01 09:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinked</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">        <span class="keyword">this</span>.incrLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">this</span>.incrLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> loc, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loc &lt; length) &#123;</span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span>(loc-<span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                loc--;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            <span class="keyword">this</span>.incrLength();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(loc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addFirst(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (loc &gt; length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.add(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> loc, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loc &lt; length) &#123;</span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span>(loc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                loc--;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> loc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loc &lt; length) &#123;</span><br><span class="line">            Node temp = head;</span><br><span class="line">            <span class="keyword">while</span> (loc-<span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                loc--;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            <span class="keyword">this</span>.subLength();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incrLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;length : &quot;</span>+<span class="keyword">this</span>.length + <span class="string">&quot;, head: &quot;</span>+ head.toString()+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;data: &quot;</span> + data);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;next: &quot;</span>);</span><br><span class="line">            stringBuilder.append(next == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : next.toString());</span><br><span class="line">            stringBuilder.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: netty-chat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-01 09:50</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLinked myLinked = <span class="keyword">new</span> MyLinked();</span><br><span class="line">        myLinked.addFirst(<span class="number">5</span>);</span><br><span class="line">        myLinked.addFirst(-<span class="number">1</span>);</span><br><span class="line">        myLinked.add(<span class="number">1</span>);</span><br><span class="line">        myLinked.add(<span class="number">2</span>);</span><br><span class="line">        myLinked.add(<span class="number">3</span>);</span><br><span class="line">        myLinked.insert(<span class="number">2</span>,<span class="number">6</span>);</span><br><span class="line">        myLinked.insert(<span class="number">3</span>,<span class="number">10</span>);</span><br><span class="line">        myLinked.update(<span class="number">3</span>,<span class="number">20</span>);</span><br><span class="line">        myLinked.delete(<span class="number">2</span>);</span><br><span class="line">        System.out.println(myLinked.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<p><img src="/archives/f9405533/image-20211101173137897.png" alt="结果"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——冒泡排序</title>
    <url>/archives/4fe6adbb/</url>
    <content><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数</li>
<li>针对所有的元素重复以上步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ol>
<h2 id="动态图演示"><a href="#动态图演示" class="headerlink" title="动态图演示"></a>动态图演示</h2><p><img src="/archives/4fe6adbb/bubbleSort.gif" alt="冒泡排序动态图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">        bubbleSort(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;冒泡排序结果：&quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制排序次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 此处为算法优化点，可以去掉； 设置一个标记，若为true，则表示此次循环没有需要进行交换的，也就是说待排序序列已经是有序的了</span></span><br><span class="line">            <span class="keyword">boolean</span> sortFlag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 开始从第0个元素排序，相邻两个元素排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; data.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(data[j] &gt; data[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    sortFlag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 交换元素</span></span><br><span class="line">                    <span class="comment">// 第一种交换写法，通过加减运算</span></span><br><span class="line">                    data[j] = data[j] + data[j + <span class="number">1</span>];</span><br><span class="line">                    data[j + <span class="number">1</span>] = data[j] - data[j + <span class="number">1</span>];</span><br><span class="line">                    data[j] = data[j] - data[j + <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 第二种交换写法，通过异或(^)运算</span></span><br><span class="line"><span class="comment">//                    data[j] = (data[j] ^ data[j + 1]);</span></span><br><span class="line"><span class="comment">//                    data[j + 1] = data[j + 1] ^ data[j];</span></span><br><span class="line"><span class="comment">//                    data[j] =  data[j + 1] ^ data[j];</span></span><br><span class="line">                    <span class="comment">// 第三种交换写法，通过借助临时变量完成</span></span><br><span class="line"><span class="comment">//                    int temp = data[j];</span></span><br><span class="line"><span class="comment">//                    data[j] = data[j + 1];</span></span><br><span class="line"><span class="comment">//                    data[j + 1] = temp;</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sortFlag) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在交换元素的时候有三种方式：</p>
<ul>
<li>通过元素间的加减运算交换——-代码中第一种写法</li>
<li>通过元素间的异或(^)运算交换——–代码中第二种写法</li>
<li>通过借助临时变量交换——–代码中第三种写法</li>
</ul>
<p>其中前两种写法在运行效率上高于第三种，因为在运行过程中减少了内存分配的开销。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——堆排序</title>
    <url>/archives/78985d23/</url>
    <content><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序(Heapsort)是指利用堆这种数据结构进行的一种排序算法。堆排序的平均时间复杂度为O(nlogn)。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆可以分为大顶堆和小顶堆</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列。</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列。</li>
</ol>
<p><img src="/archives/78985d23/image-20211123141324574.png" alt="小顶堆"></p>
<p>将上图小顶堆中的节点按照层次从上到下从左到右依次编号，并将节点映射到数组中即可得到下面结果</p>
<p><img src="/archives/78985d23/image-20211123141618611.png" alt="小顶堆结果映射结果"></p>
<p>观察小顶堆树结构以及映射的数组结果，可以得到以下公式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小顶堆： arr[i] &lt;= arr[2i + <span class="number">1</span>] &amp;&amp; arr[i] &lt;= arr[2i + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>同理，大顶堆也可以得到一个公式来描述节点关系</p>
<p><img src="/archives/78985d23/image-20211123142142863.png" alt="大顶堆"></p>
<p>将上图小顶堆中的节点按照层次从上到下从左到右依次编号，并将节点映射到数组中即可得到下面结果</p>
<p><img src="/archives/78985d23/image-20211123142220147.png" alt="大顶堆节点映射结果"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">大顶堆： arr[i] &gt;= arr[2i + <span class="number">1</span>] &amp;&amp; arr[i] &gt;= arr[2i + <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="堆排序算法步骤"><a href="#堆排序算法步骤" class="headerlink" title="堆排序算法步骤"></a>堆排序算法步骤</h2><ol>
<li>创建一个堆H[0……n-1];</li>
<li>把堆顶(最大值)和堆尾交换</li>
<li>把堆的尾索引缩小1，并重新堆化，目的是把交换到堆顶的节点放在相应的正确的位置，史整个堆树满足大(小)顶堆的特性。</li>
<li>重复步骤2，直到堆的尾索引为0</li>
</ol>
<p><strong>步骤一：</strong> 构建初始堆树，这里我们构建大顶堆，用来升序排列。</p>
<p>1、假如有一个无序的数列结构，如下：</p>
<p><img src="/archives/78985d23/image-20211123154521031.png" alt="无序数列结构"></p>
<p>2、从最后一个非叶子结点开始调整(第一个非叶子结点：arr.length / 2 - 1 = 15/2-1 = 6，也就是46这个节点) ，从左到右，从下到上进行调整</p>
<p><img src="/archives/78985d23/image-20211123154827731.png" alt="从第一个非叶子结点开始调整"></p>
<p>3、找到第二个非叶子结点65，因为在[65,31,77]中，77最大，所以这里65和77交换</p>
<p><img src="/archives/78985d23/image-20211123155001476.png" alt="调整第二个非叶子结点"></p>
<p>4、找到第三个非叶子结点35，因为在[35,30,20]中，35最大，所以这里不做交换</p>
<p><img src="/archives/78985d23/image-20211123155121520.png" alt="调整第三个非叶子结点"></p>
<p>5、找到第四个非叶子结点13，因为在[13,65,10]中，65最大，所以这里13和65做交换</p>
<p><img src="/archives/78985d23/image-20211123155230100.png" alt="调整第四个非叶子结点"></p>
<p>6、找到第五个非叶子结点96，因为在[96,77,81]中，96最大，所以这里不做交换</p>
<p><img src="/archives/78985d23/image-20211123155323547.png" alt="调整第五个非叶子结点"></p>
<p>7、找到第六个非叶子结点60，因为在[60,65,35]中，65最大，所以这里60和65做交换</p>
<p><img src="/archives/78985d23/image-20211123155426133.png" alt="调整第六个非叶子结点"></p>
<p>8、找到第七个非叶子结点91，因为在[91,65,96]中，96最大，所以这里91和96做交换</p>
<p><img src="/archives/78985d23/image-20211123155510196.png" alt="调整第七个非叶子结点"></p>
<p><strong>步骤二：</strong> 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换</p>
<p>1、将堆顶元素96和末尾元素22进行交换</p>
<p><img src="/archives/78985d23/image-20211123173538328.png" alt="交换堆顶和堆尾元素"></p>
<p>2、重新调整堆树，使其继续满足堆定义</p>
<p><img src="/archives/78985d23/%E5%A0%86%E6%A0%91%E7%BB%93%E6%9E%84%E8%B0%83%E6%95%B4.png" alt="重新调整堆树，使其满足堆定义"></p>
<p>3、重复以上步骤，可以得到最终的堆树结构如图所示</p>
<p><img src="/archives/78985d23/image-20211123174146485.png" alt="最终堆排序树结构"></p>
<h2 id="动态图演示"><a href="#动态图演示" class="headerlink" title="动态图演示"></a>动态图演示</h2><p><img src="/archives/78985d23/heapSort.gif" alt="堆排序动态图1"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建大顶堆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 构建堆的开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 构建堆的结束位置 防止重复建堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxTopHeap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = start;</span><br><span class="line">        <span class="comment">// 下标是从0开始就加1，否则就不需要加1</span></span><br><span class="line">        <span class="keyword">int</span> son = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(son &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 比较左右节点的大小</span></span><br><span class="line">            <span class="keyword">int</span> temp = son;</span><br><span class="line">            <span class="comment">// 表示右节点比左节点大</span></span><br><span class="line">            <span class="keyword">if</span> (son + <span class="number">1</span> &lt; end &amp;&amp; data[son] &lt; data[son + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 要交换父节点和右节点</span></span><br><span class="line">                temp = son + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不用交换</span></span><br><span class="line">            <span class="keyword">if</span> (data[parent] &gt; data[temp]) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                <span class="keyword">int</span> tmp = data[parent];</span><br><span class="line">                data[parent] = data[temp];</span><br><span class="line">                data[temp] = tmp;</span><br><span class="line">                <span class="comment">// 继续堆化</span></span><br><span class="line">                parent = temp;</span><br><span class="line">                son = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.length;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * i = length / 2 - 1 怎么来的？</span></span><br><span class="line"><span class="comment">         * 在完全二叉树中，第一个非叶子结点其实就是最后一个叶子节点的父节点。</span></span><br><span class="line"><span class="comment">         * 假设节点的索引值为i，则其左子叶索引值为2i + 1; 右子叶索引值为2i + 2;</span></span><br><span class="line"><span class="comment">         * 因为最后一个叶子节点的索引值是n - 1，所以他的父节点索引为((n - 1) - 1) / 2 即n/2 - 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            maxTopHeap(data,i,length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[<span class="number">0</span>];</span><br><span class="line">            data[<span class="number">0</span>] = data[i];</span><br><span class="line">            data[i] = temp;</span><br><span class="line">            maxTopHeap(data,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——希尔排序</title>
    <url>/archives/41c4cd29/</url>
    <content><![CDATA[<h2 id="基本排序思想"><a href="#基本排序思想" class="headerlink" title="基本排序思想"></a>基本排序思想</h2><p>算法先将要排序的一组数组按某个增量d分成若干组，每组中记录的下标相差d。对每组中全部元素进行排序，然后再用一个比较小的增量对他进行分组，在每组中再进行排序。当增量减到1时，整个要排序的数被分成了一组，排序完成。</p>
<p>例如：</p>
<blockquote>
<p>假设待排序数组为：[49,38,65,97,76,13,27,49,55,04]</p>
<p>增量序列的取值一次为</p>
<p>5，2，1</p>
</blockquote>
<p>在排序过程中，由于希尔算法需要多次排序，所以该算法排序是<strong>不稳定的</strong></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data =  &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        shellSort(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔排序&quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.length;</span><br><span class="line">        <span class="comment">// 决定比较间隔</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length/<span class="number">2</span>; i&gt;<span class="number">0</span>; i/=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据比较间隔将数组分成若干个子数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="comment">// 对若干个子数组进行插入排序</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &gt;=i &amp;&amp; data[k] &lt; data[k-i] ; k-=i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = data[k];</span><br><span class="line">                    data[k] = data[k-i];</span><br><span class="line">                    data[k-i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行以上代码结果如下：</p>
<p><img src="/archives/41c4cd29/image-20211106125559680.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——归并排序</title>
    <url>/archives/4e99e3ae/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>把一个序列切分成左右两个子序列，然后分别再切分左右两个子序列，一次切分下去，直到每个序列不能再切分为止，也就是只剩一个元素。这是一个递归的过程。然后将每个子序列排序合并，最后合并成一个完整的有序的序列。</p>
<p>图解如下：</p>
<p><img src="/archives/4e99e3ae/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3.png" alt="归并排序图解"></p>
<p>归并过程如下动态图：</p>
<p><img src="/archives/4e99e3ae/mergeSort.gif" alt="归并排序流程"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rextester</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		  <span class="keyword">int</span>[] data = &#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		  mergeSort(data,<span class="number">0</span>,data.length - <span class="number">1</span>);</span><br><span class="line">		  System.out.println(<span class="string">&quot;归并排序结果：&quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 归并排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data 数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left 数组起始位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 数组结束位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">			<span class="comment">// 将数组从中间切分成左右两个子数组</span></span><br><span class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">			<span class="comment">// 递归切分左边子数组</span></span><br><span class="line">			mergeSort(data, left, mid);</span><br><span class="line">			<span class="comment">// 递归切分右边子数组</span></span><br><span class="line">			mergeSort(data, mid+<span class="number">1</span>, right);</span><br><span class="line">			<span class="comment">// 开始将切分的子数组排序合并</span></span><br><span class="line">			merge(data, left, mid, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对子数组进行合并排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data 数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left 数组起始位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid 数组中间位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 数组结束位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">		<span class="comment">// 左边子数组开始位置</span></span><br><span class="line">		<span class="keyword">int</span> leftPointer = left;</span><br><span class="line">		<span class="comment">// 右边子数组开始位置</span></span><br><span class="line">		<span class="keyword">int</span> rightPointer = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 临时数组的游标指针，起始位置为left</span></span><br><span class="line">		<span class="keyword">int</span> loc = left;</span><br><span class="line">		<span class="keyword">while</span>(leftPointer &lt;= mid &amp;&amp; rightPointer &lt;= right) &#123;</span><br><span class="line">			<span class="keyword">if</span>(data[leftPointer] &lt; data[rightPointer]) &#123;</span><br><span class="line">				<span class="comment">// 如果左边的数小于右边的数，就将左边小的数放入到临时数组中</span></span><br><span class="line">				<span class="comment">// 并且将loc++,leftPointer++</span></span><br><span class="line">				tmp[loc++] = data[leftPointer++];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果左边的数大于等于右边的数，就将右边的数放入到临时数组中</span></span><br><span class="line">				<span class="comment">// 并且将loc++,rightPointer++</span></span><br><span class="line">				tmp[loc++] = data[rightPointer++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将左边没有放入临时数组的数放入到临时数组中</span></span><br><span class="line">		<span class="keyword">while</span>(leftPointer &lt;= mid) &#123;</span><br><span class="line">			tmp[loc++] = data[leftPointer++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将右边没有放入临时数组的数放入到临时数组中</span></span><br><span class="line">		<span class="keyword">while</span>(rightPointer &lt;= right) &#123;</span><br><span class="line">			tmp[loc++] = data[rightPointer++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将临时数组中排好序的元素放到data中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">			data[i] = tmp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul>
<li><strong>时间复杂度：O(nLogn)</strong></li>
<li><strong>空间复杂度：T(N)</strong> ，归并排序过程中创建了一个与原来数组一样大小的临时数组。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——快速排序</title>
    <url>/archives/a4803490/</url>
    <content><![CDATA[<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>从数列中挑选一个元素，一般情况下我们是取的数列第一个元素。这个取到的元素成为“基准数”(pivot)；</li>
<li>从数列尾部开始往头部找比基准数小的数，将小的数与基准数做位置调换；</li>
<li>从数列头部开始往尾部找比基准数大的数，将大的数与基准数做位置调换；</li>
<li>当步骤2与步骤3执行完毕之后，基准数就处于了数列的中间位置，这时基准数左边的子数列中所有元素都是小于基准数；基准数右边的子数列中的所有元素都是大于基准数；这个过程称为分区操作；</li>
<li>递归地把基准数左边数列和基准数右边数列排序；</li>
</ol>
<h2 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h2><p>现有如下数列：data={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48}，我们对这个数列使用快排。</p>
<p>定义一个基数：<code>pivot = 3</code><br>一个查询左边的元素的指针: <code>leftPointer</code>，起初 <code>leftPointer = 0</code><br>一个查询右边的元素指针: <code>rightPointer</code> , 起初<code>rightPointer = data.length - 1 </code></p>
<p><img src="/archives/a4803490/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="快排算法过程"></p>
<h2 id="动态图演示"><a href="#动态图演示" class="headerlink" title="动态图演示"></a>动态图演示</h2><p><img src="/archives/a4803490/quickSort.gif" alt="快排动态图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rextester</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		  <span class="keyword">int</span>[] data = &#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		  qSort(data,<span class="number">0</span>,data.length - <span class="number">1</span>);</span><br><span class="line">		  System.out.println(Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 基准数</span></span><br><span class="line">		<span class="keyword">int</span> base = data[left];</span><br><span class="line">		<span class="comment">// 向后移动的指针</span></span><br><span class="line">		<span class="keyword">int</span> leftPointer = left;</span><br><span class="line">		<span class="comment">// 向前移动的指针</span></span><br><span class="line">		<span class="keyword">int</span> rightPointer = right;</span><br><span class="line">		<span class="comment">// 如果left和right不想等，说明没有循环完毕,继续循环</span></span><br><span class="line">		<span class="keyword">while</span>(leftPointer &lt; rightPointer) &#123;</span><br><span class="line">			<span class="comment">// 从后往前找比基准数小的数</span></span><br><span class="line">			<span class="keyword">while</span>(leftPointer &lt; rightPointer &amp;&amp; data[rightPointer] &gt;= base) &#123;</span><br><span class="line">				rightPointer--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 说明找到了</span></span><br><span class="line">			<span class="keyword">if</span>(leftPointer &lt; rightPointer) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = data[rightPointer];</span><br><span class="line">				data[rightPointer] = data[leftPointer];</span><br><span class="line">				data[leftPointer] = temp;</span><br><span class="line">				leftPointer++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 从前往后找比基准数大的数</span></span><br><span class="line">			<span class="keyword">while</span>(leftPointer &lt; rightPointer &amp;&amp; data[leftPointer] &lt;= base) &#123;</span><br><span class="line">				leftPointer++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果找到了就交换位置</span></span><br><span class="line">			<span class="keyword">if</span>(leftPointer &lt; rightPointer) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = data[leftPointer];</span><br><span class="line">				data[leftPointer] = data[rightPointer];</span><br><span class="line">				data[rightPointer] = temp;</span><br><span class="line">				rightPointer--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将数组分成三部分，左，基准数，右，</span></span><br><span class="line">		<span class="keyword">if</span>(left &lt; leftPointer) &#123;</span><br><span class="line">			qSort(data,left,leftPointer - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rightPointer &lt; right) &#123;</span><br><span class="line">			qSort(data,rightPointer + <span class="number">1</span>,right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>当基准数选择的是数列中做小或者做大的数时，快速排序的运行情况最坏是O(n²)，如果说基准数取得比较好，或者数列中有很多已经是排好序的数列了，这时快速排序的平均复杂度降为了O(nlogn)；</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这里可以中间放在优化基准数，怎么取基准数可以合适。比如：</p>
<ol>
<li>三数据中取基准数</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——插入排序</title>
    <url>/archives/cd5503e2/</url>
    <content><![CDATA[<p>题目：将该数组<code>int[] data = &#123;8,5,7,4,1,3,2&#125;</code>进行排序，要求手写插入排序进行实现。</p>
<blockquote>
<p><strong>插入排序整体思想：</strong><br>  将一个数组分成已排序和未排序两个部分，每次都从未排序的部分中取出一个数(b)，和已排序部分中的每个元素(arr[i])去<br>  做比较，如果在已排序部分中找到一个数小于从未排序中拿出来的那个数(arr[i]&lt;b)，就停止比较，将未排序部分取出来的<br>  数插入到已排序部分比较小的元素后面(arr[i+1] = b)；每次从未排序部分取一个数都重复上面步骤，直到排序完成。<br><strong>注意：</strong>未排序数字和已排序部分在作比较的时候，最好是从已排序部分的尾部开始比较，依次往头部进行。这样做的好处就是可以保证<br>元素之间的相对位置不会改变，同时在比较的时候同步可以向后移动数组元素，为即将插入的数字预留空间。降低时间复杂度</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: netty-chat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-11-03 12:15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序整体思想：</span></span><br><span class="line"><span class="comment">     *   将一个数组分成已排序和未排序两个部分，每次都从未排序的部分中取出一个数(b)，和已排序部分中的每个元素(arr[i])去</span></span><br><span class="line"><span class="comment">     *   做比较，如果在已排序部分中找到一个数小于从未排序中拿出来的那个数(arr[i]&lt;b)，就停止比较，将未排序部分取出来的</span></span><br><span class="line"><span class="comment">     *   数插入到已排序部分比较小的元素后面(arr[i+1] = b)；每次从未排序部分取一个数都重复上面步骤，直到排序完成。</span></span><br><span class="line"><span class="comment">     * 注意：未排序数字和已排序部分在作比较的时候，最好是从已排序部分的尾部开始比较，依次往头部进行。这样做的好处就是可以保证</span></span><br><span class="line"><span class="comment">     * 元素之间的相对位置不会改变，同时在比较的时候同步可以向后移动数组元素，为即将插入的数字预留空间。降低时间复杂度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里有两层循环</span></span><br><span class="line">            <span class="comment">// 时间复杂度最坏是: O(n²)-----每次都会执行第二次循环中的if语句</span></span><br><span class="line">            <span class="comment">// 时间复杂度最好是: O(n)------即每次都执行第二次循环的break</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> data = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (data &lt; arr[j]) &#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>] = data;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入排序第二种写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;<span class="number">0</span> &amp;&amp; data[j] &lt; data[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = data[j];</span><br><span class="line">                data[j] = data[j-<span class="number">1</span>];</span><br><span class="line">                data[j-<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = insertSort(data);</span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/archives/cd5503e2/image-20211103124225442.png" alt="排序运行结果"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——计数排序</title>
    <url>/archives/90620757/</url>
    <content><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>开辟一个临时数组</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ol>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/archives/90620757/countingSort.gif" alt="计数排序演示"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rextester</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">	   <span class="keyword">int</span>[] data = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		 countingSort(data);</span><br><span class="line">	   System.out.println(Arrays.toString(data));</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; data.length; i++) &#123;</span><br><span class="line">			temp[data[i]] = temp[data[i]]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(temp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				temp[i] -= <span class="number">1</span>;</span><br><span class="line">				data[idx++] = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法——选择排序</title>
    <url>/archives/18d056c9/</url>
    <content><![CDATA[<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>首先再未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。一次类推，直到所有的元素都排序完成。</p>
<h2 id="动态图演示"><a href="#动态图演示" class="headerlink" title="动态图演示"></a>动态图演示</h2><p><img src="/archives/18d056c9/selectionSort.gif" alt="选择排序演示图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rextester</span></span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		  <span class="keyword">int</span>[] data = &#123;<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>&#125;;</span><br><span class="line">		  selectSort(data);</span><br><span class="line">		  System.out.println(<span class="string">&quot;选择排序后的结果: &quot;</span> + Arrays.toString(data));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 选择排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> data 待排序序列</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		   <span class="comment">// 交换次数</span></span><br><span class="line">		   <span class="comment">// 先假设每次循环时，最小索引为i</span></span><br><span class="line">			<span class="keyword">int</span> minIndex = i;</span><br><span class="line">			<span class="comment">// 每个元素都和剩下的未排序的元素比较</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; data.length; j++) &#123;</span><br><span class="line">				<span class="comment">// 寻找最小索引</span></span><br><span class="line">				<span class="keyword">if</span>(data[j] &lt; data[minIndex]) &#123;</span><br><span class="line">					<span class="comment">// 将最小索引保存起来</span></span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 经过一轮循环，可以找到最小索引，将最小索引对应的元素放到i的位置</span></span><br><span class="line">			swap(data,i,minIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 交换元素</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 排序序列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 交换元素的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> minIndex 最小元素索引</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> minIndex)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = data[i];</span><br><span class="line">		data[i] = data[minIndex];</span><br><span class="line">		data[minIndex] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul>
<li><strong>时间复杂度：O(n²)</strong> </li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>规则引擎Drools快速入门</title>
    <url>/archives/bc098de5/</url>
    <content><![CDATA[<h1 id="规则引擎简介"><a href="#规则引擎简介" class="headerlink" title="规则引擎简介"></a><strong>规则引擎简介</strong></h1><p><strong>规则引擎</strong>，全称为<strong>业务规则管理系统</strong>，英文名为BRMS(即Business Rule Management System)。规则引擎实现了将业务决策从应用程序中分离出来，接收数据的输入，解释业务规则，并根据业务规则做出业务决策。规则引擎就是这样一个输入输出平台。现在比较流行的规则引擎之一为Drools，一款由JBoss组织提供的基于Java语言开发的开源规则引擎，Drools是KIE项目的一部分，Kie：Knowledge is everything, Jboss一些列项目的总称。</p>
<h2 id="规则引擎主要的应用场景"><a href="#规则引擎主要的应用场景" class="headerlink" title="规则引擎主要的应用场景"></a>规则引擎主要的应用场景</h2><p>对于一些比较复杂的业务规则并且业务规则可能频繁的变动的系统比较合适使用规则引擎，如下：</p>
<ol>
<li>风险控制系统——风险贷款、风险评估</li>
<li>反欺诈项目——银行贷款、征信验证</li>
<li>决策平台系统——财务计算</li>
<li>促销平台系统——满减、打折、加价购</li>
</ol>
<h2 id="Drools介绍"><a href="#Drools介绍" class="headerlink" title="Drools介绍"></a>Drools介绍</h2><p>drools是一款由JBoos组织提供的基于Java语言开发的开源规则引擎，可以将复杂的业务规则从硬编码中剥离出来，以规则脚本的形式放在文件或者特定的存储介质中（例如数据库中），使得业务规则的变更不需要修改项目代码、不用重启服务器就可以在线上环境立即生效。</p>
<p><a href="https://drools.org/">drools官网地址</a></p>
<p><a href="https://github.com/kiegroup/drools">drools源码下载地址</a></p>
<ul>
<li>使用规则引擎有哪些优势：<ul>
<li>业务规则与系统代码分离，实现业务规则的集中管理</li>
<li>在不重启服务的情况下可以随时对业务规则进行扩展和维护</li>
<li>可以动态修改业务规则，从而快速响应需求变更</li>
<li>规则引擎是相对独立的，只关心业务规则，是的业务分析人员也可以参与编辑、维护系统的业务规则</li>
<li>减少硬编码业务规则的成本和风险</li>
<li>使用规则引擎提供的规则编辑工具，使复杂的业务规则变得简单</li>
</ul>
</li>
</ul>
<p>在项目中使用drools时，既可以单独使用也可以整合springboot使用。如果单独使用需要导入如下maven坐标即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们使用IDEA开发drools应用，IDEA中已经集成了drools插件。</p>
<p>drools API开发步骤如下</p>
<p><img src="/archives/bc098de5/image-20220707224445150.png" alt="drools开发步骤"></p>
<h2 id="Drools快速入门"><a href="#Drools快速入门" class="headerlink" title="Drools快速入门"></a>Drools快速入门</h2><h3 id="业务场景说明"><a href="#业务场景说明" class="headerlink" title="业务场景说明"></a>业务场景说明</h3><p>用户购买的商品总额和对应的积分赠送规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100元以下，不加积分</span><br><span class="line">100元~500元，加100积分</span><br><span class="line">500元~1000元，加500积分</span><br><span class="line">1000元以上，加1000积分</span><br></pre></td></tr></table></figure>

<h3 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h3><p>第一步：创建maven工程droolsDemo并导入相关maven坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.drools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>drools-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.10.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：在工程中的resources下创建META-INF文件夹，并在文件夹下创建kmodule.xml配置文件，配置文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kmodule</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.drools.org/xsd/kmodule&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        name:指定kbase的名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">        packages:指定规则文件的目录，需要根据实际情况填写，否则无法加载到规则文件</span></span><br><span class="line"><span class="comment">        default:指定当前kbase是否为默认</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kbase</span> <span class="attr">name</span>=<span class="string">&quot;myKbase1&quot;</span> <span class="attr">packages</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            name:指定ksession名称，可以任意，但是需要唯一</span></span><br><span class="line"><span class="comment">            default:指定当前session是否为默认</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ksession</span> <span class="attr">name</span>=<span class="string">&quot;ksession-rule&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kbase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kmodule</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong> 上面配置文件的名称和位置都是固定写法，不能更改</p>
<p>kmodule 中可以包含一个到多个kbase，分别对应drl的规则文件</p>
<p>kbase 需要一个唯一的name，可以去任意字符串</p>
<p>packages 为drl文件所在的resource目录下的路径。(注意区分drl文件中的package与此处的package不一定相同。多个包用逗号分隔。默认情况下会扫描resources目录及子目录下所有规则文件)</p>
<p>kbase的default属性，表示当前KieBase是不是默认的，如果时默认的规则不用名称就可以查找到该KieBase，但每个module最多只能有一个默认KieBase</p>
<p>kbase下面可以有一个或者多个ksession，ksession的name属性必须设置，且必须唯一</p>
</blockquote>
<p>第三步：创建实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 订单原价 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amout;</span><br><span class="line">    <span class="comment">/** 积分 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAmout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAmout</span><span class="params">(<span class="keyword">int</span> amout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amout = amout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;amout=&quot;</span> + amout +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第四步：在resources下创建rules目录，并且添加规则文件score-rules.drl</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package rules</span><br><span class="line"></span><br><span class="line">import com.lhb.entity.Order</span><br><span class="line"></span><br><span class="line">//规则1：100元以下, 不加分</span><br><span class="line">rule &quot;score_1&quot;</span><br><span class="line">    when</span><br><span class="line">        $s : Order(amout &lt;= 100)</span><br><span class="line">    then</span><br><span class="line">        $s.setScore(0);</span><br><span class="line">        System.out.println(&quot;成功匹配到规则1：100元以下, 不加分 &quot;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//规则2：100元-500元 加100分</span><br><span class="line">rule &quot;score_2&quot;</span><br><span class="line">    when</span><br><span class="line">        $s : Order(amout &gt; 100 &amp;&amp; amout &lt;= 500)</span><br><span class="line">    then</span><br><span class="line">        $s.setScore(100);</span><br><span class="line">        System.out.println(&quot;成功匹配到规则2：100元-500元 加100分 &quot;);</span><br><span class="line">end</span><br><span class="line">//规则3：500元-1000元 加500分</span><br><span class="line">rule &quot;score_3&quot;</span><br><span class="line">    when</span><br><span class="line">        $s : Order(amout &gt; 500 &amp;&amp; amout &lt;= 1000)</span><br><span class="line">    then</span><br><span class="line">        $s.setScore(500);</span><br><span class="line">        System.out.println(&quot;成功匹配到规则3：500元-1000元 加500分 &quot;);</span><br><span class="line">end</span><br><span class="line">//规则4：1000元 以上 加1000分</span><br><span class="line">rule &quot;score_4&quot;</span><br><span class="line">    when</span><br><span class="line">        $s : Order(amout &gt; 1000)</span><br><span class="line">    then</span><br><span class="line">        $s.setScore(1000);</span><br><span class="line">        System.out.println(&quot;成功匹配到规则4：1000元 以上 加1000分 &quot;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个规则文件就是描述了，当符合条件的时侯，做什么事情，每当规则有变动的时候，我们只需要修改规则文件，然后重新加载即可</p>
<p>第五步：编写单元测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lhb.entity.Order;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.KieServices;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieContainer;</span><br><span class="line"><span class="keyword">import</span> org.kie.api.runtime.KieSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDrools</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        KieServices kieServices = KieServices.Factory.get();</span><br><span class="line">        KieContainer kieContainer = kieServices.getKieClasspathContainer();</span><br><span class="line">        <span class="comment">//会话对象,用于和规则引擎交互</span></span><br><span class="line">        KieSession kieSession = kieContainer.newKieSession();</span><br><span class="line">        <span class="comment">//构造订单对象，设置订单金额，由规则引擎计算获得的积分</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setAmout(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据交给规则引擎，规则引擎会根据提供的数据进行规则匹配</span></span><br><span class="line">        kieSession.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//激活规则引擎，如果匹配成功则执行规则</span></span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        <span class="comment">//关闭会话</span></span><br><span class="line">        kieSession.dispose();</span><br><span class="line">        <span class="comment">//打印结果;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单提交之后积分：&quot;</span>+order.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="规则引擎构成"><a href="#规则引擎构成" class="headerlink" title="规则引擎构成"></a>规则引擎构成</h2><p>drools规则引擎由以下三个部分构成：</p>
<ul>
<li>Working Memory（工作内存）</li>
<li>Rule Base（规则库）</li>
<li>Inference Engine（推理引擎），其中推理引擎又包括以下部分：<ul>
<li>Pattern Matcher（匹配器）具体匹配哪个规则，由这一个来完成</li>
<li>Agenda（议程）</li>
<li>Execution Engine（执行引擎）</li>
</ul>
</li>
</ul>
<p>如下图</p>
<p><img src="/archives/bc098de5/image-20220708215409773.png" alt="image-20220708215409773"></p>
<h3 id="相关概念说明"><a href="#相关概念说明" class="headerlink" title="相关概念说明"></a>相关概念说明</h3><p><strong>Working Memory：</strong> 工作内存，drools规则引擎会从Working Memory中获取数据并和规则文件中定义的规则进行模式匹配，所以我们开发的应用程序只需要将我们的数据插入到Working Memory中即可，例如上面案例中，调用kieSession.insert(order)就是将order对象插入到了工作内存中。</p>
<p><strong>Fact：</strong> 事实，是指在drools规则应用当中，将一个普通的JavaBean插入到Working Memory后的对象就是Fact对象，例如上面案例中的Order对象就是输入Fact对象。Fact对象时我们的应用和规则引擎进行数据交互的桥梁或通道。</p>
<p><strong>Rule Base：</strong> 规则库，我们在规则文件中定义的规则都会被加载到规则库中</p>
<p><strong>Pattern Matcher：</strong> 匹配器，将Rule Base中的所有规则与Working Memory中的Fact对象进行模式匹配，匹配成功的规则将被激活并放入Agenda中。</p>
<p><strong>Agenda：</strong> 议程，用于存放通过匹配器进行模式匹配后被激活的规则。</p>
<p><strong>Execution Engine：</strong> 执行引擎，执行Agenda中被激活的规则</p>
<h3 id="规则引擎执行过程"><a href="#规则引擎执行过程" class="headerlink" title="规则引擎执行过程"></a>规则引擎执行过程</h3><p><img src="/archives/bc098de5/image-20220708221305352.png" alt="规则引擎执行过程"></p>
]]></content>
      <categories>
        <category>规则引擎</category>
      </categories>
      <tags>
        <tag>Drools</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/archives/ccff2b22/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是Java中最常用的设计模式之一。在我们悉知的Spring中源码中的bean创建就是使用了工厂模式；这种类型的设计模式属于创建型模式，他提供一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>日志记录器：记录磁盘信息、业务事件、访问服务器信息等，让用户来选择日志记录到哪里。</li>
<li>连接服务器使用不同的协议，<code>POP3</code>、<code>IMAP</code>、<code>HTTP</code>三个协议可以用同一个接口来实现。</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>当一个调用者想创建对象时，只需要知道对象名字即可</li>
<li>扩展性高，如果需要增加新的类品，只需要新增一个工厂类即可</li>
<li>隐藏产品的具体实现，让调用者只关心接口</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>每次新增一个产品都需要新增一个产品工厂类，增加了系统复杂度。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>工厂模式在Spring源码中的应用解析：</p>
<p>我们知道在Spring中，如果我们想要通过容器去创建一个bean就需要调用一下代码来实现bean创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br><span class="line">TestIOCImpl bean = applicationContext.getBean(TestIOCImpl.class);</span><br></pre></td></tr></table></figure>

<p>其实<code>ApplicationContext</code>创建bean就是使用到了工厂模式。在上面的代码中，我们并没有显式的通过<code>new</code>去创建一个<code>TestIOCImpl</code>,通过调用<code>applicationContext.getBean()</code>传入一个bean的class来实例化；具体创建过程则交给了<code>ApplicationContext</code>去实现了。</p>
<p>首先来看看<code>ApplicationContext</code>整体的继承关系，也就是工厂模式的继承关系</p>
<p><img src="/archives/ccff2b22/image-20210810151313670.png" alt="ApplicationContext.java"></p>
<p><code>ApplicationContext</code>接口继承了一个最顶层的工厂类<code>BeanFactory</code>，来继续看看<code>BeanFactory</code>中有些什么方法呢。</p>
<p><img src="/archives/ccff2b22/image-20210810151723712.png" alt="BeanFactory.java"></p>
<p>看到这里是不是就会有点想法，我们在上面的代码中调用的<code>getBean(Class class)</code>是不是就是调用的这里的方法呢？具体实现那肯定就是在子类中去实现的喽。因为我们一开始的代码是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationMain.class);</span><br></pre></td></tr></table></figure>

<p>创建的<code>ApplicationContext</code>接口实现类其实是<code>AnnotationConfigApplicationContext</code>类型，那么在<code>AnnotationConfigApplicationContext</code>类中是不是也实现了<code>getBean</code>的一些方法？实际上spring并没有在<code>AnnotationConfigApplicationContext</code>中去实现这些方法，而是通过一个抽象类<code>AbstractApplicationContext</code>来实现了<code>ApplicationContext</code>接口中的<code>getBean</code>一系列方法。这样做的目的也是为了提高后期的扩展性，毕竟spring这么强大，扩展性肯定是必须要很强的。</p>
<p><img src="/archives/ccff2b22/image-20210810152406751.png" alt="AnnotationConfigApplicationContext.java关系图"></p>
<p><code>AbstractApplicationContext</code>中实现<code>getBean</code>系列方法的代码：</p>
<p><img src="/archives/ccff2b22/image-20210810153412546.png" alt="getBean(...)代码实现"></p>
<p>以上就是在Spring中创建Bean所用到的工厂设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法——会议安排问题</title>
    <url>/archives/dc110695/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>公司有N个同等级的会议需要使用同一个会议室，现在给你这个N个会议的开始和结束时间，怎么安排才能找到一个解决方案，使得会议室最大利用？</p>
<blockquote>
<p>样例：</p>
<p>4<br>0 9<br>8 10<br>10 12<br>8 20<br>Metting{mettingNum=1, startTime=0, endTime=9}<br>Metting{mettingNum=3, startTime=10, endTime=12}</p>
</blockquote>
<p>第一行表示N个会议，下面四行表示会议开始时间和结束时间，最后输出会议安排结果。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 贪心算法</span></span><br><span class="line"><span class="comment"> * 公司有N个同等级的会议需要使用同一个会议室，现在给你这个N个会议的开始和结束时间，怎么安排才能找到一个解决方案，使得会议室最大利用？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreedAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Metting</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Metting</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mettingNum;</span><br><span class="line">        <span class="keyword">int</span> startTime;</span><br><span class="line">        <span class="keyword">int</span> endTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Metting</span><span class="params">(<span class="keyword">int</span> mettingNum, <span class="keyword">int</span> startTime, <span class="keyword">int</span> endTime)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.mettingNum = mettingNum;</span><br><span class="line">            <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">            <span class="keyword">this</span>.endTime = endTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Metting&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;mettingNum=&quot;</span> + mettingNum +</span><br><span class="line">                    <span class="string">&quot;, startTime=&quot;</span> + startTime +</span><br><span class="line">                    <span class="string">&quot;, endTime=&quot;</span> + endTime +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Metting o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.endTime &gt; o.endTime) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4</span></span><br><span class="line"><span class="comment">     * 0 9</span></span><br><span class="line"><span class="comment">     * 8 10</span></span><br><span class="line"><span class="comment">     * 10 12</span></span><br><span class="line"><span class="comment">     * 8 20</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        List&lt;Metting&gt; mettings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> end = scanner.nextInt();</span><br><span class="line">            Metting metting = <span class="keyword">new</span> Metting(i + <span class="number">1</span>, start, end);</span><br><span class="line">            mettings.add(metting);</span><br><span class="line">        &#125;</span><br><span class="line">        mettings.sort(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> curTime = <span class="number">0</span>; <span class="comment">// 从0点开始可以开会</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Metting metting = mettings.get(i);</span><br><span class="line">            <span class="keyword">if</span> (metting.startTime &gt;= curTime) &#123; <span class="comment">// 如果会议的开始时间大于当前时间，表示可以开会</span></span><br><span class="line">                System.out.println(metting.toString());</span><br><span class="line">                curTime = metting.endTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络IO与Epoll模型</title>
    <url>/archives/3449cc56/</url>
    <content><![CDATA[<h1 id="IO网络模型"><a href="#IO网络模型" class="headerlink" title="IO网络模型"></a>IO网络模型</h1><p>在Java中支持3种网络编程IO模式：</p>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>AIO</li>
</ul>
<h2 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h2><p>同步阻塞模型，一个客户端连接对应一个处理线程</p>
<p><img src="/archives/3449cc56/BIO%E6%A8%A1%E5%9E%8B.png" alt="BIO同步阻塞模型"></p>
<p>BIO代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待连接。。&quot;</span>);</span><br><span class="line">            <span class="comment">//阻塞方法</span></span><br><span class="line">            Socket clientSocket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;有客户端连接了。。&quot;</span>);</span><br><span class="line">            handler(clientSocket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void run() &#123;</span></span><br><span class="line"><span class="comment">                    try &#123;</span></span><br><span class="line"><span class="comment">                        handler(clientSocket);</span></span><br><span class="line"><span class="comment">                    &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;).start();*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket clientSocket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;准备read。。&quot;</span>);</span><br><span class="line">        <span class="comment">//接收客户端的数据，阻塞方法，没有数据可读时就阻塞</span></span><br><span class="line">        <span class="keyword">int</span> read = clientSocket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;read完毕。。&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接收到客户端的数据：&quot;</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">        &#125;</span><br><span class="line">        clientSocket.getOutputStream().write(<span class="string">&quot;HelloClient&quot;</span>.getBytes());</span><br><span class="line">        clientSocket.getOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        <span class="comment">//向服务端发送数据</span></span><br><span class="line">        socket.getOutputStream().write(<span class="string">&quot;HelloServer&quot;</span>.getBytes());</span><br><span class="line">        socket.getOutputStream().flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;向服务端发送数据结束&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//接收服务端回传的数据</span></span><br><span class="line">        socket.getInputStream().read(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到服务端的数据：&quot;</span> + <span class="keyword">new</span> String(bytes));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>IO代码里read操作是阻塞操作，如果连接不做数据读写操作会导致线程阻塞，浪费资源</li>
<li>如果线程很多，会导致服务器线程太多，压力太大，比如C10K问题</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，但是程序简单易理解</p>
<h2 id="NIO-Non-Blocking-IO"><a href="#NIO-Non-Blocking-IO" class="headerlink" title="NIO(Non Blocking IO)"></a>NIO(Non Blocking IO)</h2><p>同步非阻塞模型，服务器实现模式为<strong>一个线程可以处理多个请求(连接)<strong>，，客户端发送的连接请求都会注册到</strong>多路复用器selector上</strong>，多路复用器轮询到连接有IO请求就进行处理，JDK1.4开始引入。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>NIO方式适用于连接数据多并且连接比较短(轻操作)的架构，比如聊天服务、弹幕系统、服务器间通讯。编程比较复杂</p>
<p>NIO非阻塞代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存客户端连接</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NIO ServerSocketChannel,与BIO的serverSocket类似</span></span><br><span class="line">        ServerSocketChannel serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 非阻塞模式accept方法不会阻塞，否则会阻塞</span></span><br><span class="line">            <span class="comment">// NIO的非阻塞是由操作系统内部实现的，底层调用了linux内核的accept函数</span></span><br><span class="line">            SocketChannel socketChannel = serverSocket.accept();</span><br><span class="line">            <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123; <span class="comment">// 如果有客户端进行连接</span></span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">                <span class="comment">// 设置SocketChannel为非阻塞</span></span><br><span class="line">                socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 保存客户端连接在List中</span></span><br><span class="line">                channelList.add(socketChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历连接进行数据读取</span></span><br><span class="line">            Iterator&lt;SocketChannel&gt; iterator = channelList.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SocketChannel sc = iterator.next();</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                <span class="comment">// 非阻塞模式read方法不会阻塞，否则会阻塞</span></span><br><span class="line">                <span class="keyword">int</span> len = sc.read(byteBuffer);</span><br><span class="line">                <span class="comment">// 如果有数据，把数据打印出来</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; <span class="comment">// 如果客户端断开，把socket从集合中去掉</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果连接太多的话，会有大量的无效遍历，加入有10000个连接，其中只有1000个连接有写数据，但是由于其他9000个连接并没有断开，我们还是要每次遍历一万次，其中有十分之九的遍历都是无效的，这显然不是一个好的方案</p>
</blockquote>
<p>NIO引入多路复用器代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioSelectorServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NIO ServerSocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocket = ServerSocketChannel.open();</span><br><span class="line">        serverSocket.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        <span class="comment">// 设置ServerSocketChannel为非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开Selector处理Channel，即创建epoll</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span></span><br><span class="line">        serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待需要处理的事件发生</span></span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取selector中注册的全部事件的 SelectionKey 实例</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历SelectionKey对事件进行处理</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">// 如果是OP_ACCEPT事件，则进行连接获取和事件注册</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                    SocketChannel socketChannel = server.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 这里只注册了读事件，如果需要给客户端发送数据可以注册写事件</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;  <span class="comment">// 如果是OP_READ事件，则进行读取和打印</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                    <span class="keyword">int</span> len = socketChannel.read(byteBuffer);</span><br><span class="line">                    <span class="comment">// 如果有数据，把数据打印出来</span></span><br><span class="line">                    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123; <span class="comment">// 如果客户端断开连接，关闭Socket</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从事件集合里删除本次处理的key，防止下次select重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO有三大核心组件：</p>
<ul>
<li><strong>Channel(通道)</strong></li>
<li><strong>Buffer(缓冲区)</strong></li>
<li><strong>Selector(多路复用器)</strong></li>
</ul>
<blockquote>
<ol>
<li>channel类似于流，每个channel对应一个buffer缓冲区，buffer底层就是数组</li>
<li>channel会注册到selector上，由selector根据channel读写事件的发生将其交由某个空闲的线程处理</li>
<li>NIO的Buffer和channel都是既可以读也可以写</li>
</ol>
</blockquote>
<p><img src="/archives/3449cc56/NIO%E6%A8%A1%E5%9E%8B.png" alt="NIO模型"></p>
<p>NIO底层在JDK1.4版本是用的Linux的内核函数select()或poll()来实现，跟上面的NIOServer代码类似，selector每次都会轮询所有的sockChannel看下那个channel有读写事件，有的话就处理，没有的话就继续遍历，JDK1.5开始引入了epoll()基于事件响应机制来优化NIO。</p>
<p>NIOSelectorServer代码里如下几个方法非常重要，我们从HotSpot与Linux内核函数级别来理解一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector.open();  <span class="comment">//创建多路复用器</span></span><br><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);  <span class="comment">//将channel注册到多路复用器上</span></span><br><span class="line">selector.select();  <span class="comment">//阻塞等待需要处理的事件发生</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/3449cc56/NIO%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81.png" alt="NIO底层源码"></p>
<blockquote>
<p>总结：NIO整个调用流程就是Java调用了操作系统的内核函数来创建Socket，获取Socket的文件描述符，再创建一个Selector对象，对应操作系统的Epoll描述符，将获取到的Socket连接的文件描述符的事件绑定到Selector对应的Epoll文件描述符上，进行事件的异步通知，这样就实现了使用一条线程，并且不需要太多的无效遍历，将事件处理交给了操作系统内核(操作系统中断程序实现)，大大提高了效率。</p>
</blockquote>
<h2 id="Epoll函数详解"><a href="#Epoll函数详解" class="headerlink" title="Epoll函数详解"></a>Epoll函数详解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>创建一个epoll实例，并返回一个非负数作为文件描述符，用于对epoll接口的所有后续调用。参数size代表可能会容纳size个描述符，但size不是一个最大值，只是提示操作系统他的数量级，现在这个参数基本已经废弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> op,<span class="keyword">int</span> fd,struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用文件描述符epfd引用的epoll实例，对目标文件描述符fd执行op操作。</p>
<p>参数epfd表示epoll对应的文件描述符，参数fd表示socket对应的文件描述符。</p>
<blockquote>
<p>参数op有以下几个值：</p>
<p>EPOLL_CTL_ADD: 注册新的fd到epfd中，并关联事件event； </p>
<p>EPOLL_CTL_MOD: 修改已经注册的fd的监听事件</p>
<p>EPOLL_CTL_DEL: 从epfd中移除fd，并且忽略掉绑定的event，这时event可以为null</p>
</blockquote>
<p>参数event是一个结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__unit32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">__unit32_t</span> u32;</span><br><span class="line">  <span class="keyword">__unit64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>events有很多可选值，这里列举几个常用的:</p>
<p>EPOLLIN: 表示对应的文件描述符是可读的</p>
<p>EPOLLOUT: 表示对应的文件描述符是可写的</p>
<p>EPOLLERR: 表示对应的文件描述符发生了错误；</p>
<p>成功返回0，失败返回-1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event *events,<span class="keyword">int</span> maxevents,<span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待文件描述符epfd上的事件。</p>
<p>epfd是Epoll对应的文件描述符，events表示调用者有可能用事件的集合，maxevents表示最多等到多少个事件就返回，timeout是超时时间。</p>
<p>I/O多路复用底层主要用的Linux内核函数(select,poll,epoll)来实现，windows不支持epoll实现，windows底层是基于winsock2的select函数实现的(不开源)</p>
<table style="width:100%;" cellpadding="2" cellspacing="0" align="center" border="1" bordercolor="#000000">
  <tbody>
      <tr bgcolor="#71bff6">
          <td style="text-align:center;">
         &emsp;
      </td>
        <td style="text-align:center;">
        <b>select</b>
      </td>
        <td style="text-align:center;">
        <b>poll</b>
      </td> 
        <td style="text-align:center;">
        <b>epoll(jdk 1.5及以上)</b>
      </td>
    </tr>
      <tr>
          <td bgcolor="#71bff6" style="text-align:center;">
         <b>操作方式</b>
      </td>
        <td style="text-align:center;">
        遍历
      </td>
        <td style="text-align:center;">
        遍历
      </td> 
        <td style="text-align:center;">
        回调
      </td>
    </tr>
      <tr>
          <td bgcolor="#71bff6" style="text-align:center;">
         <b>底层实现</b>
      </td>
        <td style="text-align:center;">
        数组
      </td>
        <td style="text-align:center;">
        链表
      </td> 
        <td style="text-align:center;">
        哈希表
      </td>
    </tr>
      <tr>
          <td bgcolor="#71bff6" style="text-align:center;">
         <b>IO效率</b>
      </td>
        <td style="text-align:center;">
        每次调用都进行线性遍历，时间复杂度为O(n)
      </td>
        <td style="text-align:center;">
        每次调用都进行线性遍历，时间复杂度为O(n)
      </td> 
        <td style="text-align:center;">
        事件通知方式，每当有IO事件就绪，系统注册的回调函数就会被调用，时间复杂度O(1)
      </td>
    </tr>
      <tr>
          <td bgcolor="#71bff6" style="text-align:center;">
         <b>最大连接</b>
      </td>
        <td style="text-align:center;">
        有上限
      </td>
        <td style="text-align:center;">
        无上限
      </td> 
        <td style="text-align:center;">
        无上限
      </td>
    </tr>
  </tbody>
</table>

<h2 id="AIO-NIO-2-0"><a href="#AIO-NIO-2-0" class="headerlink" title="AIO(NIO 2.0)"></a>AIO(NIO 2.0)</h2><p>异步非阻塞，由操作系统完成后回调通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<p><strong>应用场景：</strong> AIO方式适用于链接数目多且连接较长(重操作)的架构，JDK7开始支持</p>
<p>AIO代码示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverChannel =</span><br><span class="line">                AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;2--&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                    <span class="comment">// 再此接收客户端连接，如果不写这行代码后面的客户端连接连不上服务端</span></span><br><span class="line">                    serverChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;3--&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloClient&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">                            exc.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;1--&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.aio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AsynchronousSocketChannel socketChannel = AsynchronousSocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>)).get();</span><br><span class="line">        socketChannel.write(ByteBuffer.wrap(<span class="string">&quot;HelloServer&quot;</span>.getBytes()));</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line">        Integer len = socketChannel.read(buffer).get();</span><br><span class="line">        <span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端收到信息：&quot;</span> + <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**BIO、NIO、AIO对比: ** </p>
<table style="width:100%;" cellpadding="2" cellspacing="0" align="center" border="1" bordercolor="#000000">
  <tbody>
      <tr>
          <td style="text-align:center;">
         <b>对比项</b>
      </td>
        <td style="text-align:center;">
        <b>BIO</b>
      </td>
        <td style="text-align:center;">
        <b>NIO</b>
      </td> 
        <td style="text-align:center;">
        <b>AIO</b>
      </td>
    </tr>
      <tr>
          <td style="text-align:center;">
         <b>IO模型</b>
      </td>
        <td style="text-align:center;">
        同步阻塞
      </td>
        <td style="text-align:center;">
        同步非阻塞(多路复用)
      </td> 
        <td style="text-align:center;">
        异步非阻塞
      </td>
    </tr>
      <tr>
          <td style="text-align:center;">
         <b>编程难度</b>
      </td>
        <td style="text-align:center;">
        简单
      </td>
        <td style="text-align:center;">
        复杂
      </td> 
        <td style="text-align:center;">
        复杂
      </td>
    </tr>
      <tr>
          <td style="text-align:center;">
         <b>可靠性</b>
      </td>
        <td style="text-align:center;">
        差
      </td>
        <td style="text-align:center;">
        好
      </td> 
        <td style="text-align:center;">
        好
      </td>
    </tr>
      <tr>
          <td style="text-align:center;">
         <b>吞吐量</b>
      </td>
        <td style="text-align:center;">
        低
      </td>
        <td style="text-align:center;">
        高
      </td> 
        <td style="text-align:center;">
        高
      </td>
    </tr>
  </tbody>
</table>

<blockquote>
<p><strong>为什么Netty使用NIO而不使用AIO？</strong></p>
<p>在Linux系统上，AIO的底层实现任然使用Epoll，没有很好实现AIO，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化，Linux上AIO还不够成熟。Netty是<strong>异步非阻塞</strong>框架，Netty在NIO上做了很多异步的封装。</p>
</blockquote>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(三)</title>
    <url>/archives/37963bb5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博文《<a href="/archives/49651b9e/">Spring-IOC原理(二)</a>》中分析了<code>AnnotationConfigApplicationContext</code>构造方法中的<code>this()</code>方法，也知道了在这个方法中主要注册了一些<code>Spring</code>初始化必要的Bean，并且也创建了我们的容器对象。接下来继续看一下<code>AnnotationConfigApplicationContext</code>构造方法中的<code>register()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	 * 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	 * DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	 * 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	 * 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	 * 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	 * 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	 * 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	 * 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">/** 刷新 */</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、register方法分析"><a href="#一、register方法分析" class="headerlink" title="一、register方法分析"></a>一、<code>register</code>方法分析</h2><p>老办法，进入<code>register(componentClasses)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(componentClasses, <span class="string">&quot;At least one component class must be specified&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一个重写方法，在方法中又调用了<code>register(componentClasses)</code>;这次是调用<code>reader</code>中的<code>register</code>。先来看看<code>reader</code>是什么东西？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解bean定义读取器，主要作用是读取被注解标记的bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br></pre></td></tr></table></figure>

<p>看到这个，脑海中突然想到，我们在<code>this()</code>方法中不是初始化过一个<code>AnnotatedBeanDefinitionReader</code>吗！没错这个<code>reader</code>就是在<code>this()</code>中初始化完成创建的，几乎之后的用的<code>reader</code>，也是这个。既然知道它的来来龙去脉了，那就继续往下走，进到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.reader.register(componentClasses)</span><br></pre></td></tr></table></figure>

<p>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，依次遍历<code>componentClasses</code>，并将遍历出的类通过<code>registerBean</code>方法中。进入<code>registerBean(componentClasses)</code>方法中具体看看是怎么做的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    doRegisterBean(beanClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又被<code>Spring</code>代码搞恶心了，这TM套了这么多层还没有进入。高手都是这样子写代码的吗？？后来才知道其实在<code>Spring</code>源码中，不管嵌套多少次，最终真正干活的方法只有是<code>doXXX()</code>的方法。好吧继续进到<code>doRegisterBean()</code>方法中。</p>
<h3 id="1-1、doRegisterBean方法分析"><a href="#1-1、doRegisterBean方法分析" class="headerlink" title="1.1、doRegisterBean方法分析"></a>1.1、<code>doRegisterBean</code>方法分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * AnnotatedGenericBeanDefinition一种数据结构，用来描述Bean的，这里的作用就是把传入的标记了注解的类转为</span></span><br><span class="line"><span class="comment">	 * AnnotatedGenericBeanDefinition数据结构，类里面有一个getMetadata方法，可以拿到类上面的注解信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断是否需要跳过注解，spring中有<span class="doctag">@Condition</span>注解，当不满足条件，这个Bean就不会被解析</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解析bean的作用域，如果没有设置的话，默认是单例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取bean名字</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为<span class="doctag">@Lazy</span>、<span class="doctag">@Primary</span>,<span class="doctag">@DependsOn</span>、<span class="doctag">@Role</span>、<span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 限定符处理，不是特指<span class="doctag">@Qualifier</span>注解，也有可能是<span class="doctag">@Primary</span>,或者<span class="doctag">@Lazy</span>，或者是其他，如果以常规方式去初始化spring</span></span><br><span class="line"><span class="comment">	 * ApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationMain.class);</span></span><br><span class="line"><span class="comment">	 * qualifier永远都是空的，包括上面的name和instanceSupplier都是同样的道理</span></span><br><span class="line"><span class="comment">	 * 但是spring提供了其他方式去注册bean，就可能传入了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 可以传入qualifier数组，所以这里循环处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 优先处理<span class="doctag">@Primary</span>注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">				abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 再处理<span class="doctag">@Lazy</span>注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">				abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 最后处理其他注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (customizers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">			customizer.customize(abd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将AnnotatedGenericBeanDefinition和beanName封装到一个对象中BeanDefinitionHolder</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注册。最终调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，DefaultListableBeanFactory会维护一系列的信息</span></span><br><span class="line"><span class="comment">	 * 比如beanDefinitionNames,beanDefinitionMap。</span></span><br><span class="line"><span class="comment">	 * beanDefinitionNames是一个List&lt;String&gt; 用来存放bean的名字</span></span><br><span class="line"><span class="comment">	 * beanDefinitionMap是一个Map&lt;String,BeanDefinition&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细看一下上面代码。</p>
<h4 id="1-1-1、-初始化AnnotatedGenericBeanDefinition"><a href="#1-1-1、-初始化AnnotatedGenericBeanDefinition" class="headerlink" title="1.1.1、 初始化AnnotatedGenericBeanDefinition"></a>1.1.1、 初始化<code>AnnotatedGenericBeanDefinition</code></h4><p>首先是创建了一个<code>AnnotatedGenericBeanDefinition</code>，它其实可以看做是一种数据结构，里面会包含一些注解信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里创建<code>AnnotatedGenericBeanDefinition</code>的作用主要是吧传入的标记了注解的类封装为<code>AnnotatedGenericBeanDefinition</code>类型，然后可以通过<code>AnnotatedGenericBeanDefinition</code>中的<code>getMetadata()</code>方法来拿到类上面的注解信息。</p>
</blockquote>
<h4 id="1-1-2、shouldSkip-判断是否跳过"><a href="#1-1-2、shouldSkip-判断是否跳过" class="headerlink" title="1.1.2、shouldSkip()判断是否跳过"></a>1.1.2、<code>shouldSkip()</code>判断是否跳过</h4><p>接下类会判断是否需要跳过注解。在<code>Spring</code>中有一个<code>@Confition</code>注解，当不满足该注解表达式中条件时，这个Bean就不会被解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>shouldSkip()</code>方法中主要是解析带有<code>@Conditional</code>注解的类，如果没有注解这个注解，则直接返回false,否则会循环递归去解析带有该注解的类；并将所有带有该注解的类元信息拿到，并遍历渠道过滤条件，然后将过滤条件封装为<code>Condition</code>加入到<code>conditions</code>集合中；然后进行排序，之后会遍历我们刚刚保存的条件集合<code>conditions</code> ，通过<code>matchs()</code>方法匹配到符合过滤条件的bean,返回true</p>
</blockquote>
<h3 id="1-1-3、解析bean作用域"><a href="#1-1-3、解析bean作用域" class="headerlink" title="1.1.3、解析bean作用域"></a>1.1.3、解析bean作用域</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析bean的作用域，如果没有设置的话，默认是单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里bean的作用域默认是单例，当然可以通过<code>@Scope(scopeName = &quot;&quot;)</code>注解来指定作用域,是<code>singleton</code>还是<code>prototype</code></p>
</blockquote>
<h3 id="1-1-4、解析通用注解"><a href="#1-1-4、解析通用注解" class="headerlink" title="1.1.4、解析通用注解"></a>1.1.4、解析通用注解</h3><p>通过<code>AnnotationConfigUtils.processCommonDefinitionAnnotations(abd)</code>来解析通用注解，例如<code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>、<code>@Role</code>、<code>@Description</code>注解。然后处理解析到的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 可以传入qualifier数组，所以这里循环处理</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 优先处理<span class="doctag">@Primary</span>注解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">            abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 再处理<span class="doctag">@Lazy</span>注解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">            abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 最后处理其他注解</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述代码我们可以看出，其实<code>@Lazy</code>、<code>@Primary</code>、<code>@DependsOn</code>、<code>@Role</code>、<code>@Description</code>在处理的时候是有优先级的，如果一个类中以上几个注解都标注了，那么优先级依次是：<code>@Primary</code> &gt; <code>@Lazy</code> &gt; 其他注解</p>
</blockquote>
<h3 id="1-1-5、通过registerBeanDefinition-注册spring需要的基础bean"><a href="#1-1-5、通过registerBeanDefinition-注册spring需要的基础bean" class="headerlink" title="1.1.5、通过registerBeanDefinition()注册spring需要的基础bean"></a>1.1.5、通过<code>registerBeanDefinition()</code>注册spring需要的基础bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册。最终调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册，DefaultListableBeanFactory会维护一系列的信息</span></span><br><span class="line"><span class="comment"> * 比如beanDefinitionNames,beanDefinitionMap。</span></span><br><span class="line"><span class="comment"> * beanDefinitionNames是一个List&lt;String&gt; 用来存放bean的名字</span></span><br><span class="line"><span class="comment"> * beanDefinitionMap是一个Map&lt;String,BeanDefinition&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>

<p>最终通过调用<code>DefaultListableBeanFactory</code>类中的<code>registerBeanDefinition()</code>来完成基础bean的注册，这个方法的调用链很深，我们先点进到<code>registerBeanDefinition()</code>方法中看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取bean的名字</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注册bean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果有别名，注册别名</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>registerBeanDefinition()</code>方法中先获取了bean名字，然后通过调用<code>registry.registerBeanDefinition(beanName,beanDefinition)</code>来真正完成注册，这里的<code>registry</code>是<code>DefaultListableBeanFactory</code>实现子类，所以我们到<code>DefaultListableBeanFactory</code>类中找到<code>registerBeanDefinition()</code>方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                   <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 先从beanDefinitionMap一级缓存中获取bean */</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">/** 如果一级缓存中有bean */</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                            <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                            existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                             <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                             <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** 将bean设置到一级缓存 */</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * beanDefinitionMap是Map&lt;String,BeanDefinition&gt;,这里把beanName作为key,beanDefinition作为value</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先会判断<code>beanDefinitionMap</code>缓存中是否存在bean，第一次进来肯定是不存在的，所以第一次进来必定会进入else分支，在else分支中，为了避免重复创建，首先会通过<code>hasBeanCreationStarted()</code>来判断是否已经创建。第一次的话这里肯定也是没有创建，所以也不会进入到if中，来到else将<code>beanDefinition</code>放入<code>beanDefinitionMap</code>中，<code>beanName</code>放入<code>beanDefinitionNames</code>集合中。最后开看一些<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从代码中可以看出，<code>beanDefinitionMap</code>是一个Map，并且key是<code>beanName</code>，value是<code>BeanDefinition</code>，<code>beanDefinitionNames</code>是一个集合，并且是线程可见变量集合，用来保存<code>beanName</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(二)</title>
    <url>/archives/49651b9e/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇博文<a href="/archives/81aeb1f/">《Spring-IOC原理(一)》</a>中已经基本上了解了一下<code>Spring IOC</code>的大致运行流程。也知道了这个流程都是从<code>AnnotationConfigApplicationContext</code>构造方法中发起的，那么本篇博文就从<code>AnnotationConfigApplicationContext</code>构造方法中详细探究一下<code>Spring IOC</code>详细的加载过程；回顾一下<code>AnnotationConfigApplicationContext</code>构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 这里会实例化BeanDefinitionReader和BeanDefinitionScanner，并注册一些框架初始化必要的Bean</span></span><br><span class="line"><span class="comment">	* 调用无参构造函数，会先调用父类GenericApplicationContext的构造函数，父类构造函数中就是初始化</span></span><br><span class="line"><span class="comment">	* DefaultListableBeanFactory，并且赋值给beanFactory。</span></span><br><span class="line"><span class="comment">	* 在本类的构造函数中，初始化了一个读取器reader = new AnnotatedBeanDefinitionReader(this);</span></span><br><span class="line"><span class="comment">	* 和一个扫描器scanner = new ClassPathBeanDefinitionScanner(this);</span></span><br><span class="line"><span class="comment">	* 扫描器scanner的用出不是很大，它仅仅是我们外部手动调用.scan()方法时才会用到的，常规方式是不会用到scanner</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">/** 注册Bean</span></span><br><span class="line"><span class="comment">	* 把传入的类进行注册，这里会有两种方式，一种是传入配置类，一种是传入bean。</span></span><br><span class="line"><span class="comment">	* 这里spring会把传统的带有<span class="doctag">@Configuration</span>注解的类称之为FULL配置类，不带<span class="doctag">@Configuration</span>注解但是带有<span class="doctag">@Component</span>、</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@Import</span>、<span class="doctag">@ImportResource</span>、<span class="doctag">@Server</span>、<span class="doctag">@ComponentScan</span> 等注解的类称之为Lite配置类</span></span><br><span class="line"><span class="comment">	* 我们这里先把带有<span class="doctag">@Configuration</span>注解的称之为传统配置类，不带该注解的称之为普通类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">/** 刷新 */</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、this-方法详解"><a href="#一、this-方法详解" class="headerlink" title="一、this()方法详解"></a>一、<code>this()</code>方法详解</h2><p>在以上的构造方法中，首先是调用的本类的无参构造方法<code>this()</code>，<code>ctrl+鼠标左键</code>点进入看看这个构造方法里都干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 这里会隐式调用父类构造函数，来初始化DefaultListableBeanFactory */</span></span><br><span class="line">    <span class="comment">/** 1、 用来读取Bean配置信息，该配置信息是使用注解配置的 */</span></span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">/** 用来扫描 1中读取到的Bean，这里会扫描配置有<span class="doctag">@AutoWired</span>、<span class="doctag">@Value</span>等注解*/</span></span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AnnotationConfigApplicationContext</code>无参构造方法中创建了<code>this.reader</code>是一个<code>AnnotatedBeanDefinitionReader</code>类型和<code>this.scanner</code>是一个<code>ClassPathBeanDefinitionScanner</code>类型。</p>
<blockquote>
<p><strong><code>this.reader</code>：</strong> 注解bean定义读取器，主要作用是读取被注解标记的bean</p>
<p><strong><code>this.scanner</code>：</strong> 扫描器，如果使用注解的方式不会使用到这个扫描器；只有在外部通过<code>.scan(...)</code>方法时才会调到，常规方法时不会用到的。</p>
</blockquote>
<p>因为这里主要是用的注解的方式进行调试的，所以<code>this.scanner</code>也不会使用到，这里也就不去研究。接下来只研究<code>this.reader</code>。</p>
<p>因为<code>AnnotationConfigApplicationContext</code>类是继承了父类<code>GenericApplicationContext</code>的。如下类关系图</p>
<p><img src="/archives/49651b9e/image-20210817105837171.png" alt="AnnotationConfigApplicationContext类关系图"></p>
<p>所以在<code>AnnotationConfigApplicationContext</code>构造方法执行之前，首先会执行<code>GenericApplicationContetxt</code>类的默认构造方法，来看看<code>GenericApplicationContetxt</code>的构造方法里干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里创建了一个bean工厂，该bean工厂在后面进行bean初始化的时候会用到；其实这个<code>beanFactory</code>就是我们所说的容器</p>
</blockquote>
<p>等到<code>GenericApplicationContext()</code>执行完毕之后，接下来才会执行我们的<code>AnnotationConfigApplicationContext()</code>构造方法中的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 1、 用来读取Bean配置信息，该配置信息是使用注解配置的 */</span></span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>继续点进入，发现有调了<code>AnnotatedBeanDefinitionReader</code>的构造方法。继续跟进，what!!! 怎么还停留在构造方法中,嵌套这么复杂……想一想这不是设计模式中的门面方法么。看到了代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>

<h2 id="二、registerAnnotationConfigProcessors方法详解"><a href="#二、registerAnnotationConfigProcessors方法详解" class="headerlink" title="二、registerAnnotationConfigProcessors方法详解"></a>二、<code>registerAnnotationConfigProcessors</code>方法详解</h2><p>这回该是开始正式干活的方法了，点进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>。。。。此时一万只草泥马从眼前奔腾而过!!!既然已经到这里了，那我就在赌一把，继续点进入调用的方法中。</p>
<p>豁然开朗,终于看到了干活的方法了。好家伙小100行的方法，全是if判断。大致看一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 将ConfigurationClassPostProcessor分装成RootBeanDefinition注册到容器中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册CommonAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册PersistenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册EventListenerMethodProcessor</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册DefaultEventListenerFactory</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出在<code>registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, @Nullable Object source)</code> 方法中主要将spring初始化要用到的后置处理器封装成了<code>RootBeanDefinition</code>并且将他们注册到<code>set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8)</code>中。主要包括</p>
<blockquote>
<ul>
<li><code>ConfigurationClassPostProcessor</code>：这个后置处理器后期会解析带有<code>@Configuration</code>、<code>@Import</code>、<code>@Component</code>、<code>@ComponentScan</code>等注解，在spring中给常重要</li>
<li><code>AutoWiredAnnotationBeanPostProcessor</code>：主要用来解析带有<code>@AutoWired</code>注解的属性，用来注入属性实例</li>
<li><code>CommonAnnotationBeanPostProcessor</code>：用来解析通用注解，比如<code>@Resource</code>、<code>@WebServiceRef</code>、<code>@EJB</code>注解。这三个注解都是定义在<code>javax.*</code>包下，属于java中的注解</li>
<li><code>PersistenceAnnotationBeanPostProcessor</code>：用来解析<code>@PersistenceUnit</code>、<code>@PersistenceContext</code>注解</li>
<li><code>EventListenerMethodProcessor</code>：用来解析<code>@EventListener</code>注解，</li>
<li><code>DefaultEventListenerFactory</code>：处理默认监听事件,当没有在程序中指定事件</li>
</ul>
</blockquote>
<h2 id="三、registerPostProcessor方法详解"><a href="#三、registerPostProcessor方法详解" class="headerlink" title="三、registerPostProcessor方法详解"></a>三、<code>registerPostProcessor</code>方法详解</h2><p>接下来继续看一下<code>registerPostProcessor(registry,def,beanName)</code>，点进入这个方法看看内部有什么实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinitionHolder <span class="title">registerPostProcessor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记bean角色是spring内部定义，并非用户定义</span></span><br><span class="line">    definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 注册bean定义，registry的实现类是DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(definition, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法中主要设置了bean的角色和注册bean定义，</p>
</blockquote>
<h2 id="四、registerBeanDefinition方法详解"><a href="#四、registerBeanDefinition方法详解" class="headerlink" title="四、registerBeanDefinition方法详解"></a>四、<code>registerBeanDefinition</code>方法详解</h2><p>继续进入<code>registry.registerBeanDefinition(beanName, definition);</code>中，注意<code>registerBeanDefinition()</code>是接口中的方法，该方法中的实现是在接口实现类中，而<code>registry</code>的实现类是<code>DefaultListableBeanFactory</code>，所以最终我们要进入到<code>DefaultListableBeanFactory</code>类中的<code>registerBeanDefinition(beanName,definition)</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">	Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 先从beanDefinitionMap一级缓存中获取bean */</span></span><br><span class="line">	BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="comment">/** 如果一级缓存中有bean */</span></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			<span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">						existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">						<span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/** 将bean设置到一级缓存 */</span></span><br><span class="line">		<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * beanDefinitionMap是Map&lt;String,BeanDefinition&gt;,这里把beanName作为key,beanDefinition作为value</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>整个方法中主要是将<code>registerAnnotationConfigProcessors(BeanDefinitionRegistry)</code>方法中注册的一些Bean后置处理器做了处理，将这些后置处理器注册成<code>BeanDefinition</code>对象并且将其放入<code>Map&lt;String,BeanDefinition&gt;</code>类型的<code>beanDefinitionMap</code>中。</p>
</blockquote>
<p>大概流程是：首先根据给定的<code>beanName</code>去<code>beanDefinitionMap</code>中拿bean定义，如果bean定义不为空。继续判断是否允许重复创建bean定义(如果允许重复创建bean定义，并且给定的bean定义名称已经在<code>beanDefinitionMap</code>中已经存在实例，则第二次创建的bean定义实例会覆盖第一次bean定义实例。可以通过<code>spring.main.allow-bean-definition-overriding</code>来指定是否允许覆盖);如果不允许重复创建bean定义即<code>allowBeanDefinitionOverriding=false</code>,会抛出<code>BeanDefinitionOverrideException</code>异常；如果允许重复创建bean定义即<code>allowReanDefinitionOverriding=true</code>；继续判断bean定义角色、bean定义类型，如果都通过，则将传入的bean定义实例放入<code>beanDefinitionMap</code>中；key为<code>beanName</code>,value为<code>BeanDefinition</code>实例对象；</p>
<p>如果从<code>beanDefinitionMap</code>中拿出的bean定义为空，即第一次进来，将传进来的bean定义放入<code>beanDefinitionMap</code>中，同时将<code>beanName</code>放入<code>beanDefinitionNames</code>中。然后判断从<code>beanDefinitionMap</code>拿出来的bean定义 不为空 或者 已经有实例的单例bean，则递归调用<code>resetBeanDefinition()</code>。</p>
<p>上面分析中说了，bean最后会保存在<code>beanDefinitionMap</code>中，<code>beanName</code>会保存在<code>beanDefinitionNames</code>中；<code>beanDefinitionMap</code>是一个Map，key是<code>beanName</code>,value是<code>BeanDefinition</code>；<code>beanDefinitionNames</code>是字符串列表。从这里我们可以看出<code>DefaultListableBeanFactory</code>就是我们常说的容器了。可以在这方法中打一个端点调试一下。</p>
<p><img src="/archives/49651b9e/image-20210817162318035.png" alt="端点调试"></p>
<p><strong><code>DefaultListableBeanFactory</code>中的<code>beanDefinitionMap</code>、<code>beanDefinitionNames</code>是很重要的，后面会经常看到他们的身影。</strong></p>
<p>这里只是简单的把创建bean所需要的基本信息放入到了工厂中，还没有进行真正的生产bean。上面我们提到注册了好多bean后置处理器，<strong>其中有一个很重要的bean是<code>ConfigurationClassPostProcessor</code> ，这个bean实现了一个接口<code>BeanDefinitionRegistryPostProcessor</code>接口，<code>BeanDefinitionRegistryPostProcessor</code>接口又继承了<code>BeanFactoryPostProcessor</code>接口；而<code>BeanFactoryPostProcessor</code>是Spring的扩展点之一，必须记住<code>ConfigurationClassPostProcessor</code>类的继承关系。</strong></p>
<p><img src="/archives/49651b9e/image-20210817163534229.png" alt="ConfigurationClassPostProcessor"></p>
<p>除了注册<code>ConfigurationClassPostProcessor</code>,还注册了<code>AutoWiredAnnotationBeanPostProcessor</code> bean，该bean实现了一个接口<code>MergedBeanDefinitionPostProcessor</code>，而<code>MergedBeanDefinitionPostProcessor</code>接口继承了<code>BeanPostProcessor</code>。**<code>BeanPostProcessor</code>也是Spring的一个扩展点之一，也是非常重要，需要记住。**</p>
<p><img src="/archives/49651b9e/image-20210817164936726.png" alt="AutoWiredAnnotationBeanPostProcessor类关系图"></p>
<p>到此，<code>this()</code>方法中的流程分析完毕。</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper实战</title>
    <url>/archives/e5bda741/</url>
    <content><![CDATA[<h1 id="1、什么是Zookeeper"><a href="#1、什么是Zookeeper" class="headerlink" title="1、什么是Zookeeper"></a>1、什么是Zookeeper</h1><p>在Zookeeper官方文档中给出的接释是，它是一个分布式协调框架，是Apache Hadoop的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>
<p><img src="/archives/e5bda741/clipboard.png" alt="Zookeeper"></p>
<p>Zookeeper主要由两个核心概念：文件系统数据结构 + 监听通知机制</p>
<h2 id="1-1-文件系统数据结构"><a href="#1-1-文件系统数据结构" class="headerlink" title="1.1 文件系统数据结构"></a>1.1 文件系统数据结构</h2><p>Zookeeper维护一个类似文件系统的数据结构：</p>
<p><img src="/archives/e5bda741/image-20211003175038043.png" alt="zookeeper文件系统的数据结构"></p>
<p>每个子目录都被称作为<strong>znode（目录节点）</strong>，和文件系统类似，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode。</p>
<p>有四种类型的znode：</p>
<ol>
<li><p>PERSISTENT-持久化目录节点</p>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只要不手动删除该节点，他将永远存在</p>
</li>
<li><p>PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</p>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p>
</li>
<li><p>EPHEMERAL-临时目录节点</p>
<p>客户端与zookeeper断开连接后，该节点被删除</p>
</li>
<li><p>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p>
<p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p>
</li>
<li><p>Container节点</p>
<p>3.5.3版本新增，如果Container节点下面没有子节点，则Container节点在未来会被Zookeeper自动清除，定时任务默认60秒检查一次</p>
</li>
<li><p>TTL节点（默认禁用，只能通过系统配置<em>zookeeper.extendedTypesEnabled=true</em>开启，不稳定）</p>
</li>
</ol>
<p><img src="/archives/e5bda741/image-20211003175418041.png" alt="zookeeper节点构成"></p>
<h2 id="1-2-监听通知机制"><a href="#1-2-监听通知机制" class="headerlink" title="1.2 监听通知机制"></a>1.2 监听通知机制</h2><p>客户端监听他关心的任意节点，或者目录节点以及递归子目录节点</p>
<ol>
<li>如果注册的是对某个节点的监听，则当这个节点被删除，或者被修改时，对应的客户端将被通知</li>
<li>如果注册的是对某个目录的监听，则这个目录有子节点被创建，或者有子节点被删除，对应的客户端将被通知</li>
<li>如果注册的是对某个目录的递归子节点进行监听，则当目录下面任意子节点有目录结构的变化（有子节点被创建，或者被删除）或者根节点有数据变化时，对应的客户端将通知</li>
</ol>
<p><strong>注意：所有的通知都是一次性的，无论是对节点还是对目录进行的监听，一旦触发，对应的监听即被删除。递归子节点，监听是对所有子节点的，所以每个子节点下面的事件同样只会被触发一次</strong></p>
<h2 id="1-3-Zookeeper经典应用场景"><a href="#1-3-Zookeeper经典应用场景" class="headerlink" title="1.3 Zookeeper经典应用场景"></a>1.3 Zookeeper经典应用场景</h2><ol>
<li>分布式配置中心</li>
<li>分布式注册中心</li>
<li>分布式锁</li>
<li>分布式队列</li>
<li>集群选举</li>
<li>分布式屏障</li>
<li>分布订阅</li>
</ol>
<h1 id="2、Zookeeper安装及使用"><a href="#2、Zookeeper安装及使用" class="headerlink" title="2、Zookeeper安装及使用"></a>2、Zookeeper安装及使用</h1><h2 id="2-1-zookeeper安装"><a href="#2-1-zookeeper安装" class="headerlink" title="2.1 zookeeper安装"></a>2.1 zookeeper安装</h2><h4 id="Step1-配置Java环境，检查环境"><a href="#Step1-配置Java环境，检查环境" class="headerlink" title="Step1: 配置Java环境，检查环境"></a>Step1: 配置Java环境，检查环境</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h4 id="Step2-下载解压zookeeper"><a href="#Step2-下载解压zookeeper" class="headerlink" title="Step2: 下载解压zookeeper"></a>Step2: 下载解压zookeeper</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">weget https://archive.apache.org/dist/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.9-bin.tar.gz</span><br><span class="line"><span class="built_in">cd</span> apache-zookeeper-3.5.9-bin</span><br></pre></td></tr></table></figure>

<h4 id="Step3-重命名配置文件-zoo-sample-cfg"><a href="#Step3-重命名配置文件-zoo-sample-cfg" class="headerlink" title="Step3: 重命名配置文件 zoo_sample.cfg"></a>Step3: 重命名配置文件 zoo_sample.cfg</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<h4 id="Step4-启动zookeeper"><a href="#Step4-启动zookeeper" class="headerlink" title="Step4: 启动zookeeper"></a>Step4: 启动zookeeper</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以通过bin/skServer.sh 来查看都支持哪些参数</span></span><br><span class="line">bin/zkServer.sh start conf/zoo.cfg</span><br></pre></td></tr></table></figure>

<h4 id="Step5-检查是否启动成功"><a href="#Step5-检查是否启动成功" class="headerlink" title="Step5: 检查是否启动成功"></a>Step5: 检查是否启动成功</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure>

<h4 id="Step6-连接服务器"><a href="#Step6-连接服务器" class="headerlink" title="Step6: 连接服务器"></a>Step6: 连接服务器</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure>

<h2 id="2-2-zookeeper使用"><a href="#2-2-zookeeper使用" class="headerlink" title="2.2 zookeeper使用"></a>2.2 zookeeper使用</h2><ol>
<li><p>创建zookeeper节点命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create [-s] [-e] [-c] [-t ttl] path [data] [acl]</span><br></pre></td></tr></table></figure>

<p>中括号为可选项，没有则默认创建持久化节点</p>
<p>-s：顺序节点</p>
<p>-e：临时节点</p>
<p>-c：容器节点</p>
<p>-t：可以给节点添加过期时间，默认禁用，需要通过系统参数启用</p>
<p>(<em>-Dzookeeper.extendedTypesEnabled=true, znode.container.checkIntervalMs:(Java system property only)<strong>New in 3.5.1:</strong> The time interval in milliseconds for each check of candidate container and ttl nodes. Default is “60000”</em>)</p>
<p>创建节点：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create /test-note some-data</span><br></pre></td></tr></table></figure>

<p>如上，没有加任何可选参数，创建的就是一个持久化节点<br><img src="/archives/e5bda741/image-20211003164434593.png" alt="创建节点"></p>
<p>查看节点：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">get /test-node</span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003165018195.png" alt="查看节点"></p>
<p>查看节点状态信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stat</span> /test-node</span><br></pre></td></tr></table></figure>
<p><img src="/archives/e5bda741/image-20211003165814988.png" alt="查看节点状态"></p>
</li>
</ol>
<ul>
<li>cZxid：创建znode的事务ID（Zxid的值）</li>
<li>mZxid：最后修改znode的事务ID</li>
<li>pZxid：最后添加或删除子节点的事务ID（子节点列表发生变化才会发生改变）</li>
<li>ctime：znode创建时间</li>
<li>mtime：znode最近修改时间</li>
<li>dataVersion：znode的当前数据版本</li>
<li>cversion：znode的子节点结果集版本（一个节点的子节点增加、删除都回影响这个版本）</li>
<li>aclVersion：表示对此znode的acl版本</li>
<li>ephemeralOwner：znode是临时znode时，表示znode所有者的sessionID。如果znode不是临时znode，则该字段设置为零</li>
<li>dataLength：znode数据字段的长度</li>
<li>numChildren：znode的子znode的数量。</li>
</ul>
<p>查看节点状态信息同时查看数据</p>
<p><img src="/archives/e5bda741/image-20211003171357202.png" alt="查看节点状态信息"></p>
<p>根据状态数据中的版本号有并发修改数据实现客观锁功能</p>
<p>比如：客户端首先获取版本信息，<code>get -s /node-test</code></p>
<p><img src="/archives/e5bda741/image-20211003171802123.png" alt="节点版本信息"></p>
<p><code>/test-node</code>当前的数据版本是1，这时客户端用set命令修改数据的时候可以把版本号带上</p>
<p><img src="/archives/e5bda741/image-20211003172301741.png" alt="带版本号修改"></p>
<p>如果在执行上面set命令前，有人修改了数据，zookeeper回递增版本号，这个时候如果再用以前的版本号修改，将会导致失败，报错如下：</p>
<p><img src="/archives/e5bda741/image-20211003172210262.png" alt="带版本号修改报错"></p>
<p>创建节点，这里要注意，zookeeper是以节点组织数据的，没有相对路径这么一说，所以，所有的节点一定是以<code>/</code>开头的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create /test-node/test-sub-node</span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003192152896.png" alt="创建子节点"></p>
<p>查看子节点的信息，比如根节点下面所有的子节点，加一个大写R可以查看递归子节点列表</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003192322656.png" alt="查看根节点所有子节点"></p>
<p>查看<code>/test-node</code>下面所有的子节点</p>
<p><img src="/archives/e5bda741/image-20211003192436348.png" alt="查看节点"></p>
<p>创建临时节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create -e /ephemeral data</span><br></pre></td></tr></table></figure>

<p>create 后跟一个<code>-e</code>创建临时节点，临时节点不能创建子节点</p>
<p><img src="/archives/e5bda741/image-20211003193204396.png" alt="创建临时节点"></p>
<p>创建序号节点，加参数<code>-s</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create /seq-parent data <span class="comment"># 创建父目录，单纯为了分类，非必须</span></span><br><span class="line">create /seq-parent/ data <span class="comment"># 创建顺序节点。顺序节点将再seq-parent目录下面，顺序递增</span></span><br></pre></td></tr></table></figure>

<p>为了容纳子节点，先创建父目录<code>/seq-parent</code></p>
<p><img src="/archives/e5bda741/image-20211003193523659.png" alt="创建父目录"></p>
<p>也可以再序号节点前面带一个前缀</p>
<p><img src="/archives/e5bda741/image-20211003193757408.png" alt="序号节点前加前缀"></p>
<p>创建临时顺序节点，其他增删改查和其他节点无异</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create -s -e /ephemeral-node/前缀-</span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003194346735.png" alt="image-20211003194346735"></p>
<p>创建容器节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create -c /container</span><br></pre></td></tr></table></figure>

<p>容器节点主要用来容纳子节点，如果没有给其创建子节点，容器节点表现和持久化节点一样，如果给容器创建了子节点，后续有把子节点清空，容器节点也会被zookeeper删除。</p>
<ol start="2">
<li><p>事件监听机制</p>
<p>针对节点的监听：一旦事件触发，对应的注册立刻被删除，所以事件监听是一次性的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">get -w /path <span class="comment"># 注册监听的同时获取数据</span></span><br><span class="line"><span class="built_in">stat</span> -w /path <span class="comment"># 对节点进行监听，且获取元数据信息</span></span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003195407810.png" alt="监听节点"></p>
</li>
</ol>
<p>针对目录的监听，如下图，目录的变化，会触发事件，且一旦触发，对应的监听也会被移除，后续对节点的创建没有触发监听事件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -w /path</span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003195740404.png" alt="监听目录"></p>
<p>针对递归子目录的监听</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -R -w /path <span class="comment"># -R区分大小写，一定要大写</span></span><br></pre></td></tr></table></figure>

<p>如下对<code>/test</code>节点进行递归监听，但是每个目录下的目录监听也是一次性的，如第一次在<code>/test</code>目录下创建节点时，触发监听事件，第二次则没有，同样，因为是递归的目录监听，所以在<code>/test/sub</code>下进行节点创建时，触发事件，但是再次创建<code>/test/sub/subsub</code>节点时，没有触发事件。</p>
<p><img src="/archives/e5bda741/image-20211003201435610.png" alt="递归子目录监听"></p>
<blockquote>
<p>Zookeeper事件类型：</p>
<ul>
<li>None：连接建立事件</li>
<li>NodeCreated：节点创建</li>
<li>NodeDeleted：节点删除</li>
<li>NodeDataChanged：节点数据变化</li>
<li>NodeChildrenChanged：子节点列表变化</li>
<li>DataWatchRemoved：节点监听被移除</li>
<li>ChildWatchRemoved：子节点监听被移除</li>
</ul>
</blockquote>
<h1 id="3、Zookeeper的ACL权限控制-Access-Control-List"><a href="#3、Zookeeper的ACL权限控制-Access-Control-List" class="headerlink" title="3、Zookeeper的ACL权限控制(Access Control List)"></a>3、Zookeeper的ACL权限控制(Access Control List)</h1><p>Zookeeper的ACL权限控制，可以控制节点的读写操作，保证数据的安全性，Zookeeper的ACL权限设置分为3部分组成，分别是：**权限模式(Scheme)<strong>、</strong>授权对象(ID)<strong>、</strong>权限信息(Permission)**。最终组成一条例如”scheme:id:permission”格式的ACL请求信息，下面我们具体看一下这三个部分代表什么意思：</p>
<p><strong>Scheme(权限模式)：</strong> 用来设置Zookeeper服务器进行权限验证的方式。Zookeeper的权限校验方式大体分为两种类型：</p>
<p>一种是<strong>范围验证</strong>。所谓的范围验证就是说Zookeeper可以针对一个IP或者一段IP地址授予某种权限。比如我们可以让一个IP地址为“IP：192.168.31.104”的机器对服务器上的某个节点具有写入的权限，或者也可以通过“IP：192.168.31.1/24”给一段IP地址的机器赋予权限。</p>
<p>另一种是模式就是<strong>口令验证</strong>，也可以理解为用户名密码的方式。在Zookeeper中这种验证方式是Digest认证，而Digest这种认证方式首先在客户端传送“username:password”这种形式的权限表示符后，Zookeeper服务端会对密码部分使用SHA-1和BASWE64算法进行加密，以保证安全性。</p>
<p>还有一种<strong>Super权限模式</strong>，Super可以认为是一个特殊的Digest认证。具有Super权限的客户端可以对Zookeeper上任意数据节点进行任意的操作。</p>
<p><strong>授权对象(ID)：</strong></p>
<p>授权就是说我们要把权限赋予谁，而对应于4种不同的权限模式来说，如果我们选择采用IP方式，使用授权对象可以是一个IP或者IP地址段；而如果使用Digest或Super方式，则对应于一个用户名。如果是World模式，是授权系统中的所有用户。</p>
<p><strong>权限信息(Permission)：</strong></p>
<p>权限就是指我们可以在数据节点上执行的操作类型，如下所示：在Zookeeper中已经定义好的权限有5种：</p>
<blockquote>
<p>数据节点（c：create）创建权限，授予权限的对象可以在数据节点下==创建子节点==</p>
<p>数据节点（w：write）更新权限，授予权限的对象可更新该数据节点</p>
<p>数据节点（r：read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信息</p>
<p>数据节点（d：delete）删除权限，授予权限的对象可以删除该数据节点的==子节点==</p>
<p>数据节点（a：admin）管理者权限，授予权限的对象可以对该数据节点进行ACL权限设置</p>
</blockquote>
<p><strong>命令：</strong></p>
<p><code>getAcl</code>: 获取某个节点的ACL权限信息</p>
<p><code>setAcl</code>：设置某个节点的ACL权限信息</p>
<p><code>addauth</code>：输入认证授权信息，相当于注册用户信息，注册时输入明文密码，zk将以密文的形式存储</p>
<p>可以通过系统参数<code>zookeeper.skipACL = yes</code>进行设置，默认时<code>no</code>，可以设置为<code>true</code>，则配置过的ACL将不再进行权限检测</p>
<p><strong>生成授权ID的两种方式：</strong></p>
<ul>
<li><p>代码生成ID</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSuperDigest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    String sId = DigestAuthenticationProvider.generateDigest(<span class="string">&quot;lhb:123456&quot;</span>);</span><br><span class="line">    System.out.println(sId);<span class="comment">//  lhb:nJnredAZxZ1dpEZSzZt/xmcFNUM=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过命令生成</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>设置ACL的两种方式：</strong></p>
<ul>
<li><p>节点创建的同时设置ACL</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">create [-s][-e][-c] path [data][acl]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>create /zk-node datatest digest:lhb:nJnredAZxZ1dpEZSzZt/xmcFNUM=:cdrwa</p>
</blockquote>
</li>
<li><p>使用setAcl设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setAcl /zk-node digest:lhb:nJnredAZxZ1dpEZSzZt/xmcFNUM=:cdrwa</span><br></pre></td></tr></table></figure></li>
</ul>
<p>添加权限信息后，不能直接访问，在访问前需要添加授权信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">addauth digest gj:<span class="built_in">test</span></span><br><span class="line">get /zk-node</span><br><span class="line">datatest</span><br></pre></td></tr></table></figure>

<p>另一种授权模式：auth明文授权</p>
<p>使用前需要先<code>addauth digest username:password</code>注册用户信息，后续可以直接用明文授权。例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">addauth digest u100:p100</span><br><span class="line">create /node-1 node1data auth:u100:p100:cdwra <span class="comment"># 这时u100用户授权信息会被zk保存，可以认为当前的授权用户为u100</span></span><br><span class="line">get /node-1</span><br><span class="line">node1data</span><br></pre></td></tr></table></figure>

<p>IP授权模式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setAcl /node-ip ip:192.168.31.127:cdwra</span><br><span class="line">create /node-ip data ip:192.168.31.127:cdwra</span><br></pre></td></tr></table></figure>

<p>多个指定IP可以通过都好分隔开来，例如</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setAcl /node-ip ip:IP1:rw,ip:IP2:a</span><br></pre></td></tr></table></figure>

<p><strong>Super超级管理员模式：</strong></p>
<p>这是一种特殊的Digest模式，在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作。需要在启动是通过JVM参数开启：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DigestAuthenticationProvider中定义</span></span><br><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=super:&lt;base64encoded(SHA1(password))</span><br></pre></td></tr></table></figure>

<h1 id="4、Zookeeper内存数据的持久化"><a href="#4、Zookeeper内存数据的持久化" class="headerlink" title="4、Zookeeper内存数据的持久化"></a>4、Zookeeper内存数据的持久化</h1><p>Zookeeper数据的组织形式为一个类似文件系统的数据结构，而这些数据都是存储在内存中的，所以我们可以认为，Zookeeper是一个基于内存的小型数据库</p>
<p><strong>内存中的数据：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, DataNode&gt;();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchManager dataWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WatchManager childWatches = <span class="keyword">new</span> WatchManager();</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>DataNode是Zookeeper存储节点数据的最小单位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataNode</span> <span class="keyword">implements</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> data[];</span><br><span class="line">    Long acl;</span><br><span class="line">    <span class="keyword">public</span> StatPersisted stat;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; children = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h1 id="5、事务日志"><a href="#5、事务日志" class="headerlink" title="5、事务日志"></a>5、事务日志</h1><p>针对每一次客户端的事务操作，Zookeeper都会将他们记录到事务日志中，当然，Zookeeper也会将数据变更应用到内存数据库中。我们可以在zookeeper的主配置文件zoo.cfg中配置内存中的数据持久化目录，也就是事务日志的存储路径dataLogDir。如果没有配置dataLogDir(非必填)，事务日志将默认存储到dataDir(必填项)目录。</p>
<p>zookeeper提供了格式化工具(org.apache.zookeeper.server.LogFormatter)可以进行查看事务日志数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -classpath .:slf4j-api-1.7.25.jar:zookeeper-3.5.9.jar:zookeeper-jute-3.5.9.jar org.apache.zookeeper.server.LogFormatter /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.5.9-bin/data/verssion-2/log.1</span><br></pre></td></tr></table></figure>

<p>如下是我本地的日志文件格式化效果</p>
<p><img src="/archives/e5bda741/image-20211003214213823.png" alt="日志文件格式化效果"></p>
<p>从左到右分别记录了操作时间，客户端会话ID，CXID，ZXID，操作类型，节点路径，节点数据(用#+ascii码表示)，节点版本。</p>
<p>Zookeeper进行事务日志文件操作的时候会频繁进行磁盘IO操作，事务日志的不断追加写操作会触发底层磁盘IO为文件开辟新的磁盘块，即磁盘Seek。因此，为了提升磁盘IO的效率，Zookeeper在创建事务日志文件的时候就进行文件空间的预分配——即在创建文件的时候，就向操作系统申请一块大一点的磁盘块。这个预分配的磁盘大小可以通过系统参数<code>zookeeper.preAllocSize</code>进行配置。</p>
<p>事务日志文件名为：log.&lt;当时最大事务ID&gt;，因为日志文件是顺序写入的，所以这个最大事务ID也将是整个事务日志文件中，最小的事务ID，日志满了即进行下一次事务日志文件的创建</p>
<h1 id="6、数据快照"><a href="#6、数据快照" class="headerlink" title="6、数据快照"></a>6、数据快照</h1><p>数据快照用于记录Zookeeper服务器上某一时刻的全量数据，并将其写入到指定的磁盘文件中。</p>
<p>可以通过配置<code>snapCount</code>来设置每间隔事务请求个数，生成快照，数据存储在dataDir指定的目录中</p>
<p>可以通过一下方式进行查看快照数据（为了避免集群中所有机器在同一时间进行快照，实际的快照生存成时间为事务数达到[snapCount/2 + 随机数(随机数范围为1~snapCount/2)]个数时开始快照）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -classpath .:slf4j-api-1.7.25.jar:zookeeper-3.5.8.jar:zookeeper-jute-3.5.8.jar org.apache.zookeeper.server.SnapshotFormatter /usr/<span class="built_in">local</span>/zookeeper/apache-zookeeper-3.5.8-bin/data-dir/version-2/snapshot.0</span><br></pre></td></tr></table></figure>

<p><img src="/archives/e5bda741/image-20211003215744332.png" alt="查看快照信息"></p>
<p>快照事务日志文件名为：snapshot.&lt;当时最大事务ID&gt;，日志满了即进行下一次事务日志文件的创建。</p>
<p><strong>有了事务日志，为什么还是要快照数据呢？</strong></p>
<blockquote>
<p>因为快照数据主要是为了快速恢复，事务日志文件是每次事务请求都会进行追加的操作，而快照数据是达到某种设定条件下某一刻内存的全量数据。所以快照数据是反应当时内存中数据的状态。事务日志是更加全面的数据，所以恢复数据的时候，可以先恢复快照数据，再通过增量恢复事务日志中的数据即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>invokeBeanDefinitionRegistryPostProcessors方法解析</title>
    <url>/archives/79103379/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先来回顾一下上周学习的内容。在上周我们主要解析了<code>refresh()</code>方法中的<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法。这个方法主要是实例化并调用所有注册的<code>BeanFactoryPostProcessor</code>，我们也知道了<code>invokeBeanFactoryPostProcessors</code>方法中主要是处理<code>BeanFactoryPostProcessor</code>接口的，而<code>BeanFactoryPostProcessor</code>是针对<code>BeanFactory</code>的扩展，所以在bean实例化之前，可以读取bean定义，也可以修改bean定义。同时我们说到了在第一次调用bean定义后置处理器的时候会去解析我们的<code>@Import</code>、<code>@Component</code>等注解，而解析这个注解又调用了<code>invokeBeanDefinitionRegistryPostProcessors</code>方法，在这个方法中最终会调用<code>ConfigurationClassPostProcessor</code>类中的<code>processConfigBeanDefinitions</code>方法。上周 没有讲到这个方法，下来我们详细说一下。</p>
<h3 id="一、processConfigBeanDefinitions方法调用链"><a href="#一、processConfigBeanDefinitions方法调用链" class="headerlink" title="一、processConfigBeanDefinitions方法调用链"></a>一、<code>processConfigBeanDefinitions</code>方法调用链</h3><p><img src="/archives/79103379/invokeBeanDefinitionRegistryPostProcessors%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%93%BE.png" alt="processConfigBeanDefinitions方法调用链"></p>
<p>跟着<code>processConfigBeanDefinitions</code>方法调用链我们找到这个方法如下图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获得所有的BeanDefinition的Name，存放到candidateNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 循环从所有BeanDefinition拿到配置类并且标记：CONFIGURATION_CLASS_ATTRIBUTE属性</span></span><br><span class="line"><span class="comment">	 * CONFIGURATION_CLASS_ATTRIBUTE属性分两种：</span></span><br><span class="line"><span class="comment">	 * full完整配置类：<span class="doctag">@Configuration</span></span></span><br><span class="line"><span class="comment">	 * lite精简版配置类：<span class="doctag">@Component</span>、<span class="doctag">@Import</span>、<span class="doctag">@ComponentScan</span>、<span class="doctag">@Bean</span>、<span class="doctag">@ImportSource</span></span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 内部有两个标记位来标记是否已经处理过了，这里也会有一串只是盲区</span></span><br><span class="line"><span class="comment">	 * 当我们注册配置类的时候，可以不加<span class="doctag">@Configuration</span>注解，直接使用<span class="doctag">@Component</span>、<span class="doctag">@ComponentScan</span>、<span class="doctag">@Import</span>、<span class="doctag">@ImportSource</span>注解，这时候我们称这个类叫Lite配置类</span></span><br><span class="line"><span class="comment">	 * 如果类上加了<span class="doctag">@Configuration</span>注解，我们称这类叫Full配置类</span></span><br><span class="line"><span class="comment">	 * 如果我们注册了Lite配置类，那么我们getBean(...)这个配置类的时候，会发现他就是原本的那个配置类。</span></span><br><span class="line"><span class="comment">	 * 如果我们注册了Full配置类，那么我们getBean(...)这个配置类的时候，会发现他已经不是原本的那个配置类了，反而已经成CGLIB代理的类了。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">		BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">		<span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *  检查bean是否是configutation类，同时这里会设置bean定义的元数据以及CONFIGURATION_CLASS_ATTRIBUTE属性（full/lite）</span></span><br><span class="line"><span class="comment">		 *  判断是否为配置类，在ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef,this.metadataReaderFactory)</span></span><br><span class="line"><span class="comment">		 *  内部会做判断，这个类是Full配置类还是Lite配置类，并给CONFIGURATION_CLASS_ATTRIBUTE属性加上full/lite标记</span></span><br><span class="line"><span class="comment">		 *  满足条件下将bean定义封装成BeanDefinitionHolder并加入到configCandidates中</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">			configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">	<span class="comment">/** 如果没有注解<span class="doctag">@Configuration</span>类则返回 */</span></span><br><span class="line">	<span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line">	<span class="comment">/** 按照注解中<span class="doctag">@Order</span>给定的顺序排序 */</span></span><br><span class="line">	configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">		<span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">		<span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">		<span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">	SingletonBeanRegistry sbr = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * registry是DefaultListableBeanFactory类型，DefaultListableBeanFactory最终会实现SingletonBeanRegistry接口</span></span><br><span class="line"><span class="comment">	 * 所以可以进入这个if</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">		sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * spring中可以修改默认的bean命名方式，这里就是看用户有没有自定义bean的命名方式。</span></span><br><span class="line"><span class="comment">			 * 如果有自定义bean命名方式，那么会用自定义的bean命名方式替换掉默认命名方式</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">					AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">			<span class="keyword">if</span> (generator != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">				<span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parse each @Configuration class</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建配置类解析器</span></span><br><span class="line"><span class="comment">	 * 解析<span class="doctag">@Component</span>、<span class="doctag">@ComponentScan</span>、<span class="doctag">@Import</span>、<span class="doctag">@Bean</span>、<span class="doctag">@ImportSource</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">			<span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">			<span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">	Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/** 这里真正的解析注解，解析配置类，<span class="doctag">@Components</span>、<span class="doctag">@ComponentScan</span>、<span class="doctag">@Import</span>等 */</span></span><br><span class="line">		parser.parse(candidates);</span><br><span class="line">		parser.validate();</span><br><span class="line"></span><br><span class="line">		Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">		configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">		<span class="comment">/** 通过ConfigurationClassBeanDefinitionReader读取配置数据，并且根据他的内容创建一个Bean定义 */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.reader = <span class="keyword">new</span> ConfigurationClassBeanDefinitionReader(</span><br><span class="line">					registry, <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.environment,</span><br><span class="line">					<span class="keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 注册bean定义</span></span><br><span class="line"><span class="comment">		 * 这一步才会把<span class="doctag">@Import</span>、<span class="doctag">@Bean</span>、<span class="doctag">@ImportSource</span>注解的类转化成BeanDefinition</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 把configClasses加入到alreadyParsed</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">		candidates.clear();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取注册器里面BeanDefinition的数量和candidateNames进行比较</span></span><br><span class="line"><span class="comment">		 * 如果大于的话，说明有新的BeanDefinition注册进来</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">			<span class="comment">/** 从注册器里获取BeanDefinitionNames */</span></span><br><span class="line">			String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">			<span class="comment">/** candidateNames转化为set */</span></span><br><span class="line">			Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">			Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">			<span class="comment">/** 循环alreadyParsed，把ConfigurationClass加入到alreadyParsedClasses */</span></span><br><span class="line">			<span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">				alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">					BeanDefinition bd = registry.getBeanDefinition(candidateName);</span><br><span class="line">					<span class="comment">/** checkConfigurationClassCandidate(...)判断bean是否符合注入条件 */</span></span><br><span class="line">					<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="keyword">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">							!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">						candidates.add(<span class="keyword">new</span> BeanDefinitionHolder(bd, candidateName));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			candidateNames = newCandidateNames;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">	<span class="comment">/** 将 ImportRegistry 注册为 bean 以支持 ImportAware <span class="doctag">@Configuration</span> 类 */</span></span><br><span class="line">	<span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">		sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">		<span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">		<span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">		((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、解析"><a href="#二、解析" class="headerlink" title="二、解析"></a>二、解析</h2><p>找到方法实现之后，接下来我们对方法中逻辑做一下解释。</p>
<h3 id="1、获取所有BeanName"><a href="#1、获取所有BeanName" class="headerlink" title="1、获取所有BeanName"></a>1、获取所有<code>BeanName</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 获得所有的BeanDefinition的Name，存放到candidateNames */</span></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br></pre></td></tr></table></figure>

<p>来获取所有<code>BeanName</code>，并将其放入<code>candidateNames</code>数组中；</p>
<h3 id="2、循环candidateNames数组"><a href="#2、循环candidateNames数组" class="headerlink" title="2、循环candidateNames数组"></a>2、循环<code>candidateNames</code>数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">	BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">	<span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  检查bean是否是configutation类，同时这里会设置bean定义的元数据以及CONFIGURATION_CLASS_ATTRIBUTE属性（full/lite）</span></span><br><span class="line"><span class="comment">	 *  判断是否为配置类，在ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef,this.metadataReaderFactory)</span></span><br><span class="line"><span class="comment">	 *  内部会做判断，这个类是Full配置类还是Lite配置类，并给CONFIGURATION_CLASS_ATTRIBUTE属性加上full/lite标记</span></span><br><span class="line"><span class="comment">	 *  满足条件下将bean定义封装成BeanDefinitionHolder并加入到configCandidates中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">		configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环在第一步获取到的<code>candidateNames</code>数组，根据<code>beanName</code>获得<code>BeanDefinition</code>，判断此<code>BeanDefinition</code>是否已经被处理过了；接着会判断是否为配置类，如果是的话。加入到<code>configCandidates</code>数组；在判断的时候还会标记配置类是属于<code>Full</code>配置类还是属于<code>Lite</code>配置类。</p>
<blockquote>
<p><strong>扫盲点：</strong></p>
<ol>
<li>当注册配置类的时候，可以不加<code>@Configuration</code>注解，直接使用<code>@Component</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportResource</code>等注解，在Spring中这类的配置类称为<code>Lite</code>配置类，如果加了<code>@Component</code>注解，就称之为<code>Full</code>配置类。</li>
<li>如果注册了<code>Lite</code>配置类，当我们在使用<code>getBean()</code>获取这配置类时，会发现他就是原本的那个配置类，如果我们注册了<code>Full</code>配置类，再通过<code>getBean()</code>获取这个配置类的时候，会发现他已经不是原来的那个配置类了，而是被<code>CGLIB</code>代理之后的类。</li>
<li>写一个A类，其中有一个构造方法，打印出”hello word”，在写一个配置类，里面有两个被<code>@Bean</code>注解的方法，其中一个方法<code>new </code>了A类，并且返回A对象，把此方法称之为<code>getA</code>，第二个方法有调用了<code>getA</code>方法，如果配置类是<code>Lite</code>配置类，会发现打印了两次”hello word”，也就是说A类被new了两次，如果配置类是<code>Full</code>配置类，会发现只打印一次”hello word”，也就是说A类被new了一次，这是因为这个类被<code>CGLIB</code>代理了，方法已经被改写了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">&quot;hello word&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 只会打印一次&quot;hello word&quot;</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 会打印两次&quot;hello Word&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="meta">@AutoWired</span></span><br><span class="line">  <span class="keyword">private</span> A a;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> A <span class="title">getA2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getA();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="3、是否有注解-Configuration"><a href="#3、是否有注解-Configuration" class="headerlink" title="3、是否有注解@Configuration"></a>3、是否有注解<code>@Configuration</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断bean有没有被<code>@Configuration</code>标记，如果没有被标记说明不是配置类，直接返回</p>
<h3 id="4、根据-Order排序"><a href="#4、根据-Order排序" class="headerlink" title="4、根据@Order排序"></a>4、根据<code>@Order</code>排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">	<span class="keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">	<span class="keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">	<span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里会按照<code>@Order</code>中指定的顺序进行排序</p>
<h3 id="5、解析配置类"><a href="#5、解析配置类" class="headerlink" title="5、解析配置类"></a>5、解析配置类</h3><p>通过<code>parser.parse</code>方法来解析配置类，改配置类可能是<code>Full</code>配置类，也可能是<code>Lite</code>配置类，进入到这个方法中看一看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">		BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 如果BeanDefinition是AnnotatedBeanDefinition实例，解析注解</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				<span class="comment">/** 解析配置类，<span class="doctag">@Component</span>、<span class="doctag">@Components</span>、<span class="doctag">@Import</span>等 */</span></span><br><span class="line">				parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">				parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里可以配置多个配置类，所以需要做循环处理，因为我们的配置类是<code>AnnotatedBeanDefinition</code>的实例，所以这里会进入到第一个if中的<code>parse()</code>方法中，我们继续点进入看一看逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	processConfigurationClass(<span class="keyword">new</span> ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processConfigurationClass</span><span class="params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断是否跳过注解,解析<span class="doctag">@Conditional</span>注解</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ConfigurationClass existingClass = <span class="keyword">this</span>.configurationClasses.get(configClass);</span><br><span class="line">	<span class="keyword">if</span> (existingClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">				existingClass.mergeImportedBy(configClass);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">			<span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">			<span class="keyword">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">			<span class="keyword">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Recursively process the configuration class and its superclass hierarchy.</span></span><br><span class="line">	<span class="comment">/** 递归处理配置类及其子类的层次结构 */</span></span><br><span class="line">	SourceClass sourceClass = asSourceClass(configClass, filter);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 重点关注的方法</span></span><br><span class="line"><span class="comment">		 * 解析注解<span class="doctag">@Component</span>、<span class="doctag">@ComponentScan</span>、<span class="doctag">@Components</span>、<span class="doctag">@Import</span>等</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (sourceClass != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个方法中进行了判断，以及递归配置类，最终调用<code>doProcessConfigurationClass</code>，来正则实现解析注解</p>
<h3 id="6、doProcessConfigurationClass执行真正解析注解"><a href="#6、doProcessConfigurationClass执行真正解析注解" class="headerlink" title="6、doProcessConfigurationClass执行真正解析注解"></a>6、<code>doProcessConfigurationClass</code>执行真正解析注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title">doProcessConfigurationClass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 解析注解<span class="doctag">@Component</span> */</span></span><br><span class="line">	<span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">		<span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">		processMemberClasses(configClass, sourceClass, filter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process any @PropertySource annotations</span></span><br><span class="line">	<span class="comment">/** 解析注解<span class="doctag">@PropertySource</span>，<span class="doctag">@PropertySource</span>注解用来加载properties文件 */</span></span><br><span class="line">	<span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">			sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">			org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">			processPropertySource(propertySource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">					<span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process any @ComponentScan annotations</span></span><br><span class="line">	<span class="comment">/** 解析注解<span class="doctag">@ComponentScan</span>， <span class="doctag">@ComponentScan</span>注解除了常用的basePackage之外，还有includeFilters，excludeFilters等属性  */</span></span><br><span class="line">	Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">			sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">	<span class="comment">/** 如果没有加<span class="doctag">@ComponentScan</span>注解或者用<span class="doctag">@Condition</span>注解跳过的，就不再进入这个if */</span></span><br><span class="line">	<span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">			!<span class="keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">			<span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">			<span class="comment">/** 如果一个类配置了<span class="doctag">@ComponentScan</span>注解，则会立即执行parse(...)进行扫描，sourceClass.getMetadata().getClassName()就是配置类的名称 */</span></span><br><span class="line">			Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">					<span class="keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">			<span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">			<span class="comment">/** 检查其他的配置类是否设置了扫描定义，并且在需要的是否递归解析 */</span></span><br><span class="line">			<span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">				BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">				<span class="keyword">if</span> (bdCand == <span class="keyword">null</span>) &#123;</span><br><span class="line">					bdCand = holder.getBeanDefinition();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">					<span class="comment">// 二次扫描，因为可能组件类有被@Bean标记的方法，或者组件类本身也有@ComponentScan注解，需要再一次扫描</span></span><br><span class="line">					parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process any @Import annotations</span></span><br><span class="line">	<span class="comment">/** 解析<span class="doctag">@Import</span>注解</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span> 注解是spring中很重要的一个注解，SpringBoot中大量应用了这个注解</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Import</span> 三种类， 一种是<span class="doctag">@Import</span>普通类，一种是Import ImportSelector，还有一种是Import ImportBeanDefinitionRegister</span></span><br><span class="line"><span class="comment">	 * getImports(sourceClass)是获取import的内容，返回的是一个set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line">	<span class="comment">/** 解析<span class="doctag">@ImportResource</span>注解 */</span></span><br><span class="line">	AnnotationAttributes importResource =</span><br><span class="line">			AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">	<span class="keyword">if</span> (importResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">		String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">		Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">			String resolvedResource = <span class="keyword">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">			configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process individual @Bean methods</span></span><br><span class="line">	<span class="comment">/** 解析<span class="doctag">@Bean</span>注解 可以看出获取了带<span class="doctag">@Bean</span>的方法后，不是马上转换成BeanDefinition，而是先用一个set&lt;AnnotationAttributes&gt;接收 */</span></span><br><span class="line">	Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">	<span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">		configClass.addBeanMethod(<span class="keyword">new</span> BeanMethod(methodMetadata, configClass));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process default methods on interfaces</span></span><br><span class="line">	<span class="comment">/** 解析接口默认方法 */</span></span><br><span class="line">	processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Process superclass, if any</span></span><br><span class="line">	<span class="comment">/** 解析超类 */</span></span><br><span class="line">	<span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">		String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">		<span class="keyword">if</span> (superclass != <span class="keyword">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">				!<span class="keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">			<span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">			<span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中才是我们关注的重点，这里将会解析<code>@Component</code>、<code>@PropertySource</code>、<code>@Import</code>、<code>@ImportResource</code>、<code>@Bean</code>注解，并且他们的解析顺序也是从左到右一次进行解析。</p>
<p><img src="/archives/79103379/image-20210906170334883.png" alt="doProcessConfigurationClass解析流程"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>敏感词检测——基于DFA（有穷自动机）实现</title>
    <url>/archives/930adced/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在做一个社交软件，其中我负责的板块是文章发布与文章品论，文章发布是需要后台进行敏感词检测的，不能出现色情、暴力、政治相关的言论。说实话在刚看到这个需求时，脑子里闪现出了用String类中的contains()，方法检测文章中是否有指定的敏感词，然后用replaceAll()方法全部替换掉。然后从百度上下载到一份敏感词词库，我打开一看，emmmmmm。我靠词库中有一万多个敏感词，这TM没法用contains()。于是乎这个方案就丢了。后来在百度的时候，看到了有穷自动机，前缀树匹配、ikAnalyze分词器等解决方案。这里基于效率，我选择了使用DFA（确定有穷自动机）。</p>
<h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><h3 id="DFA-确定有穷自动机"><a href="#DFA-确定有穷自动机" class="headerlink" title="DFA(确定有穷自动机)"></a>DFA(确定有穷自动机)</h3><p>在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。下图展示了其状态的转换，有根从外边来的箭头指向的状态表示初始状态，有个黑圈的状态是接受状态：</p>
<p><img src="/archives/930adced/image-20211207092739057.png" alt="图-1"></p>
<p>现在我们来看看有穷自动机怎么处理输入的字符串：</p>
<ol>
<li>一开始，自动机处于初始状态</li>
<li>输入字符串的第一个字符，这时自动机会查询当前状态上与输入字符相匹配的边，并沿这条边转换到下一个状态。</li>
<li>继续输入下一个字符，重复第二步，查询当前状态上的边并进行状态转换</li>
<li>当字符串全部输入后，如果自动机正好处于接受状态上，就说该自动机<strong>接受了这一字符串</strong>。</li>
</ol>
<h2 id="敏感词检测实现思路"><a href="#敏感词检测实现思路" class="headerlink" title="敏感词检测实现思路"></a>敏感词检测实现思路</h2><p>从上图-1中我们看出是通过某个动作进入到下一个状态的，在这里我们检测敏感词的动作是通过Query查询来到达下一个状态的。通过输入参数可以Query查询“1”、“2”、“3”。我们就转化为了通过查询动作到Java结果集中查找对应的结果。例如：我们有如下敏感词：日本人、日本鬼子。那么我们这个对应到java中怎么构建集合机构呢？</p>
<p>首先：query 日—&gt;{本}、query 本—&gt;{人、鬼子}、query人—&gt;{null}、query鬼—&gt;{子}。结构如下</p>
<p><img src="/archives/930adced/image-20211207123338391.png" alt="图-2"></p>
<p>可以对以上结构进行扩展</p>
<p><img src="/archives/930adced/image-20211207123608096.png" alt="图-3"></p>
<p>这样我们就将我们的敏感词库构建成了一个类似树的结构<code>(其实这个树就是Tire树，也叫作字典树、前缀树)</code>，这样我们来判断一个词是否为敏感词是就只需要找到词的第一个字符下面的子树，遍历这个子树看看是否有我们要检索的词，减少了搜索范围；随着词语的第二个字符、第三个字符进入检查，这个检索范围会越来越小。那么什么是否该结束检索敏感词呢，这里我们需要来一个<strong>标识符表示</strong>。</p>
<p>在Java中我们通过HashMap来实现以上DFA算法的搜索模型构建，构建思路如下：</p>
<ol>
<li><p>在hashMap中查询“日”，看是否存在hashMap中，如果不存在，则证明在我们的词库模型结构中没有以“日”开头的词，这时我们需要直接构建一个这样的数。然后跳至第3步，设置结束标志位isEnd</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashMap = wordMap; <span class="comment">// 将临时map指针指向词库索引，防止直接操作词库</span></span><br><span class="line">HashMap newmap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">newmap.put(<span class="string">&quot;isEnd&quot;</span>,<span class="number">0</span>); <span class="comment">// 表示这个字符不是结束字符</span></span><br><span class="line">hashMap.put(<span class="string">&quot;日&quot;</span>,newmap);  <span class="comment">// HashMap wordMap = new HashMap&lt;String,Object&gt;();</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果在hashMap中找到了，表示存在以“日”开头的敏感词，则需要遍历这个“日”下的子树，跳至第1步，一次匹配“本”、“人”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashMap = wordMap.get(<span class="string">&quot;日&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>判断这个字符是否是该词语中最后一个子。如果是表示敏感词结束，设置标志位为isEnd = 1，否则设置标志位isEnd = 0；</p>
</li>
</ol>
<p>整个流程图如下：</p>
<p><img src="/archives/930adced/image-20211207130939129.png" alt="流程图"></p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p><strong>一下代码都是基于springboot项目的</strong></p>
<p>yml配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">npl:</span></span><br><span class="line">  <span class="attr">baseDir:</span> <span class="string">classpath:/npl</span></span><br><span class="line">  <span class="attr">sensitiveWord:</span></span><br><span class="line">    <span class="attr">replacement:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>



<p>DFA算法抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yunya.community.miniprogram.basic.nlp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ResourceUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: community-miniprogram</span></span><br><span class="line"><span class="comment"> * 自然语言处理，基于有穷自动机算法实现敏感词检测，因为目前敏感词不多，多以通过这种方式可以达到空间换取时间效果，</span></span><br><span class="line"><span class="comment"> * 如果敏感词库日后增大的话，不在适合这种方式，可以通过ikAnalyze分词器来做</span></span><br><span class="line"><span class="comment"> * 确定型有穷自动机算法模型结构如下：</span></span><br><span class="line"><span class="comment"> * 比如当前敏感词中有</span></span><br><span class="line"><span class="comment"> * 中国</span></span><br><span class="line"><span class="comment"> * 中国人</span></span><br><span class="line"><span class="comment"> * 中华人民共和国</span></span><br><span class="line"><span class="comment"> * 结构如下:</span></span><br><span class="line"><span class="comment"> * &quot;中&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *     isEnd: 0,</span></span><br><span class="line"><span class="comment"> *     &quot;国&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *         isEnd: 1,</span></span><br><span class="line"><span class="comment"> *         &quot;人&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *             isEnd: 1</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;,</span></span><br><span class="line"><span class="comment"> *     &quot;华&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *         isEnd:0,</span></span><br><span class="line"><span class="comment"> *         &quot;人&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *             isEnd:0,</span></span><br><span class="line"><span class="comment"> *             &quot;民&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *                 isEnd:0,</span></span><br><span class="line"><span class="comment"> *                 &quot;共&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *                     isEnd:0,</span></span><br><span class="line"><span class="comment"> *                     &quot;和&quot;: &#123;</span></span><br><span class="line"><span class="comment"> *                         isEnd:0,</span></span><br><span class="line"><span class="comment"> *                         &quot;国&quot;:&#123;</span></span><br><span class="line"><span class="comment"> *                             isEnd:1</span></span><br><span class="line"><span class="comment"> *                         &#125;</span></span><br><span class="line"><span class="comment"> *                     &#125;</span></span><br><span class="line"><span class="comment"> *                 &#125;</span></span><br><span class="line"><span class="comment"> *             &#125;</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 基于DFA算法的自然语言处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-12-06 09:23</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NplAbstractHandler</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;npl.baseDir&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String baseDir = <span class="string">&quot;classpath:/npl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TEXT_FILE = <span class="string">&quot;npl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File[] wordTextFiles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String ISEND = <span class="string">&quot;isend&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">enum</span> <span class="title">IS_END</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检索词结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZERO,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检索词未结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ONE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">enum</span> <span class="title">MATCH_TYPE</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最小匹配规则，如：敏感词库[&quot;中国&quot;,&quot;中国人&quot;]，语句：&quot;我是中国人&quot;，匹配结果：我是[中国]人</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MINIMUM_MATCH,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最大匹配规则，如：敏感词库[&quot;中国&quot;,&quot;中国人&quot;]，语句：&quot;我是中国人&quot;，匹配结果：我是[中国人]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MAXIMUM_MATCH</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBaseDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaseDir</span><span class="params">(String baseDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baseDir = baseDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里主要获取配置文件中的所有词库</span></span><br><span class="line">        File[] files = ResourceUtils.getFile(<span class="string">&quot;classpath:&quot;</span>).listFiles(pathname -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (TEXT_FILE.equals(pathname.getName())) &#123;</span><br><span class="line">                baseDir = pathname.getPath();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wordTextFiles = files[<span class="number">0</span>].listFiles();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化DFA处理模型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dfaWordMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wordSet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HashMap dfaWordMap, Set&lt;String&gt; wordSet)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始初始化词库&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        HashMap currentMap;</span><br><span class="line">        Iterator&lt;String&gt; iterator = wordSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            currentMap = dfaWordMap;</span><br><span class="line">            String currentWord = iterator.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentWord.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> keyWord = currentWord.charAt(i);</span><br><span class="line">                Object nextMap = currentMap.get(keyWord);</span><br><span class="line">                <span class="keyword">if</span> (nextMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将map的指针指向nextMap，以便于下次循环使用</span></span><br><span class="line">                    currentMap = (HashMap) nextMap;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HashMap&lt;Object, Object&gt; newWord = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    newWord.put(ISEND, IS_END.ZERO);</span><br><span class="line">                    currentMap.put(keyWord, newWord);</span><br><span class="line">                    <span class="comment">// 将map指针指向当前新创建的词节点，下次的新词要在这个新词后面添加</span></span><br><span class="line">                    currentMap = newWord;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果字符是词的结尾字符，设置结束表示isEnd=1</span></span><br><span class="line">                <span class="comment">// 这里减1是因为执行完本次循环，i会自增，所以这里需要先减1</span></span><br><span class="line">                <span class="keyword">if</span> (i == currentWord.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    currentMap.put(ISEND, IS_END.ONE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;词库初始化完成,一共&#123;&#125;个词,用时&#123;&#125;ms&quot;</span>, wordSet.size(), (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断文本中是否存在词库中指定的词，存在则返回字符串长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dfaWordMap 词库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text       文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beginIndex 文本开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType  匹配模式,参考 &#123;<span class="doctag">@MATCH</span>_TYPE&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回敏感词长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">checkWord</span><span class="params">(HashMap dfaWordMap, String text, <span class="keyword">int</span> beginIndex, Enum matchType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 敏感词长度</span></span><br><span class="line">        AtomicInteger wordLength = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        Map currentMap = dfaWordMap;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &lt; text.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> keyWord = text.charAt(i);</span><br><span class="line">            currentMap = (Map) currentMap.get(keyWord);</span><br><span class="line">            <span class="keyword">if</span> (currentMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wordLength.getAndIncrement();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == ((Integer) currentMap.get(ISEND))) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (MATCH_TYPE.MINIMUM_MATCH == matchType) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wordLength.get() &lt; <span class="number">1</span> || !flag) &#123;</span><br><span class="line">            wordLength.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordLength.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含词库中的敏感词</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dfaWordMap 词库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text       文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType  匹配类型 参考&#123;<span class="doctag">@MATCH</span>_TYPE&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(HashMap dfaWordMap, String text, Enum matchType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> wordLength = checkWord(dfaWordMap, text, i, matchType);</span><br><span class="line">            <span class="keyword">if</span> (wordLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文本中的敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dfaWordMap 词库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType 匹配模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回敏感词集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">getSensitiveWordInText</span><span class="params">(HashMap dfaWordMap, String text, Enum matchType)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; sensitiveWordSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> wordLength = checkWord(dfaWordMap, text, i, matchType);</span><br><span class="line">            <span class="keyword">if</span> (wordLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sensitiveWordSet.add(text.substring(i, i + wordLength));</span><br><span class="line">                i = i + wordLength - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sensitiveWordSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换文本中的敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dfaWordMap 词库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaceChar 代表敏感词的字符，替换后文本将使用这里指定的符号代表敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType 匹配类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回替换后的文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">replaceSensitiveWord</span><span class="params">(HashMap dfaWordMap, String text, <span class="keyword">char</span> replaceChar, Enum matchType)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; sensitiveWordSet = getSensitiveWordInText(dfaWordMap, text, matchType);</span><br><span class="line">        Iterator&lt;String&gt; iterator = sensitiveWordSet.iterator();</span><br><span class="line">        String resultText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String sensitive = iterator.next();</span><br><span class="line">            String replaceChars = getReplaceChars(replaceChar, sensitive.length());</span><br><span class="line">            resultText = text.replaceAll(sensitive, replaceChars);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取替换的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaceChar 替换字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 字符长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回替换字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getReplaceChars</span><span class="params">(<span class="keyword">char</span> replaceChar,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        String replaceStr = String.valueOf(replaceChar);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            replaceStr += replaceStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaceStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载敏感词本地文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">loadSensitiveWordResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.wordTextFiles == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;在&#123;&#125;下没有找到相应的txt词库文件，敏感词检测将不能使用!!&quot;</span>,baseDir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;开始加载本地词库&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">for</span> (File file : wordTextFiles) &#123;</span><br><span class="line">            wordSet.addAll(loadFile(file));</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;本地词库加载完成，共有&#123;&#125;个词，耗时&#123;&#125;ms&quot;</span>,wordSet.size(),(System.currentTimeMillis() - start));</span><br><span class="line">        <span class="keyword">return</span> wordSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">loadFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file),<span class="number">2048</span>);</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                words.add(line.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>敏感词处理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yunya.community.miniprogram.basic.nlp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Program</span>: community-miniprogram</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 敏感词处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: LHB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: v0.0.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2021-12-06 09:31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveWordHandler</span> <span class="keyword">extends</span> <span class="title">NplAbstractHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** dfa敏感词库 */</span></span><br><span class="line">    <span class="keyword">private</span> HashMap dfaWordMap;</span><br><span class="line">    <span class="comment">/** 本地词库 */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; wordModelSet;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;npl.sensitiveWord.replacement&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String replacement = <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本中是否包含敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType 敏感词匹配类型 参考&#123;<span class="doctag">@DfaAbstractHandler</span>&#125;类中的&#123;<span class="doctag">@MATCH</span>_TYPE&#125;变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String text, Enum matchType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(dfaWordMap,text,matchType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文本中是否包含敏感词,默认最小匹配模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(dfaWordMap,text,MATCH_TYPE.MINIMUM_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文本中的敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType 敏感词匹配类型 参考&#123;<span class="doctag">@DfaAbstractHandler</span>&#125;类中的&#123;<span class="doctag">@MATCH</span>_TYPE&#125;变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回敏感词集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSensitiveWordInText</span><span class="params">(String text, Enum matchType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSensitiveWordInText(dfaWordMap,text,matchType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文本中的敏感词, 默认最小模式匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回敏感词集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSensitiveWordInText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSensitiveWordInText(dfaWordMap,text,MATCH_TYPE.MINIMUM_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换文本中的敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replaceChar 代表敏感词的字符，替换后文本将使用这里指定的符号代表敏感词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matchType 敏感词匹配类型 参考&#123;<span class="doctag">@DfaAbstractHandler</span>&#125;类中的&#123;<span class="doctag">@MATCH</span>_TYPE&#125;变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回替换后的文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSensitiveWord</span><span class="params">(String text, Enum matchType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> replaceSensitiveWord(dfaWordMap,text,replacement.charAt(<span class="number">0</span>),matchType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替换文本中的敏感词,默认最小模式匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回替换后的文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSensitiveWord</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> replaceSensitiveWord(dfaWordMap,text,replacement.charAt(<span class="number">0</span>),MATCH_TYPE.MINIMUM_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 这里主要是初始化操作</span></span><br><span class="line">        <span class="keyword">this</span>.wordModelSet = loadSensitiveWordResources();</span><br><span class="line">        <span class="keyword">this</span>.dfaWordMap = <span class="keyword">new</span> HashMap&lt;&gt;(wordModelSet.size());</span><br><span class="line">        init(<span class="keyword">this</span>.dfaWordMap,wordModelSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/archives/930adced/image-20211207131205649.png" alt="测试结果"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFA(有穷自动机)</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——图论基础</title>
    <url>/archives/fc93130d/</url>
    <content><![CDATA[<h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><ul>
<li><p>图形结构是一种比树形结构更复杂的<strong>非线性结构</strong>。在树形结构中，结点间具有分支层次关系，每一层的结点 只能和上一层中的至多一个结点相关，但可能和下一层的多个结点相关。而在图形结构中，任意两个结点之间都可能相关，即结点之间的领接关系可以是任意的。</p>
</li>
<li><p>图可以分为两种：有向图和无向图</p>
<p><img src="/archives/fc93130d/image-20211130163803330.png" alt="有向图"><br><img src="/archives/fc93130d/image-20211130163945297.png" alt="无向图"></p>
</li>
</ul>
<h2 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h2><ol>
<li><strong>顶点：</strong> 途中的任何一个结点，都可以称作顶点，<strong>在图中不允许没有顶点，线性表可以是空表，树可以是空树，但是图不可以是空图，图可以没有边，但至少要有一个顶点</strong> </li>
<li><strong>边：</strong> 连接到顶点的线就是边，即顶点到顶点之间的连线</li>
<li><strong>顶点的度：</strong> 连接该顶点的边的条数</li>
<li><strong>出度：</strong> 箭头从这个顶点指出去的就是出度</li>
<li><strong>入度：</strong> 箭头方向指向这个顶点的就是入度</li>
<li><strong>有向图：</strong> 顶点与顶点之间的关系是有方向的</li>
<li><strong>无向图：</strong> 顶点与顶点之间的关系没有方向的</li>
</ol>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="使用邻接矩阵-二维数组-来存储图形结构"><a href="#使用邻接矩阵-二维数组-来存储图形结构" class="headerlink" title="使用邻接矩阵(二维数组)来存储图形结构"></a>使用邻接矩阵(二维数组)来存储图形结构</h3><p>1、如果有N个节点，那么我们就需要使用N*N的矩阵来存储</p>
<p><img src="/archives/fc93130d/image-20211130163803330.png" alt="有向图"></p>
<p>在上面的有向图中共有7个顶点，那么我们就需要使用一个7*7的二维数组来进行存储，我们将A-G转为0-6对应的数组下标，二维数组的横坐标代表当前的节点，纵坐标代表其他节点，如果当前的值为1，表示两个点之间存在关联，否则没有关联。如下：</p>
<p>  (1) A[0][1] = 1 :  第0个元素和第1个元素是有关联的（即A和B有联系）</p>
<p>  (2) A[1][0] = 0 : 第1个元素和第0个元素没有关联（即B和A之间没有联系，因为是有向图）</p>
<p>  (3) A[1][2] = 1 : 第1个元素和第二个元素有关联（即B和C之间有联系）</p>
<p>……依次进行映射，得到如下的图</p>
<p><img src="/archives/fc93130d/image-20211130173220434.png" alt="邻接矩阵"></p>
<blockquote>
<p>这里会有一个稀疏矩阵的概念：矩阵中各个顶点之间的关联很少（即存在大量0，只有很少的值为1），这样就会有一个问题——保存图形结构的二维数组中大量空间被浪费掉的情况，为了减少这种不必要的浪费，可以使用<strong>邻接表</strong>来存储图形</p>
</blockquote>
<h3 id="使用领接表-链表-来存储图形结构"><a href="#使用领接表-链表-来存储图形结构" class="headerlink" title="使用领接表(链表)来存储图形结构"></a>使用领接表(链表)来存储图形结构</h3><p>使用邻接表(链表)的方式来存储图形和Map中存储entity元素有点类似。</p>
<p><img src="/archives/fc93130d/image-20211130163803330.png" alt="有向图"></p>
<p>接下来我们利用链表将上述有向图存储起来</p>
<p><img src="/archives/fc93130d/image-20211130175554541.png" alt="使用邻接表(链表)保存图形结构"></p>
<h3 id="两种存储方式对比"><a href="#两种存储方式对比" class="headerlink" title="两种存储方式对比"></a>两种存储方式对比</h3><ul>
<li><strong>领接矩阵(数组)：</strong> 浪费空间，但是操作都是在内存中进行，速度快。<strong>合适处理数据量不大的场景</strong></li>
<li><strong>邻接表(链表)：</strong> 节省空间，速度比较慢，<strong>适合大数据量场景</strong></li>
</ul>
<h2 id="图形的遍历"><a href="#图形的遍历" class="headerlink" title="图形的遍历"></a>图形的遍历</h2><p>图形的遍历算法有两种：深度优先算法(DFS)和广度优先算法(BFS)</p>
<blockquote>
<p><strong>核心关键：</strong> </p>
<ul>
<li><strong>队列(queue)：每次需要<code>pop()</code>取队列头元素，并且将头元素有关的节点全部加入队列。</strong></li>
<li><strong>标记数组mark：每次将遍历过的结点打标记，下次遍历将不会再遍历有标记的结点。<code>深度优先算法中，由于使用递归，存在回溯操作，所以在递归完后需要将结点标记取消</code></strong> </li>
<li>以上两步操作参考下面代码部分</li>
</ul>
</blockquote>
<h3 id="广度优先算法-BFS"><a href="#广度优先算法-BFS" class="headerlink" title="广度优先算法(BFS)"></a>广度优先算法(BFS)</h3><p>广度优先遍历就是类似于树的层次遍历，利用一个队列，先找到一个点，然后我们把这个点加入到队列中，从队列中取出一个值，依次找出这个点的关联结点加入到队列中，循环这个操作，知道队列为空，此时我们就已经完成了整个图的遍历。</p>
<blockquote>
<p><strong>注意：</strong> 这里同样我们需要对遍历过的点进行标记，如果这个点在队列中加入过，则不能再继续添加到队列中。比如：A→B，B→A，此时如果不做标记，A走到B，尝试B的时候，因为B到A又要尝试A一遍，会陷入死循环（有点类似Spring中的循环依赖）。</p>
</blockquote>
<p>例如：将下面有向图做广度遍历</p>
<p><img src="/archives/fc93130d/image-20211130163803330.png" alt="有向图"></p>
<p>广度优先遍历<br>1、取一个点出来，这里我们从A开始，将A点放入队列中<br>2、从对头取出一个元素<br>3、将与A有关的所有结点放入队列中<br>4、标记A为遍历过的点，被标记过的结点不会再走</p>
<table>
<thead>
<tr>
<th align="center">队列</th>
<th align="center">入队结点</th>
<th align="center">标记结点</th>
<th align="center">出队结点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[A]</td>
<td align="center">A</td>
<td align="center">A</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">[B]</td>
<td align="center">B</td>
<td align="center">A,B</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">[C,F]</td>
<td align="center">C,F</td>
<td align="center">A,B,C,F</td>
<td align="center">C</td>
</tr>
<tr>
<td align="center">[F,E]</td>
<td align="center">E</td>
<td align="center">A,B,C,F,E</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">[E,G]</td>
<td align="center">G</td>
<td align="center">A,B,C,F,E,G</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">[G,D]</td>
<td align="center">D(B结点已经被标记，不会再入队)</td>
<td align="center">A,B,C,F,E,G,D</td>
<td align="center">G</td>
</tr>
<tr>
<td align="center">[D]</td>
<td align="center">没有，G结点下没有关联结点</td>
<td align="center">A,B,C,F,E,G,D</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">[]</td>
<td align="center">没有，队列为空，结束遍历</td>
<td align="center">A,B,C,F,E,G,D</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>最终上面有向图的广度遍历结果为：<code>ABCFEGD</code></p>
<h3 id="深度优先算法-DFS"><a href="#深度优先算法-DFS" class="headerlink" title="深度优先算法(DFS)"></a>深度优先算法(DFS)</h3><p>深度优先算法可以想象成是走迷宫，我们会选择一个方向一路走到底，直到不能走了然后再返回上一步继续尝试其他方向，在代码中就是递归+回溯，这就是深度优先遍历。同样，我们需要标记已经走过的点，原因和广度优先遍历一样，防止陷入死循环。</p>
<blockquote>
<p>在深度优先算法中有一个重要的优化手段就是<strong>剪枝</strong> 。</p>
</blockquote>
<p>举例说明：</p>
<p><img src="/archives/fc93130d/image-20211130163803330.png" alt="有向图"></p>
<p>找到一个节点，先按照一个方向一致走下去(反映到代码中就是递归)，并且将走过的点进行标记，下次不再走标记过的点，如果没有与当前点有关联的点了，就一步一步往会返(代码中就是回溯操作)。</p>
<table>
<thead>
<tr>
<th align="center">路径</th>
<th align="center">标记点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">A</td>
</tr>
<tr>
<td align="center">A-&gt;B</td>
<td align="center">A,B</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;E</td>
<td align="center">A,B,E</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;E-&gt;D</td>
<td align="center">A,B,E,D</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;E-&gt;D-&gt;C</td>
<td align="center">A,B,E,D,C</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;E-&gt;D(回溯，因为跟C有关的点都被标记了)</td>
<td align="center">A,B,E,D,C</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;E(回溯，跟D有关的点都被标记)</td>
<td align="center">A,B,E,D,C</td>
</tr>
<tr>
<td align="center">A-&gt;B(回溯，跟E有关的点都被标记)</td>
<td align="center">A,B,E,D,C</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;F(C被标记，不用走)</td>
<td align="center">A,B,E,D,C,F</td>
</tr>
<tr>
<td align="center">A-&gt;B-&gt;F-&gt;G</td>
<td align="center">A,B,E,D,C,F,G</td>
</tr>
</tbody></table>
<p>上面我们是对节点的遍历，如果我们需要的是所有的路径，则在回退节点的时候，<strong>还应该将已经遍历过的标记的点也进行回退，这样我们就可以实现全部路径的遍历，可以参考后面的算法示例</strong></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="解救美女1-使用BFS广度优先算法解决"><a href="#解救美女1-使用BFS广度优先算法解决" class="headerlink" title="解救美女1 (使用BFS广度优先算法解决)"></a>解救美女1 (使用BFS广度优先算法解决)</h3><p>有一天，小美和你去玩迷宫。但是方向感不好的小美很快就迷路了，你得知后便去解救无助的小美，你已经弄清楚了迷宫的地图，现在你要知道从你当前位置出发你是否能够达到小美的位置？</p>
<p><img src="/archives/fc93130d/image-20211201110711135.png" alt="使用BFS广度优先算法解决"></p>
<blockquote>
<ul>
<li><p>1表示地图上的障碍物，0表示有路可以走</p>
</li>
<li><p>邻接矩阵（二维数组）：</p>
<p>0(你)    0    1    0</p>
<p>0    0    0    0</p>
<p>0    0    1    0</p>
<p>0    1    0(小美)    0</p>
<p>0    0    0    1</p>
</li>
</ul>
</blockquote>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 有一天，小美和你去玩迷宫，但是方向感不好的小美很快就迷路了，你得知之后便去营救，你已经弄清楚了迷宫的地图，现在你要知道你从当前位置出发是否能够到达小美的位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 1表示地图上的障碍物，0表示有路可以走</span></span><br><span class="line"><span class="comment"> * - 邻接矩阵（二维数组）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0（你） 0 1 0</span></span><br><span class="line"><span class="comment"> * 0         0 0 0</span></span><br><span class="line"><span class="comment"> * 0 0 1 0</span></span><br><span class="line"><span class="comment"> * 0 1 0（小美） 0</span></span><br><span class="line"><span class="comment"> * 0 0 0 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来表示地图总共有几行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来表示地图总共有几列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标的横坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dx;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标的纵坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储邻接矩阵</span></span><br><span class="line"><span class="comment">     * 就是地图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[][];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来标记数据，走过的点，不能再重复入BFS的队列，避免死循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mark[][];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> data[][], <span class="keyword">boolean</span> mark[][])</span> </span>&#123;</span><br><span class="line">        n = row;</span><br><span class="line">        m = col;</span><br><span class="line">        <span class="keyword">this</span>.dx = dx;</span><br><span class="line">        <span class="keyword">this</span>.dy = dy;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找寻过程函数</span></span><br><span class="line"><span class="comment">     * 思路就是我们将当前点的相邻的节点全部入队列，依次从队列中取值，然后循环这个操作，直至队列为空，这就是BFS（广度优先）遍历全部图的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x X表示自己当前位置的横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y y表示自己当前位置的纵坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否当前位置越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) &#123;</span><br><span class="line">            <span class="comment">// 表示当前已经下标越界</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否当前自己的位置就是目标的位置</span></span><br><span class="line">        <span class="keyword">if</span> (x == dx &amp;&amp; y == dy) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前位置就是目标位置: X: &quot;</span> + x + <span class="string">&quot;, Y: &quot;</span> + y);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前自己的节点进行标记，下次不会再进行处理</span></span><br><span class="line">        mark[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 声明一个广度遍历的队列（BFS就是借助队列实现的）,队列的大小是邻接矩阵的长乘宽</span></span><br><span class="line">        Queue&lt;Point&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(n * m);</span><br><span class="line">        <span class="comment">// 将自己当前的位置封装成Point对象</span></span><br><span class="line">        Point start = <span class="keyword">new</span> Point();</span><br><span class="line">        start.x = x;</span><br><span class="line">        start.y = y;</span><br><span class="line">        <span class="comment">// 将自己现在这个节点添加到BFS的队列中</span></span><br><span class="line">        queue.add(start);</span><br><span class="line">        <span class="comment">// 这个是个经典，以后都可以考虑，因为我们是用二维数组对其进行存储，且我们只能上下左右走，无法斜着走，所以我们应该四个方向进行判断</span></span><br><span class="line">        <span class="comment">// 这里定义了一个二维数组，这四个元素和我们当前的位置的横纵坐标相加，就会得到我们上下左右的点</span></span><br><span class="line">        <span class="keyword">int</span> next[][] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始遍历队列，若当前队列中不为空继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 取出队列中的第一个元素</span></span><br><span class="line">            Point point = queue.poll();</span><br><span class="line">            <span class="comment">// 开始对当前节点的上下左右节点的处理，将其入队列，利用BFS遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 新的横坐标</span></span><br><span class="line">                <span class="keyword">int</span> nextx = point.x + next[i][<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 新的纵坐标</span></span><br><span class="line">                <span class="keyword">int</span> nexty = point.y + next[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 判断新的位置的横纵坐标是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (nextx &lt; <span class="number">1</span> || nextx &gt; n || nexty &lt; <span class="number">1</span> || nexty &gt; m)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// data中的值若是1 表示障碍物，不能走</span></span><br><span class="line">                <span class="comment">// 还要判断是否该点已经被标记，如果标记也不用走，避免重复入队，死循环</span></span><br><span class="line">                <span class="keyword">if</span> (data[nextx][nexty] == <span class="number">0</span> &amp;&amp; !mark[nextx][nexty]) &#123;</span><br><span class="line">                    <span class="comment">// 此时是表示可以继续走</span></span><br><span class="line">                    <span class="comment">// 判断是否已经到达目标点</span></span><br><span class="line">                    <span class="keyword">if</span> (nextx == dx &amp;&amp; nexty == dy) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;已经找到目标位置: X: &quot;</span> + nextx + <span class="string">&quot;, Y: &quot;</span> + nexty);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 赋值新的Point</span></span><br><span class="line">                    Point newPoint = <span class="keyword">new</span> Point();</span><br><span class="line">                    newPoint.x = nextx;</span><br><span class="line">                    newPoint.y = nexty;</span><br><span class="line">                    <span class="comment">// 将当前节点进行标记，避免下次重复入队列</span></span><br><span class="line">                    mark[nextx][nexty] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 入队</span></span><br><span class="line">                    queue.add(newPoint);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;无法找到目标点&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 我的思路， </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Pointer pointer)</span> </span>&#123;</span><br><span class="line">		ArrayBlockingQueue&lt;Pointer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Pointer&gt;(n * m);</span><br><span class="line">		queue.add(pointer);</span><br><span class="line">		mark[pointer.x][pointer.y] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			Pointer point = queue.poll();</span><br><span class="line">			<span class="comment">// 向下走</span></span><br><span class="line">			<span class="keyword">if</span> (point.x + <span class="number">1</span> &lt; m &amp;&amp; point.y &lt; n &amp;&amp; data[point.x + <span class="number">1</span>][point.y] == <span class="number">0</span> &amp;&amp; !mark[point.x + <span class="number">1</span>][point.y]) &#123;</span><br><span class="line">				mark[point.x + <span class="number">1</span>][point.y] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (point.x + <span class="number">1</span> == dy &amp;&amp; point.y == dx) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;向下走： &quot;</span> + <span class="keyword">new</span> Pointer(point.x+<span class="number">1</span>,point.y));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				queue.add(<span class="keyword">new</span> Pointer(point.x + <span class="number">1</span>, point.y));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 向上走</span></span><br><span class="line">			<span class="keyword">if</span> (point.x - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; point.y &lt; n &amp;&amp; data[point.x - <span class="number">1</span>][point.y] == <span class="number">0</span> &amp;&amp; !mark[point.x - <span class="number">1</span>][point.y]) &#123;</span><br><span class="line">				mark[point.x - <span class="number">1</span>][point.y] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (point.x - <span class="number">1</span> == dy &amp;&amp; point.y == dx) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;向上走： &quot;</span> + <span class="keyword">new</span> Pointer(point.x-<span class="number">1</span>,point.y));</span><br><span class="line">					System.out.println(Arrays.asList(mark));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				queue.add(<span class="keyword">new</span> Pointer(point.x - <span class="number">1</span>, point.y));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 向右走</span></span><br><span class="line">			<span class="keyword">if</span> (point.y + <span class="number">1</span> &lt; n &amp;&amp; point.x &lt; m &amp;&amp; data[point.x][point.y + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; !mark[point.x][point.y + <span class="number">1</span>]) &#123;</span><br><span class="line">				mark[point.x][point.y + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (point.x == dy &amp;&amp; point.y + <span class="number">1</span> == dx) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;向右走： &quot;</span> + <span class="keyword">new</span> Pointer(point.x,point.y + <span class="number">1</span>));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				queue.add(<span class="keyword">new</span> Pointer(point.x, point.y + <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 向左走</span></span><br><span class="line">			<span class="keyword">if</span> (point.y - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; point.x &lt; m &amp;&amp; data[point.x][point.y - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; !mark[point.x][point.y - <span class="number">1</span>]) &#123;</span><br><span class="line">				mark[point.x][point.y - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">if</span> (point.x == dy &amp;&amp; point.y - <span class="number">1</span> == dx) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;向左走： &quot;</span> + <span class="keyword">new</span> Pointer(point.x,point.y - <span class="number">1</span>));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				queue.add(<span class="keyword">new</span> Pointer(point.x, point.y - <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主函数，用来测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建BFS的队列</span></span><br><span class="line">        <span class="comment">// 加1是因为我们不用0有关的格子，我们相当于横纵坐标从1开始</span></span><br><span class="line">        <span class="keyword">int</span> data[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化标记数组</span></span><br><span class="line">        <span class="keyword">boolean</span> mark[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                data[i][j] = cin.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入目标点</span></span><br><span class="line">        <span class="keyword">int</span> dx = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> dy = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值我们输入的起始和终止</span></span><br><span class="line">        <span class="keyword">int</span> x = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> y = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        BFS bfs = <span class="keyword">new</span> BFS(n, m ,dx, dy, data, mark);</span><br><span class="line">        bfs.bfs(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个下标类，其中里面就两个属性 X Y</span></span><br><span class="line"><span class="comment"> * 该类用来表示当前的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 横坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 纵坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解救美女2（DFS深度度优先算法解决）"><a href="#解救美女2（DFS深度度优先算法解决）" class="headerlink" title="解救美女2（DFS深度度优先算法解决）"></a>解救美女2（DFS深度度优先算法解决）</h3><p>有一天，小美和你去玩迷宫，但是方向感不好的小美很快就迷路了，你得知之后便去营救，你已经弄清楚了迷宫的地图，现在要求你以最快的速度去解救小美，你能计算出最快需要几步么？以及求出其最快的路径</p>
<p><img src="/archives/fc93130d/image-20211201110711135.png" alt="使用DFS深度优先算法解决"></p>
<blockquote>
<ul>
<li><p>1表示地图上的障碍物，0表示有路可以走</p>
</li>
<li><p>邻接矩阵（二维数组）：</p>
<p>0(你)    0    1    0</p>
<p>0    0    0    0</p>
<p>0    0    1    0</p>
<p>0    1    0(小美)    0</p>
<p>0    0    0    1</p>
</li>
</ul>
</blockquote>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - 有一天，小美和你去玩迷宫，但是方向感不好的小美很快就迷路了，你得知之后便去营救，你已经弄清楚了迷宫的地图，现在要求你以最快的速度去解救小美，你能计算出最快需要几步么？以及求出其最快的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 1表示地图上的障碍物，0表示有路可以走</span></span><br><span class="line"><span class="comment"> * - 邻接矩阵（二维数组）：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0（你） 0 1 0</span></span><br><span class="line"><span class="comment"> * 0         0 0 0</span></span><br><span class="line"><span class="comment"> * 0 0 1 0</span></span><br><span class="line"><span class="comment"> * 0 1 0（小美） 0</span></span><br><span class="line"><span class="comment"> * 0 0 0 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来表示地图总共有几行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来表示地图总共有几列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标的横坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dx;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标的纵坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来存储邻接矩阵</span></span><br><span class="line"><span class="comment">     * 就是地图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[][];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来标记数据，走过的点，不能再重复入BFS的队列，避免死循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mark[][];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来保存最小的步数 初始值设置为最大，求最小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minStep = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是个经典，以后都可以考虑，因为我们是用二维数组对其进行存储，且我们只能上下左右走，无法斜着走，所以我们应该四个方向进行判断</span></span><br><span class="line"><span class="comment">     * 这里定义了一个二维数组，这四个元素和我们当前的位置的横纵坐标相加，就会得到我们上下左右的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next[][] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来保存当前路线的路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stack&lt;Point&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来保存所有的路径 其key是步数，value是list，因为可能有多种最短路径的实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;Integer, List&lt;Stack&lt;Point&gt;&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> data[][], <span class="keyword">boolean</span> mark[][])</span> </span>&#123;</span><br><span class="line">        n = row;</span><br><span class="line">        m = col;</span><br><span class="line">        <span class="keyword">this</span>.dx = dx;</span><br><span class="line">        <span class="keyword">this</span>.dy = dy;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS深度遍历，通过深度遍历可以找到最小的步数，以及最小的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 当前自己的位置的横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 当前自己的位置的纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step 当前已经走了多少步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前的位置是否就是目标位置</span></span><br><span class="line">        <span class="keyword">if</span> (x == dx &amp;&amp; y == dy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!result.containsKey(step)) &#123;</span><br><span class="line">                result.put(step, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            result.get(step).add((Stack&lt;Point&gt;) stack.clone());</span><br><span class="line">            <span class="comment">// 如果是当前的位置，判断这次找到目标的步数是否比我们设置的最小的步数小</span></span><br><span class="line">            <span class="keyword">if</span> (step &lt; minStep) &#123;</span><br><span class="line">                minStep = step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出递归</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环走四周的节点，上下左右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 下一个位置的横坐标</span></span><br><span class="line">            <span class="keyword">int</span> nextx = x + next[i][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 下一个位置的纵坐标</span></span><br><span class="line">            <span class="keyword">int</span> nexty = y + next[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 判断是否下一个位置超过了二维数组的边界</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">1</span> || nextx &gt; n || nexty &lt; <span class="number">1</span> || nexty &gt; m) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断其下一个位置是否可以走，即判断下一个位置是否是障碍物 0不是 1 是</span></span><br><span class="line">            <span class="comment">// 判断下一个位置是否已经标记，已经标记的不能走</span></span><br><span class="line">            <span class="keyword">if</span> (data[nextx][nexty] == <span class="number">0</span> &amp;&amp; !mark[nextx][nexty]) &#123;</span><br><span class="line">                <span class="comment">// 如果此时完全正常 下一个位置可以走，则将其标志位先改为true</span></span><br><span class="line">                mark[nextx][nexty] = <span class="keyword">true</span>;</span><br><span class="line">                Point point = <span class="keyword">new</span> Point();</span><br><span class="line">                point.x = nextx;</span><br><span class="line">                point.y = nexty;</span><br><span class="line">                <span class="comment">// 将当前下标保存到栈中</span></span><br><span class="line">                stack.push(point);</span><br><span class="line">                <span class="comment">// 递归往下一个走，直到找到为止</span></span><br><span class="line">                dfs(nextx, nexty, step + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯，将当前的标志位取掉，因为我们回溯要假设这个位置没有走过</span></span><br><span class="line">                mark[nextx][nexty] = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 因为回溯所以需要出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] data = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                data[i][j] = cin.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dx = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> dy = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> x = cin.nextInt();</span><br><span class="line">        <span class="keyword">int</span> y = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我的起始位置标记位true</span></span><br><span class="line">        mark[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        DFS dfs = <span class="keyword">new</span> DFS(n,m,dx,dy,data,mark);</span><br><span class="line">        dfs.dfs(x,y,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小步数是：&quot;</span> + dfs.minStep + <span class="string">&quot;；一共有&quot;</span>+dfs.result.get(dfs.minStep).size()+<span class="string">&quot;种方案到达目标&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Stack&lt;Point&gt;&gt; stacks = dfs.result.get(dfs.minStep);</span><br><span class="line">        <span class="keyword">for</span> (Stack&lt;Point&gt; stack: stacks) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Point point : stack) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;-&gt;(&quot;</span> + point.x + <span class="string">&quot;,&quot;</span> + point.y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/archives/fc93130d/image-20211201144148795.png" alt="深度优先代码运行结果"></p>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><ul>
<li>知识图谱：推荐算法，数据挖掘</li>
<li>社交网络：QQ推荐好友功能</li>
<li>图数据库：Neo4j</li>
<li>路径问题：导航软件</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图形结构</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法——迪杰斯特拉算法</title>
    <url>/archives/bb86941a/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>上一章中，我们学了图形遍历的两种遍历方式</p>
<ul>
<li>深度优先算法(DFS)</li>
<li>广度优先算法(BFS)</li>
</ul>
<p>并且通过一个营救美女小美的案例来实现了代码。那么接着想一想，如果要营救的小美是在现实生活世界中的某个位置呢？我们怎么去很快的找到最有路径，尽快的将小美营救出来呢？</p>
<p><img src="/archives/bb86941a/image-20211201171506829.png" alt="图例"></p>
<p>这时候使用DFS算法呢，显然不行的，我们知道DFS算法中核心逻辑是递归+回溯；上一章中营救小美案例中只有几个点，所以在递归的时候是比较快的；可是如果是在现实地图中，任意一个位置都是一个点，这么多点，如果在使用DFS算法，只能压死电脑了。既然DFS行不通。那么我们就要改用其他算法了——迪杰斯特拉算法。</p>
<h2 id="最短路径分析"><a href="#最短路径分析" class="headerlink" title="最短路径分析"></a>最短路径分析</h2><h3 id="最短路径问题分析"><a href="#最短路径问题分析" class="headerlink" title="最短路径问题分析"></a>最短路径问题分析</h3><p>在计算最短路径的时候，首先需要我们解决的是怎么把图形结构存储起来。这里我们很容易可以想到</p>
<ul>
<li>线性数据结构(数组+链表)</li>
<li>非线性数据结构(树+图)</li>
</ul>
<p>我们要求地图中的最短路径，肯定是要用图形结构来存储，并且要用图形结构中的有向图存储。</p>
<h3 id="问题转换"><a href="#问题转换" class="headerlink" title="问题转换"></a>问题转换</h3><p>我们可以把地图中的几个重要的点转换到图形结构中，那么每条路的长度就是图形中边的权重。这时候可以得到如下图形结构：</p>
<p><img src="/archives/bb86941a/image-20211201173040119.png" alt="图1 图形结构"></p>
<p>如果1作为起点，我们要到6去，那么这个问题就被转换成了求点1到点6的最短路径。</p>
<h2 id="算法思路分析"><a href="#算法思路分析" class="headerlink" title="算法思路分析"></a>算法思路分析</h2><h3 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h3><p>由上一章中我们知道，存储图形数据结构有两种方法：</p>
<ul>
<li>邻接矩阵(二维数组)</li>
<li>邻接表(链表)</li>
</ul>
<blockquote>
<p>这两种存储方式的选择：</p>
<p>一般情况下，如果数据量比较大，那么选择使用邻接表(链表)来存储；如果数据量不大，使用领接矩阵(二维数组)来存储</p>
</blockquote>
<p>这里我们是做案例数据比较少，选择使用领接矩阵(二维数组)来存储。</p>
<h3 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h3><p>这次使用<strong>迪杰斯特拉算法</strong>，就是单源最短路径算法，他是所有最短路径算法的基础，我们的地图软件最终使用的算法都是以这个算法为基础优化来的。所以这个<strong>算法很重要</strong></p>
<h3 id="迪杰斯特拉算法思想"><a href="#迪杰斯特拉算法思想" class="headerlink" title="迪杰斯特拉算法思想"></a>迪杰斯特拉算法思想</h3><p>迪杰斯特拉算法主要特点是从起始点开始，<strong>采用<a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800">贪心算法</a>的<a href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5/4006">策略</a>，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。从局部最优推出全局最优</strong> </p>
<h4 id="需要明确的几个关键变量"><a href="#需要明确的几个关键变量" class="headerlink" title="需要明确的几个关键变量"></a>需要明确的几个关键变量</h4><p>1、<strong>dis数组：</strong> 用来表示起始点到每个顶点的距离，最开始这个数组中的值是无穷大，赋值最大求最小；</p>
<blockquote>
<p>举例：如果起始点是1</p>
<p>(1) dis[1]: 从顶点1到顶点1的距离为dis[1]</p>
<p>(2) dis[2]: 从顶点1到顶点2的距离为dis[2]</p>
<p>(3) dis[3]: 从顶点1到顶点3的距离为dis[3]</p>
<p>……</p>
<p>因为在图1中共有6个点，且我们的下标从1开始，所以数组地宁弈的长度应该是dis[7]，即<strong>dis[n+1]</strong></p>
</blockquote>
<p>2、<strong>loc变量：</strong> 用来赋值当前走的是第几个顶点，<strong>初始的时候需要将其赋值为初始点，这里我们的初始点为1，所以赋值为1</strong></p>
<p>3、<strong>data[][]：</strong> 二维数组，表示领接矩阵，用来存储图形结构</p>
<blockquote>
<p>例如：</p>
<p>(1) data[1][1]: 顶点1到顶点1的距离是data[1][1] </p>
<p>(2) data[1][2]: 顶点1到顶点2的距离是data[1][2]</p>
<p>(3) data[1][2]: 顶点1到顶点3的距离是data[1][3]</p>
</blockquote>
<h4 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h4><ol>
<li>创建一个dis数组，用来表示起始点到每个顶点的距离，最开始的时候我们将其赋值为无穷大</li>
<li>创建data[][]数组，用来存储图之间点与点的关系，边的距离</li>
<li>定义变量loc，初始赋值为起始点，用来存储当前操作的点的索引，当前是第几个顶点</li>
<li>使用贪心的策略，先取dis数组中最小的值，也就是<strong>取dis数组中距离起始点最近的权重的点</strong></li>
<li>将loc赋值为当前取出的点的索引，判断当前这个点可以到的其他点的路径长度，更新dis数组中的值。</li>
<li><strong>注意，dis数组中已经选取过的点我们不能再次进行选择了</strong></li>
<li>重复步骤4、5操作，知道所有的点都处理完毕</li>
</ol>
<h4 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h4><p><img src="/archives/bb86941a/image-20211201173040119.png" alt="图1 图形结构"></p>
<p>如上图所示，我们需要创建一个6*6的二维数组来保存图中节点关系。为了方便数组操作，我们二维数组的下标都从1开始，所以我们这里创建7*7的二维数组。如下图：</p>
<p><img src="/archives/bb86941a/image-20211201183122584.png" alt="二维数组初始化"></p>
<h5 id="最短路径长度求解"><a href="#最短路径长度求解" class="headerlink" title="最短路径长度求解"></a>最短路径长度求解</h5><p>1、初始化dis数组：</p>
<p><img src="/archives/bb86941a/image-20211202133636720.png" alt="初始化dis数组为最大值"></p>
<p>2、以结点“1”作为初始点，初始化dis数组，<strong>取loc=1，将dis[loc]进行标记，被标记后的结点，在下次取结点的时候是不可以取的。</strong></p>
<p><img src="/archives/bb86941a/image-20211202133919349.png" alt="取结点“1”"></p>
<blockquote>
<ul>
<li>dis[1]: 表示结点“1”到结点“1”的距离，因为结点“1”是我们的起始节点，所以距离是0</li>
<li>dis[2]: 表示结点“1”到结点“2”的距离，因为图中结点“1”到结点“2”没有边相连接，即data[1][2] = -1，所以dis[2] = MAX</li>
<li>dis[3]: 表示结点“1”到结点“3”的距离，因为图中结点“1”到结点“3”有边相连接，即data[1][3] = 10，所以dis[3] = 10</li>
<li>dis[4]: 表示结点“1”到结点“4”的距离，因为图中结点“1”到结点“4”没有边相连接，即data[1][4] = -1，所以dis[4] = MAX</li>
<li>dis[5]: 表示结点“1”到结点“5”的距离，因为图中结点“1”到结点“5”有边相连接，即data[1][5] = 30，所以dis[5] = 30</li>
<li>dis[6]: 表示结点“1”到结点“6”的距离，因为图中结点“1”到结点“6”有边相连接，即data[1][6] = 100，所以dis[6] = 100</li>
</ul>
</blockquote>
<p>3、从dis数组中选取<strong>未被标记的且路径权重最小的结点</strong> ，这时候dis数组中最小的结点是“3”，所以取loc = 3，且标记dis[loc],即dis[3]，下次取结点是该结点不能被取到。</p>
<p><img src="/archives/bb86941a/image-20211202135216538.png" alt="取结点“3”"></p>
<blockquote>
<p>从图1中可以看出结点“3”到一条边是可以到结点“4”，且权重是50，即data[3][4] = 50；所以dis数组中结点“1”到结点“4”的距离更新为<strong>min(dis[4],dis[3] + data[3][4]),这个公式很重要，当前的loc=3，也就是当前我们观察结点“3”，当我们的结点“3”加进来的时候，我们的结点“3”是可以到达结点“4”的</strong>，所以我们现在比较的是我们保存的结点“1”-&gt;结点“3”的最小距离（dis[3]）加上结点“3”到结点“4”的距离(data[3][4])大，还是结点“1”直接到结点“4”的距离(dis[4])大，然后将距离小的更新到dis[4]中；即 min(MAX,10+50=60)，60 远小于MAX，所以更新dis[4] = 60;</p>
<p><strong>以上这个操作就是<code>松弛操作</code></strong></p>
</blockquote>
<p>4、从dis数组中选取<strong>未被标记的且路径权重最小的结点</strong> ，这时候dis数组中最小的结点是“5”，所以取loc = 5，且标记dis[loc]，即dis[5]；下次取结点是该结点不能被取到。</p>
<p><img src="/archives/bb86941a/image-20211202140104948.png" alt="取结点“5”"></p>
<blockquote>
<p>这里选取的结点是loc=5，以结点“5”为起点可以到达结点“4”和结点“6”两个方向。</p>
<ul>
<li>首先来看从结点“5”到结点“4”：权重是20，即data[5][4] = 20，所以这里dis[4]路径权重是结点“1”到结点“5”的路径权重加结点“5”到结点“4”的路径权重，即dis[5] + data[5][4] = 30+20=50，小于当前dis[4]中MAX，所以更新dis[4] = 50;</li>
<li>再看从结点“5”到结点“6”：权重是60，即data[5][6] = 60，同样这里dis[6]的路径权重是结点“1”到结点“5”的路径权重加结点“5”到结点“6”的路径权重，即dis[5] + data[5][6] = 30+60=90，小于当前dis[6]中的100，所以更新dis[6] = 90</li>
</ul>
</blockquote>
<p>5、从dis数组中选取<strong>未被标记的且路径权重最小的结点</strong> ，这时候dis数组中最小的结点是“4”，所以取loc = 4，且标记dis[loc]，即dis[4]；下次取结点是该结点不能被取到。</p>
<p><img src="/archives/bb86941a/image-20211202140848037.png" alt="取结点“4”"></p>
<blockquote>
<p>结点“4”可以到结点“6”，所以dis[6] = dis[4] + data[4][6] = 50 + 10 = 60，小于当前dis[6]中的90，所以更新dis[6] = 60</p>
</blockquote>
<p>6、从dis数组中选取<strong>未被标记的且路径权重最小的结点</strong> ，这时候dis数组中最小的结点是“6”，所以取loc = 6，且标记dis[loc]，即dis[6]；下次取结点是该结点不能被取到。</p>
<p><img src="/archives/bb86941a/image-20211202141135550.png" alt="取结点“6”"></p>
<blockquote>
<p>此时没有进行更新操作，因为结点“6”不能够到达任何一个结点</p>
</blockquote>
<p>7、从dis数组中选取<strong>未被标记的且路径权重最小的结点</strong> ，这时候dis数组中最小的结点是“2”，所以取loc = 2，且标记dis[loc]，即dis[2]；下次取结点是该结点不能被取到。</p>
<p><img src="/archives/bb86941a/image-20211202141350191.png" alt="取结点“2”"></p>
<blockquote>
<p>结点“2”可以到达结点“3”，路径权重是5，但是从结点“1”是无法到达结点“2”，所以dis[3] = dis[2] + data[2][3] = MAX + 5 结果是小于dis[2]中MAX，所以这里不更新</p>
</blockquote>
<p>8、截止到这里数组遍历完毕，此时dis中的数据存放的就是起点到各个点的最短路径。</p>
<h5 id="最短路径分析-1"><a href="#最短路径分析-1" class="headerlink" title="最短路径分析"></a>最短路径分析</h5><p>我们将每一次dis的变化以及当前的loc代表的节点标注起来。</p>
<p><img src="/archives/bb86941a/image-20211202143439.png"></p>
<blockquote>
<p>需要明确一点，我们最后的dis数组一定保存的是起始点距离其下标(即某个结点)的最短路径。<strong>起始点我们是结点“1”</strong></p>
<p>  (1) dis[1]: 表示结点“1”到结点“1”的最短路径</p>
<p>  (2) dis[2]: 表示结点“1”到结点“2”的最短路径</p>
<p>……</p>
<p>通过这种方式我们最后得到的是起点到所有节点的最短路径，因此我们需要一个<strong>Map集合来保存最终的所有的起始点可以到达的所有结点的最短路径，然后每一个结点对应着一个列表或者栈来保存路径</strong></p>
</blockquote>
<p>1、当<code>loc = 1</code>的时候，我们<code>改变的是结点“1”,结点“3”,结点“5”,结点“6”对应的dis数组下标的值</code>，所以从起始点“1”到结点“1”,结点“3”,结点“5”,结点“6”的最短路径为：</p>
<p><img src="/archives/bb86941a/image-20211202145137135.png"></p>
<table>
<thead>
<tr>
<th align="center">起始结点</th>
<th align="center">终止结点</th>
<th align="center">路径</th>
<th align="center">路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1-&gt;1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">MAX</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1-&gt;3</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">-</td>
<td align="center">MAX</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">1-&gt;5</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1-&gt;6</td>
<td align="center">100</td>
</tr>
</tbody></table>
<blockquote>
<p><strong><code>这里的最短路径是指从起始结点“1”可以直接到终止节点的最短路径且路径长度不为MAX,所以这里就是表示从起始节点“1”到结点“3”、“5”、“6”的最短路径</code></strong></p>
</blockquote>
<p>2、当<code>loc = 3</code>的时候，我们<code>改变的是结点“4”对应的dis数组下标的值</code>，所以从起始点“1”到结点“4”的最短路径为：</p>
<p><img src="/archives/bb86941a/image-20211202150618831.png"></p>
<table>
<thead>
<tr>
<th align="center">起始结点</th>
<th align="center">终止结点</th>
<th align="center">路径</th>
<th align="center">路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1-&gt;1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">MAX</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1-&gt;3</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">1-&gt;3-&gt;4</td>
<td align="center">60</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">1-&gt;5</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1-&gt;6</td>
<td align="center">100</td>
</tr>
</tbody></table>
<blockquote>
<p>这里我们改变了结点“4”的最短路径，即dis数组中下标为4的最短路径值。根据前面推出的最短路径的公式**<code>min(dis[x],data[x][loc] + dis[x])</code>** ，因为我们当前<strong>loc = 3</strong>，所以可以得知，<strong>dis[4] &gt; dis[3] + data[3][4]<strong>，所以才会将dis[4]的最短路径长度改成60(结点“1”到结点“3”的最短路径长度为10 + 结点“3”到结点“4”的路径长度50)，所以要保存的最短路径可以是</strong><code>map.get(3).push(4),即map.get(loc).push(i),然后将这个路径放在map中，其中map的key是i，这里就是放置在map中，key为4</code></strong> </p>
</blockquote>
<p>3、当<code>loc = 5</code>的时候，我们<code>改变的是结点“4”、6对应的dis数组下标的值</code>，所以从起始点“1”到结点“4”，“6”的最短路径为：</p>
<p><img src="/archives/bb86941a/image-20211202152740032.png"></p>
<table>
<thead>
<tr>
<th align="center">起始结点</th>
<th align="center">终止结点</th>
<th align="center">路径</th>
<th align="center">路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1-&gt;1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">MAX</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1-&gt;3</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">1-&gt;3-&gt;4</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">1-&gt;5</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1-&gt;5-&gt;6</td>
<td align="center">90</td>
</tr>
</tbody></table>
<blockquote>
<p>这里的路径是利用**<code>map.get(loc).push(i)得到的，这里的loc = 5,i = 4,6</code>** ，我们再处理完之后再将其重新复制给map中key为4和6的。</p>
</blockquote>
<p>4、当<code>loc = 4</code>的时候，我们<code>改变的是结点“6”对应的dis数组下标的值</code>，所以从起始点“1”到结点“6”的最短路径为：</p>
<p><img src="/archives/bb86941a/image-20211202153257861.png"></p>
<table>
<thead>
<tr>
<th align="center">起始结点</th>
<th align="center">终止结点</th>
<th align="center">路径</th>
<th align="center">路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1-&gt;1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">MAX</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1-&gt;3</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">1-&gt;3-&gt;4</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">1-&gt;5</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1-&gt;5-&gt;4-&gt;6</td>
<td align="center">60</td>
</tr>
</tbody></table>
<blockquote>
<p>这个路径是利用**<code>map.get(loc).push(i)得到的，这里loc = 4，i = 6</code>** ，我们再处理完之后再将其重新赋值给map中key为6的</p>
</blockquote>
<p>5、当<code>loc = 6</code>的时候，我们<code>没有改变任何dis数组中的值</code>，所以各个结点的最短路径不会发生更新</p>
<p><img src="/archives/bb86941a/image-20211202153830240.png"></p>
<table>
<thead>
<tr>
<th align="center">起始结点</th>
<th align="center">终止结点</th>
<th align="center">路径</th>
<th align="center">路径长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1-&gt;1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">-</td>
<td align="center">MAX</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">1-&gt;3</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">1-&gt;3-&gt;4</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">1-&gt;5</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">6</td>
<td align="center">1-&gt;5-&gt;4-&gt;6</td>
<td align="center">60</td>
</tr>
</tbody></table>
<p>……后面情况类似不再分析，<strong>如果和上一步没有发生改变则不会去更改其最短路径</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>我们的dis数组中保存的值就是我们认为截止到当前loc点为止，我们认为的最短的路径；<code>min(dis[loc] + data[loc][x],dis[x])</code>这个公式的意思就是取我们认为的起点到loc的最短路径加上loc到x的路径和起点到x的最短路径做比较，取最小值，将其更新到dis[x]中</strong></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><img src="/archives/bb86941a/image-20211201173040119.png" alt="图1 图形结构"></p>
<p>如上图所示，求结点1到结点6的最短路径：</p>
<p>(1) 输出最短路径经过的所有结点</p>
<p>(2) 输出最短路径的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lhb.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 92823</span></span><br><span class="line"><span class="comment"> * 迪杰斯特拉求最短的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinRoute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n表示点数，即当前图中有多少个顶点</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// m表示当前这个图有多少个边（为了方便我们一会构造图）</span></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">// begin表示我们的起点，即我们从哪一个点开始进行运算</span></span><br><span class="line">        <span class="keyword">int</span> begin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受用户的输入</span></span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 赋值点数，边数，起点</span></span><br><span class="line">        n = cin.nextInt();</span><br><span class="line">        m = cin.nextInt();</span><br><span class="line">        begin = cin.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明邻接矩阵, 因为我们的下标都是从0开始，所以长度都要加1，有几个点就是维度是几的二维数组</span></span><br><span class="line">        <span class="keyword">int</span> data[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 用来存取起点到下标的最短路径，因为下标还是从1开始的，所以长度还是需要加一，dis[5]就表示起点到顶点5的最短距离</span></span><br><span class="line">        <span class="keyword">int</span> dis[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化一个Map，因为最后我们求出来的dis是起点到左右点的最短距离</span></span><br><span class="line">        Map&lt;Integer, Stack&lt;Integer&gt;&gt; routeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化dis数组和邻接矩阵二维数组data[][]</span></span><br><span class="line">        <span class="comment">// 下标从1开始，所以有n个点，我们就要操作到第n个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 初始化dis数组，因为求最短路径，所以dis中存的应该是最大值</span></span><br><span class="line">            dis[i] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 赋值我们的二维数组，就是赋值邻接矩阵</span></span><br><span class="line">                <span class="comment">// 初始化邻接矩阵都是-1，-1表示的是顶点之间没有联系</span></span><br><span class="line">                data[i][j] = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果是自己和自己，则将其长度设置为0</span></span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    data[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值邻接矩阵，哪个点与哪个点有值，在此赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">// 横坐标</span></span><br><span class="line">            <span class="keyword">int</span> x = cin.nextInt();</span><br><span class="line">            <span class="comment">// 纵坐标</span></span><br><span class="line">            <span class="keyword">int</span> y = cin.nextInt();</span><br><span class="line">            <span class="comment">// 点与点之间的距离</span></span><br><span class="line">            <span class="keyword">int</span> value = cin.nextInt();</span><br><span class="line">            <span class="comment">// 表示的是xx到yy的距离是vv</span></span><br><span class="line">            data[x][y] = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前的横坐标等于我们规定的起始位置下标</span></span><br><span class="line">            <span class="keyword">if</span> (x == begin) &#123;</span><br><span class="line">                <span class="comment">// 直接赋值dis的第一次，即当loc为起点的时候，dis数组的值，dis[i]表示起点到i的值</span></span><br><span class="line">                <span class="comment">// 赋值起点到y的值为value，默认情况都是MAX</span></span><br><span class="line">                dis[y] = value;</span><br><span class="line">                <span class="comment">// 赋值初始值</span></span><br><span class="line">                Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                <span class="comment">// 将起点也就是路径走的第一步赋值进去</span></span><br><span class="line">                stack.push(begin);</span><br><span class="line">                <span class="comment">// 赋值终点</span></span><br><span class="line">                stack.push(y);</span><br><span class="line">                routeMap.put(y, stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始搜索最短路径，起点begin，最短路径的dis数组（表示起点到其下标的点的最短路径），data表示的是邻接矩阵，n表示总共有多少个顶点</span></span><br><span class="line">        search(begin, dis, data, n, routeMap);</span><br><span class="line">        routeMap.forEach((key,path)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;从结点&quot;</span>+ begin +<span class="string">&quot;到结点&quot;</span> + key + <span class="string">&quot;的最短路径为: &quot;</span> + dis[key] + <span class="string">&quot;， 最短路径规划为：&quot;</span> + path.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始搜索最短路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin 起始点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dis 最短路径数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示有多少个顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routeMap 走的最短路径的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span>[] dis, <span class="keyword">int</span>[][] data, <span class="keyword">int</span> n, Map&lt;Integer, Stack&lt;Integer&gt;&gt; routeMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记数组，用来表示dis中哪一个值已经被标记了，标记过的无需再次处理, 下标从1开始，所以需要长度是n+1</span></span><br><span class="line">        <span class="keyword">boolean</span> mark[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 起点已经赋值过了 所以将起点标注为true 表示已经赋值过了</span></span><br><span class="line">        mark[begin] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 当前节点到当前节点的最短路径是0</span></span><br><span class="line">        dis[begin] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 我们最多就是找节点的次数（n）</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= n) &#123;</span><br><span class="line">            <span class="comment">// loc用来表示当前的节点</span></span><br><span class="line">            <span class="keyword">int</span> loc = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 用于记录当前的dis中存储的最小值</span></span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 遍历dis数组，找到当前dis最小的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前的dis中的点没有被标记，且小于我们的最小值</span></span><br><span class="line">                <span class="keyword">if</span> (!mark[i] &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class="line">                    <span class="comment">// 保存最小值和其下标</span></span><br><span class="line">                    min = dis[i];</span><br><span class="line">                    loc = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表示没有找到最小的或者全都被标记了，此时我们退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (loc == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前的loc点进行标记</span></span><br><span class="line">            mark[loc] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 拿到当前顶点对应的 最短路径的取法</span></span><br><span class="line">            Stack&lt;Integer&gt; stack = routeMap.get(loc);</span><br><span class="line">            <span class="comment">// 更新dis数组，就是我们的dis[loc] + data[loc][X] 是否小于 dis[X] 若小于更新dis[X]的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[loc][i] != -<span class="number">1</span> &amp;&amp; (dis[loc] + data[loc][i] &lt; dis[i])) &#123;</span><br><span class="line">                    <span class="comment">// 更新dis数组的值</span></span><br><span class="line">                    dis[i] = dis[loc] + data[loc][i];</span><br><span class="line">                    <span class="comment">// 拷贝一份 因为直接改会影响</span></span><br><span class="line">                    Stack&lt;Integer&gt; stackClone = (Stack&lt;Integer&gt;)stack.clone();</span><br><span class="line">                    <span class="comment">// 将当前的新的节点放进去</span></span><br><span class="line">                    stackClone.push(i);</span><br><span class="line">                    <span class="comment">// 将其放入map中</span></span><br><span class="line">                    routeMap.put(i, stackClone);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下标加1</span></span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">8</span><br><span class="line">1</span><br><span class="line">1 3 10</span><br><span class="line">1 5 30</span><br><span class="line">1 6 100</span><br><span class="line">2 3 5</span><br><span class="line">3 4 50</span><br><span class="line">4 6 10</span><br><span class="line">5 4 20</span><br><span class="line">5 6 60</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">从结点1到结点3的最短路径为: 10， 最短路径规划为：[1, 3]</span><br><span class="line">从结点1到结点4的最短路径为: 50， 最短路径规划为：[1, 5, 4]</span><br><span class="line">从结点1到结点5的最短路径为: 30， 最短路径规划为：[1, 5]</span><br><span class="line">从结点1到结点6的最短路径为: 60， 最短路径规划为：[1, 5, 4, 6]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果起点和部分顶点没有边，则不会打印</p>
</blockquote>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>地图软件就是基于迪杰斯特拉算法进行实现的，采用了A*启发式搜索算法，但是其根本算法还是通过迪杰斯特拉算法改进优化而来的。</li>
<li>如果我们的地图很大，可以缩小计算范围，只画出一部分区域。如果是省之间的，则没必要加很细粒度的点，绘画出大的省区，然后计算完之后，在计算省内的，几个大点，最后一级一级的推出来。</li>
<li>本节课计算最短路径的时候一定要明白递推公式**<code>min(dis[loc] + data[loc][x], dis[s])</code>** ，其中dis是我们的起点到各个结点的最短路径长度的数组，loc是我们当前操作的结点索引，x表示当前的结点(loc)到x结点是有边的。</li>
</ol>
]]></content>
      <categories>
        <category>最短路径算法</category>
      </categories>
      <tags>
        <tag>迪杰斯特拉算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理(四)</title>
    <url>/archives/cdd5d4ba/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇博文《<a href="/archives/37963bb5/">Spring-IOC原理(三)</a>》中分析了<code>AnnotationConfigApplicationContext</code>构造函数中的前两个步骤，接下来我们分析最后一步，这最后一步也是整个过程的核心方法，几乎所有的操作都在这个最后的方法中完成。而且最后这个方法中调用链比较深，所以这次我们先大致捋一下最后方法中的所有大致流程，然后在逐个方法去解析其中的过程。下面我们就开始分析最后一个重要的方法<code>refresh()</code>。进入到<code>refresh()</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 刷新预处理，这里主要是保存了容器的启动时间、启动标志等信息；和主流程的关系不大</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这里最终获取了ConfigurableListableBeanFactory，和主流程的关系也不大</span></span><br><span class="line"><span class="comment">		 * DefaultListableBeanFactory实现了ConfigurableListableBeanFactory</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    <span class="comment">/** 准备这个上下文要数用的bean工厂 ，这里会设置beanFactory忽略的依赖接口（一些Aware接口），注册一些bean工厂依赖的bean（BeanFactory、ApplicationContext</span></span><br><span class="line"><span class="comment">		 * ApplicationEventPublisher、ResourceLoader），以及一些默认的bean。</span></span><br><span class="line"><span class="comment">		 * 添加了两个后置处理器：ApplicationContextAwareProcessor、ApplicationListenerDetector</span></span><br><span class="line"><span class="comment">		 * 设置了bean表达式解析器等</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      <span class="comment">/** 注册上下文子类的后置处理器 */</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      <span class="comment">/** 实例化并调用所有已经注册的BeanFactoryPostProcessor，会解析<span class="doctag">@Import</span>、<span class="doctag">@Component</span>等注解 */</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      <span class="comment">/** 注册BeanPostProcessors后置处理器 */</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      <span class="comment">// 初始化国际化资源处理器。不是主线程代码</span></span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      <span class="comment">/** 初始化事件多播器，容器是使用自定义的广播器还是默认的时间广播器都是在这个方法中进行处理的 */</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      <span class="comment">/** 初始化特定容器中的指定bean，这个方法时空方法，用来扩展用。</span></span><br><span class="line"><span class="comment">			 * 该方法是模板方法，容器刷新的时候可以自定义逻辑，不同的spring容器有不同的实现</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      <span class="comment">/** 注册事件监听器 */</span></span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      <span class="comment">/** 实例化剩余的单例Bean(非懒加载)</span></span><br><span class="line"><span class="comment">			 * 比如invokeBeanFactoryPostProcessors(beanFactory)方法中根据各种注解解析出来的类，在这个时候才会被初始化</span></span><br><span class="line"><span class="comment">			 * 实例化的过程各种BeanPostProcessor开始起作用</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      <span class="comment">/** 最后发布相应的事件</span></span><br><span class="line"><span class="comment">			 * 清除上下文资源缓存</span></span><br><span class="line"><span class="comment">			 * 初始化上下文的生命周期处理器，并刷新(找出Spring容器中实现了Lifecycle接口的bean并执行start()方法)</span></span><br><span class="line"><span class="comment">			 * 发布ContextRefreshedEvent事件告诉对应的ApplicationListener进行响应操作</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="一、prepareRefresh"><a href="#一、prepareRefresh" class="headerlink" title="一、prepareRefresh()"></a>一、<code>prepareRefresh()</code></h2><p>首先，会进行初始化前的准备工作，通过<code>prepareRefresh()</code>方法来保存了容器的启动时间、启动标志信息等。该方法中主要也是进行了启动前的一系列准备工作，和实际流程关系不太大。可以进入到<code>prepareRefresh()</code>方法中看一看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Switch to active.</span></span><br><span class="line">	<span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">	<span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">	<span class="comment">/** 在上下文环境中初始化任何占位符属性源。</span></span><br><span class="line"><span class="comment">	 * 如果一个类重写了initPropertySources()方法，比如设置了一个环境变量testProperty,</span></span><br><span class="line"><span class="comment">	 * 在容器启动的时候，会去环境变量中寻找testProperty，如果没有找到这个属性就会抛出异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	initPropertySources();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">	<span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">	<span class="comment">/** 校验环境依赖的所有环境变量或者属性是否存在，是否可以解析，</span></span><br><span class="line"><span class="comment">	 * 这一步和上一步initPropertySources()相互配合使用，在initPropertySources()中设置了环境变量，</span></span><br><span class="line"><span class="comment">	 * 在这一步检测环境变量在配置文件中是否已经配置了。</span></span><br><span class="line"><span class="comment">	 * 例如：在initPropertySources()中配置了testProperty属性，那么在validateRequiredProperties()中</span></span><br><span class="line"><span class="comment">	 * 会检测环境变量是否真正有这个testProperty属性，是否可以解析这个属性，如果不存在这个testProperty属性，</span></span><br><span class="line"><span class="comment">	 * 那么会抛出MissingRequiredPropertiesException异常</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">		<span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for the collection of early ApplicationEvents,to be published once the multicaster is available...</span></span><br><span class="line">	<span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">	<span class="comment">/** 创建早期多播器，一旦多播器可用就可以发送事件</span></span><br><span class="line"><span class="comment">	 * 所谓早期多播器就是：我们的事件监听器还没有注册到多播器上的时候，都是早期事件，早期事件不许要手动publishEvent发布，在</span></span><br><span class="line"><span class="comment">	 * RegisterListener中会自动发布</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中主要进行了三个操作：</p>
<ol>
<li><p>通过<code>initPropertySources()</code>初始化了属性源占位符，这个方法默认是空实现，如果一个类重写了<code>initPropertySources()</code>方法，比如设置了一个环境变量<code>test</code>，那么在容器启动的时候，spring会去环境变量中寻找<code>test</code>属性，如果没有找到这个属性就会抛出异常。</p>
</li>
<li><p>通过<code>getEnvironment().validateRequiredProperties()</code>检测环境依赖的所有环境变量或者属性是否存在，是否可以解析。这一步操作和上一步操作<code>initPropertySources()</code>是相互配合使用的，在<code>initPropertySources()</code>中设置了环境变量，在这一步会检测环境变量在配置文件中是否已经配置。</p>
<blockquote>
<p>例如：在<code>initPropertySources()</code>中配置了<code>test</code>属性，那么会在<code>validateRequiredProperties()</code>中检测环境变量是否真正有这个<code>test</code>属性，是否可以解析这个属性，如果不存在<code>test</code>属性，就会抛出<code>MissingRequiredPropertiesException</code>异常</p>
</blockquote>
</li>
</ol>
<p>​       这里还有一个小的知识点，就是在spring中我们可以怎么获取配置文件<code>application.yml</code>中配置的属性值。常用的有两种方式：①是         通过使用<code>@Value</code>，例如：在相应的字段上标注<code>@Value(&quot;$&#123;server.port&#125;&quot;)</code>就可以读取到服务的端口；②通过<code>@ConfigurationProperties</code>注解，在需要读取的实体类上标注该注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;student&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收配置信息的实体类 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml中的配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mysgk</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是在使用<code>@ConfigurationProperties</code>注解时，需要配置一一个<code>prefix</code>前缀参数。</p>
</blockquote>
<p>③最后一个是通过注入<code>Environment</code>来获取我们想要的属性，<code>Environment</code>就是在<code>getEnvironment()</code>方法中初始化创建出来的，我们进如到<code>getEnvironment()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用方法<code>createEnvironment()</code>来完成创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>StandardEnvironment</code>是个什么东东，我们看一看它的类继承关系</p>
<p><img src="/archives/cdd5d4ba/image-20210824114741338.png" alt="StandardEnvironment类继承关系"></p>
<p>​      当然这里也只是初始化了<code>Evironment</code>，还没有进行配置属性装载，具体装载会在<code>prepareBeanFactory()</code>中完成</p>
<ol start="3">
<li><code>this.earlyApplicationEvents</code> 创建了早期多播器，一旦多播器被创建，就可以发送事件了。什么是多播器呢，所谓早期多播器就是：我们的事件监听器还没有注册到多播器上的时候，都是早期事件，早期事件是不需要手动publishEvent发布，在RegisterListener中自动完成</li>
</ol>
<h2 id="二、obtainFreshBeanFactory"><a href="#二、obtainFreshBeanFactory" class="headerlink" title="二、obtainFreshBeanFactory()"></a>二、<code>obtainFreshBeanFactory()</code></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>这个方法和主流程的关系也不大，这里只是获取了我们在之前创建好的<code>DefaultListableBeanFactory</code>，那这里为什么是<code>ConfigurableListableBeanFactory</code>类型呢，因为我们的<code>DefaultListableBeanFactory</code>是实现了<code>ConfigurableListableBeanFactory</code>的。</p>
<blockquote>
<p>再回顾一下<code>DefaultListableBeanFactory</code>是在哪里创建的。之前我们说过，在执行<code>AnnotationConfigApplicationContext</code>构造方法之前会首先执行其父类的构造方法，</p>
<p><img src="/archives/cdd5d4ba/image-20210824121207079.png" alt="GenericApplicationContext"></p>
<p>从上图可以看出，在父类构造方法中实例化了<code>beanFactory</code>，而<code>beanFactory</code>的类型是<code>DefaultListableBeanFactory</code></p>
</blockquote>
<h2 id="三、prepareBeanFactory-beanFactory"><a href="#三、prepareBeanFactory-beanFactory" class="headerlink" title="三、prepareBeanFactory(beanFactory)"></a>三、<code>prepareBeanFactory(beanFactory)</code></h2><p>在这个方法中主要是准备上下文要用的bean工厂，这里会设置beanFactory忽略的依赖接口(例如一下Aware接口)，注册一些bean工厂依赖的bean(<code>BeanFactory</code>、<code>ApplicationContext</code>、<code>ApplicationEventPublisher</code>、<code>ResourceLoader</code>等)，以及一些默认的bean。同时也添加了两个后置处理器：<code>ApplicationContextAwareProcessor</code>、<code>ApplicationListenerDetector</code>，设置了bean解析式等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">		<span class="comment">/** 告诉内部bean工厂使用上下文的类加载器等 */</span></span><br><span class="line">		beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">		beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">		beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">		<span class="comment">/** 添加一个后置处理器：ApplicationContextAwareProcessor，这个后置处理器实现了BeanPostProcessor接口 */</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以下接口忽略自动装配。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">		<span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">		<span class="comment">/** 为beanFactory注册解析依赖的bean */</span></span><br><span class="line">		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">		beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">		beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">		<span class="comment">/** 为bean工厂注册一个早期的后置处理器，这个后置处理器是一个监听器（ApplicationListenerDetector） */</span></span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">		<span class="comment">/** 如果存在LoadTimeWeaver，就将其注册为LoadTimeWeaverAwareProcessor后置处理器 */</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">			<span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">			<span class="comment">/** 设置一个临时的类加载器 */</span></span><br><span class="line">			beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register default environment beans.</span></span><br><span class="line">		<span class="comment">/** 注册默认环境的bean */</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要做了如下操作：</p>
<ol>
<li>设置了类加载器</li>
<li>设置<code>bean</code>表达式解析器</li>
<li>添加属性编辑器的支持</li>
<li>添加一个后置处理器：<code>ApplicationContextAwareProcessor</code>，此后置处理器实现了<code>BeanPostProcessor</code>接口</li>
<li>设置了一些忽略自动装配的接口</li>
<li>设置了一些允许自动装配的接口，并且进行了赋值操作</li>
<li>在容器中还没有XXX的bean的时候，为我们注册了<code>beanName</code>为XXX的singleton bean</li>
</ol>
</blockquote>
<h2 id="四、postProcessBeanFactory-beanFactory"><a href="#四、postProcessBeanFactory-beanFactory" class="headerlink" title="四、postProcessBeanFactory(beanFactory)"></a>四、<code>postProcessBeanFactory(beanFactory)</code></h2><p>这里的这个方法是空方法，spring没有去实现，主要是提供给要实现<code>BeanPostProcessor</code>的第三方框架使用的，如果要整合spring，那么就会要实现<code>postProcessBeanFactory()</code>方法。主要是在spring的<code>BeanFactory</code>准备工作完成之后做一些额外的定制化处理，一般会结合<code>BeanPostProcessor</code>接口实现类来使用，在该方法中还要设置一些忽略的自动装配类。例如<code>AbstractRefreshableWebApplicationContext</code>类中就实现了这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ServletContextAwareProcessor(<span class="keyword">this</span>.servletContext, <span class="keyword">this</span>.servletConfig));</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class="line"></span><br><span class="line">  WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">  WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="keyword">this</span>.servletContext, <span class="keyword">this</span>.servletConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述<code>AbstractRefreshableWebApplicationContext</code>类中的<code>postProcessBeanFactory()</code>方法中添加了一个<code>ServletContextAwareProcessor</code>后置处理器，那么在这个后置处理器中的<code>postProcessBeforeInitialization()</code>方法肯定也会有实现。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getServletContext() != <span class="keyword">null</span> &amp;&amp; bean <span class="keyword">instanceof</span> ServletContextAware) &#123;</span><br><span class="line">    ((ServletContextAware) bean).setServletContext(getServletContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getServletConfig() != <span class="keyword">null</span> &amp;&amp; bean <span class="keyword">instanceof</span> ServletConfigAware) &#123;</span><br><span class="line">    ((ServletConfigAware) bean).setServletConfig(getServletConfig());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、invokeBeanFactoryPostProcessors-beanFactory"><a href="#五、invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="五、invokeBeanFactoryPostProcessors(beanFactory)"></a>五、<code>invokeBeanFactoryPostProcessors(beanFactory)</code></h2><p>这里spring会实例化并调用所有已经注册的<code>BeanFactoryPostProcessor</code>，同时这里也会解析<code>@Import</code>、<code>@Component</code>等注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值</span></span><br><span class="line"><span class="comment">	 * 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里首先会通过<code>getBeanFactoryPostProcessors()</code>拿到当前应用上下文<code>beanFactoryPostProcessors</code>变量中的值，然后调用<code>invokeBeanFactoryPostProcessors()</code>实例化并调用所有已经注册的<code>BeanFactoryPostProcessor</code>。具体<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code>方法中的执行逻辑在之后的博文中详细讲解，因为这个方法中调用链比较深。这里只是简单了解大概流程。</p>
</blockquote>
<h2 id="六、registerBeanPostProcessors-beanFactory"><a href="#六、registerBeanPostProcessors-beanFactory" class="headerlink" title="六、registerBeanPostProcessors(beanFactory)"></a>六、<code>registerBeanPostProcessors(beanFactory)</code></h2><p>这里会注册BeanPostProcessors后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续进入到<code>PostProcessorRegistrationDelegate.registerBeanPostProcessors()</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">	<span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">	<span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">	<span class="comment">/** 注册一个BeanPostProcessorChecker 当bean在BeanPostProcessor被实例化创建时期间，</span></span><br><span class="line"><span class="comment">	 * 即当有一个bean不符合所有BeanPostProcessors处理的条件时，会记录消息日志*/</span></span><br><span class="line">	<span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">	<span class="comment">// Ordered, and the rest.</span></span><br><span class="line">	<span class="comment">/** 将实现PriorityOrdered接口，Ordered接口和其他接口的BeanPostProcessors分离开来 */</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			priorityOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	<span class="comment">/** 首先，注册实现了PriorityOrdered接口的BeanProcessors */</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">	<span class="comment">/** 接下来，注册实现Ordered接口的BeanPostProcessors */</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		orderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">	<span class="comment">/** 注册剩余其他的BeanPostProcessors */</span></span><br><span class="line">	List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">		nonOrderedPostProcessors.add(pp);</span><br><span class="line">		<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">			internalPostProcessors.add(pp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">	<span class="comment">/** 最后，再注册所有的内部BeanPostProcessors */</span></span><br><span class="line">	sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">	registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">	<span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">	<span class="comment">/** 重新注册后处理器以将内部 bean 注册为 ApplicationListeners，将其移动到处理器链的末尾（用于获取代理等） */</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>先注册了一个<code>BeanPostProcessorChecker</code>后置处理器，该后置处理器的主要作用是，当bean在<code>BeanPostProcessor</code>被实例化创建时，会记录消息日志，</p>
</li>
<li><p>将实现了<code>PriorityOrdered</code>接口、<code>Ordered</code>接口和其他接口的<code>BeanPostProcessors</code>分离出来，用<code>priorityOrderedPostProcessors</code>集合来保存实现了<code>PriorityOrdered</code>接口的bean，将实现了<code>Ordered</code>接口的类名字保存到<code>orderedPostProcessorNames</code>缓存中，bean类型为<code>MergedBeanDefinitionPostProcessor</code>的bean保存到<code>internalPostProcessors</code>缓存中，除此之外的其他接口，将接口名保存到<code>nonOrderedPostProcessorNames</code>缓存中。</p>
</li>
<li><p>对所有实现了<code>PriorityOrdered</code>接口进行排序，将<code>priorityOrderedPostProcessors</code>缓存进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<p>然后将排好序的<code>priorityOrderedPostProcessors</code>缓存中的所有<code>BeanPostProcessor</code>进行注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 遍历postProcessors */</span></span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    <span class="comment">/** 将postProcessor添加到BeanFactory的beanPostProcessors缓存中 */</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对实现<code>Ordered</code>接口的所有类即<code>orderedPostProcessors</code>缓存进行排序，并进行注册，过程同第3步。</p>
</li>
<li><p>最后再对剩余的其他<code>BeanPostProcessor</code>即<code>internalPostProcessors</code>缓存中的bean进行排序和注册；过程同第3步。</p>
</li>
<li><p>注册了一个后置处理器<code>ApplicationListenerDetector</code>。</p>
</li>
</ol>
<h2 id="七、initMessageSource"><a href="#七、initMessageSource" class="headerlink" title="七、initMessageSource()"></a>七、<code>initMessageSource()</code></h2><p>这个方法中主要是初始化了一些国际化资源，和主流程相关不大，暂且不对<code>initMessageSource()</code>方法中的代码展开阅读，知道其大致功能就好。</p>
<h2 id="八、initApplicationEventMulticaster"><a href="#八、initApplicationEventMulticaster" class="headerlink" title="八、initApplicationEventMulticaster()"></a>八、<code>initApplicationEventMulticaster()</code></h2><p>初始化了事件多播器，容器是使用自定义的广播器还是默认的事件广播器都是在这个方法中进行处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用户可以在配置文件中为容器定义一个自定义的事件广播器，只要实现了ApplicationEventMulticaster接口就可以，</span></span><br><span class="line"><span class="comment">	 * Spring会通过反射机制将其注册成容器的事件广播器，如果灭有找到匹配的外部事件广播器，Spring自动使用默认的</span></span><br><span class="line"><span class="comment">	 * SimpleApplicationEventMulticaster作为事件广播器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">				beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">					<span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听器大致执行流程如下</p>
<p><img src="/archives/cdd5d4ba/image-20210824172318052.png" alt="监听器流程"></p>
<h2 id="九、onRefresh"><a href="#九、onRefresh" class="headerlink" title="九、onRefresh()"></a>九、<code>onRefresh()</code></h2><p>这个方法是一个空方法，没有任何实现，只是spring用来做扩展使用的，当容器刷新的时候可以重写这个方法，自定义业务逻辑代码；因为不同的spring容器可能会有不同的实现。</p>
<h2 id="十、registerListeners"><a href="#十、registerListeners" class="headerlink" title="十、registerListeners()"></a>十、<code>registerListeners()</code></h2><p>这个方法中注册了事件监听器，并且通过调用<code>ApplicationEventMulticaster</code>中的<code>multicastEvent</code>发布了早期事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">		<span class="comment">/** 首先，注册指定的静态监听器 */</span></span><br><span class="line">		<span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">			getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">		<span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">		<span class="comment">/** 不在这里初始化FactoryBeans，需要让所有的常规bean处于未初始化的状态，让后置处理器去初始化他们 */</span></span><br><span class="line">		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">		<span class="comment">/** 使用注册好的多播器发布早期应用事件 */</span></span><br><span class="line">		Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">		<span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">			<span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">				<span class="comment">/** 调用ApplicationEventMulticaster中的multicastEvent发布事件 */</span></span><br><span class="line">				getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h2 id="十一、finishBeanFactoryInitialization-beanFactory"><a href="#十一、finishBeanFactoryInitialization-beanFactory" class="headerlink" title="十一、finishBeanFactoryInitialization(beanFactory)"></a>十一、<code>finishBeanFactoryInitialization(beanFactory)</code></h2><p>实例化所有剩余的单例Bean(非懒加载的bean)，比如：在<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法中根据各种注解解析出来的类(实现了<code>BeanFactoryPostProcessor</code>接口的bean、实现了<code>BeanPostProcessor</code>接口的bean)，在这个时候才会被初始化，在实例的过程中各种<code>BeanPostProcessor</code>才开始起作用。**<code>BeanPostProcessor</code>的触发也是在这个方法中**</p>
<p>大致看一下<code>finishBeanFactoryInitialization()</code>中的代码，具体逻辑在另外博文中具体详谈，这里调用链比较深，先了解一下大概即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">		<span class="comment">/** 初始化上下文属性转换器 */</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">			beanFactory.setConversionService(</span><br><span class="line">					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Register a default embedded value resolver if no BeanFactoryPostProcessor</span></span><br><span class="line">		<span class="comment">// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">		<span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">		<span class="comment">/** 如果在此之前没有注册过BeanFactoryPostProcessor后置处理器(像PropertySourcesPlaceholderConfigurer bean)，</span></span><br><span class="line"><span class="comment">		 * 则注册一个默认的嵌入值解析器，主要来解析注解属性值 */</span></span><br><span class="line">		<span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">			beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">		<span class="comment">/** 初始化 LoadTimeWeaverAware bean，目的是为了后面注册他们的转换器 */</span></span><br><span class="line">		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">			getBean(weaverAwareName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">		<span class="comment">/** 停止使用临时的 ClassLoader来进行类型匹配 */</span></span><br><span class="line">		beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">		<span class="comment">/** 冻结所有的bean定义， 说明注册的bean定义将不能被修改或任何进一步的处理 */</span></span><br><span class="line">		beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">		<span class="comment">/** 实例化剩余的单例Bean */</span></span><br><span class="line">		beanFactory.preInstantiateSingletons();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>finishBeanFactoryInitialization()</code>方法中主要做了一下几步操作：</p>
<ol>
<li>初始化上下文属性转换器</li>
<li>注册属性解析器</li>
<li>初始化Aware的bean</li>
<li>冻结所有的bean定义，此时，注册的所有bean定义将不能被修改或任何的进一步操作</li>
<li>实例化剩余的单例Bean。<strong>这一步比较重要，会另外在写 博文单独解析这个方法</strong></li>
</ol>
</blockquote>
<h2 id="十二、finishRefresh"><a href="#十二、finishRefresh" class="headerlink" title="十二、finishRefresh()"></a>十二、<code>finishRefresh()</code></h2><p>最后发布相应的事件，在这方法中也会清除上下文资源缓存，初始化上下文周期处理器，并刷新。最后会发布<code>ContextRefreshedEvent</code>事件告诉对应的<code>ApplicationListener</code>进行相应的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">	<span class="comment">/** 清除上下文资源缓存（如扫描中的ASM元数据） */</span></span><br><span class="line">	clearResourceCaches();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">	<span class="comment">/** 为上下文初始化晟敏周期处理器 */</span></span><br><span class="line">	initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">	<span class="comment">/** 首先，将刷新完毕的事件传到生命周期处理器（触发isAutoStartup）方法返回true的SmartLifecycle的start()方法 */</span></span><br><span class="line">	getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Publish the final event.</span></span><br><span class="line">	<span class="comment">/** 推送上下刷新完毕事件到相应的监听器 */</span></span><br><span class="line">	publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">	LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IOC原理之invokeBeanFactoryPostProcessor详解</title>
    <url>/archives/e74be873/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前几篇的<code>Spring-IOC</code>原理系列博文中已经介绍了一下<code>Spring-IOC</code>大致流程。也大致了解了其中的流程，这次我们就来详细解读一下<code>refresh()</code>方法中的<code>invokeBeanFactoryPostProcessors()</code>方法。该方法会实例化和调用所有的<code>BeanFactoryPostProcessor</code>(包括其子类<code>BeanDefinitionRegistryPostProcess</code>)，所以该方法是很重要的。<a href="https://viewer.diagrams.net/?highlight=0000ff&edit=_blank&layers=1&nav=1&title=IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.drawio#R7F1Zc6rKFv4t9yFVOadqW8zDIzhkTkzM%2FHIKFZXEKYBG8%2BtvDzQC3SgmoMbt3vveo4DQdK9e8%2FrWkVgezE5ca9y7GrXt%2FpHAtWdHYuVIEBRRl8B%2F4JE5PiJqko6PdF2njY%2FxiwMN58sODnLB0YnTtr3Yhf5o1PedcfxgazQc2i0%2Fdsxy3dFn%2FLLOqB9%2F6tjq2tSBRsvq00efnLbfw0c1QV0cP7Wdbo88mVeC92tarfeuO5oMg%2BcdCWKFg3%2Fx6YFF7hUc8HpWe%2FQZOSRWj8SyOxr5%2BNNgVrb7cHLJtNXvW6dPD7MH606o3jvK%2FWl3PPyDb1Zb5yfhG7r20P%2F%2Brc8%2FX3ri08vl1%2Bir%2F2DOLX4y%2ByNIwc2nVn9ik3lQ%2BuAxZmcEngbXrT9y0RnlYwLf1QQTxaE%2F0UNKF%2F23qh2ZtSNdP6oqR7p2ZNSOqtKRqR1pHDpSOTL4o6p8pIEjCjoioWtqR2b5SCvDUyaHTulHGrisclRVj0zwqyr8oBtHmtTqW54Hf2qKR4aGbqaAn5q2NYRfwJXgMvhQcAew0hx5HTAz%2BI3wSMujYcfpTlzLd0bDMrxnfeT5dXfUsj0PvDBecn9OyAys%2Fhh%2B9Jxht28bkHDBXT57jm83xlYLnvoEOwwc6%2FmDPvjGg4%2BIvglVciVRjv9RySXBruJKnKJxsUuCdQguAG%2BDv5fDRRFrNbQUoun57ujdjpwJFomcIeMAhGt2Xavt2Iv7DEdDcH9zaru%2BA7aW0Xe6Q3B44LTbcALMjtPvx%2B5cA3%2Fg6IML%2B3YHz3EmQiU0B55mzyK7OCDcE3s0sH13Di4Jzv4RlGATzgnzkWR84HOx53lEkvBgL7Lh9eCYFfCZbnj3xWYBH4L9ssbe4WUxde%2BMXTtGPmSfLHjOn2BfGYhERaEJ%2Fx6hBV5suuCkpTfVlhKehATwp2MNnP6cXKJYA0h6wVPebL%2FpWs7Qg2xsNBwlz8fv5CHagvfRS9rYZ2zq4KW8MdhirLeKj7bVUjVRoG8znjT7TgvO1wjMa2xj4jt%2F62mdTktR2vTTXLvreL7tpjzluGJ3bNe122eD8cj1G3YfyKaRewqkD%2FwN146d%2Fgc%2BSw2H1nQXg%2BXwP8RBwnnGTxRrkbf84eTZM98etr30aTsBVDUOB0AG18VHOfTExEuVurYff%2FvjfxbH0P2O%2F8lp%2BJF1jU5eHgSQ%2BkiyNCmPYRMAem3A4snc4Y94%2BnIamN9zvJQxldZ8hK6pimXRjyBDT31OazQYT3z7rGM0PcCrj5dQNv3vmFDV%2F3Kdl%2BEE8dw0qkC7aUHPBmuT5kQ45S3SKv2P%2BeB3G4rHP9SGz2st7M%2Fv7pzjlmtbvo35x5rDaYqa3pJT6DllNP%2F8s8dMimzkktVuHxdE7lt86w2wwhal59upjwQs8ZiWkbSlgOXkle1bbcu38hOSv4HxZJufrRCnWomcQRo4uT5hywGrAx5fYbxF7C5eOKLsrtC6KsroESSZjxk9msRRNo%2Bs6rTJw6t52Dysl9AYFk9icu12124EXwGF9Ebd0dDqVxdHzcXRy9FoHMw2sFn8eTDd1sQfxdeCtmDXm3VvNHFb9pLrgvfwLRdQ9JLrAq8SfMmla%2BjafbAfpnEfVe7LIaQaoM3kZgm8OfRGTNiAgjye0fvQtTuu7fUWrC7hTYkcbqZuuxX7jV7jhNdB12s1XS9wx%2F3RtZIqx%2FbcH01lbDpOKMmMbacpBa0z8bXu375TM%2B47faf2nfpNp2mrFXeart6OvMDajtQuB2ac71ot3xiP%2B04LS2JwIyjnmDszZROLtLB1hlNAAdC7WrOgmj%2BPuUm91Rp%2BurcKPE%2BUjpa4q8gFR8v9VcFJtm%2FN7TaPBVlGzy0j%2Fhb7%2FE%2F65C5bSgX9oX%2FbXMzTak6Zrs8Flk3qtTkz1lotcOcWxVgJ%2FyLeW5nmqYLG4KhyUXoML%2B8rQ9UzMlRe2imOqufEUVP4Y4xp3SHXMLZXKnbf7lq%2BvSk2ufhFjFWUwWKl%2FxiaU798ywsM22XDW56OdC6fdIbhWVWONBMGOHEI0%2BRQwLJypIvoiI4CluCIAeOaMGApoRAljoAa5AO6jw5upTbTno5uV4MRVBgIVeFn%2FGOjEgZC0TUcDJz%2BOuIQ9QR1iHQ0L6SEKHUohVEHy5RKCoRhO4j7VlAQ2mmhybRcnz68dLrtmeM%2FB2fh55cjGPuVg28VOEkc%2BTInX4bgNZ%2BjXyK%2Fgl8XP0PfyO%2B2JV74jOIlZlals4PMUih4Qn3kILFBCC7BjiQuQUj4xYNfLWiJvlEiEC0m%2BRWeGepGiCjD1%2F6Bxb%2B3liCf1RTkd8sWlBiqZNbsFHAEcEKtGslyAddIiLmr6JSCrtHhvVjLfGk17X58oUhKRgssiw0YenpSh2sDU8pqovtBVjGGRIumRzaP5Er2JQ6JMikAwqyv4ClH0cwplmDgSrwk%2FmzHE8eNkNiYo07HswvZk5K0ek8GEawfidO1ZzPB9ESR1sFCxhhluuEP8xez9FR1liRbTQb9mmsN7NXO%2Buw6DTx%2BA%2B7j%2BHBa%2BHVc%2BOFCr1Z0tjjFCjXFOBcG6JhhdhvOszN5Vpoe1jMNyLIqdscZOtBOuiO3iCXJLfL20E9xAh%2FQ6k2FMDvE2gCDM%2FGNDcTRko9alYsH1e7qkSEHWrEhUgSzaY13DUqYxRWZUAGhtmKYaLoZhZf2YdJkwrJ0x4ulYZPIMbnP9q3W9ZdJii8Tz2CZ4TWbWadfF3Ijk75a41Oyany7FXWTaA67G%2FL%2BjyxnkPgkqhwlX2APlQRR43Q5%2BP%2BiqJnl59s2k1BS5n%2B5VM80jVJB8yjQzqwVQrT0Zk2t3Oe6LBrmOm6G7841g%2BOKQkkpaoeLtJUN1NRj6K67huooSUBsWcO207Z8Gx71aHlXgB4bzjiZHyCj4C3IzIjFrAapF5JLIi%2FzgqrIuqxK8Vg5WJOSIkb%2F0rJT1EuiwqucgO%2Bh0OvKS3qJ0xd%2FC1tjWrDSW%2BjBd%2FoeUw1q9ezWO%2F2DMqEItvfY4KA3F2jLBlaJgdlvAvMeuwcCVbwG82CZ9S9AXzfDEhst%2FMEloKjF6V%2B0xYOzOl8C67z4o8apStNKJLEiWuyha4BMaPKR5VJhJEOEVYRkxpi%2FYkKI68NegYpw8YuixTUJVsSWZddKRenBAl1s0%2FBdmJ6PnVVJZnxEsvbJIpSCaM9igdB17DiPhmxWlYRhlEjAR0FxHlzOBmxfvbnUtYfiQUblCBD1wlhGZW9mNTCWoV2rwlM4igQv1hbRnl9POUwTikU6hUX%2BhAz%2BuR0zoYJJX522GLzJShOKbJ%2BVJlT%2BcnaPZ1%2FMOPtkCxQ6%2B5XPpvvB6e9fb3PPfPNeHj9t8w8rXLTVEsW8kr6SKR9X1qL6Db1fIB1yTM1PS4m%2Fab7BwvZkKQ6uPAjl0CAoF4ByyBgORz5SGg0fDLM58e0MmXSJWplmUxZ0eqgxnTSn4oq0aWkFVY%2FMZ4D3hBJ2S8UA%2BTzS6aQv%2B3G4wButgyNkRnZL4iv3P3M06gOd5LsFNLFdh38Dr3B8C1XvJkdbMy4b1TQSsD8mVt8LJgoSxLpErliaKjOIfHEEKOCzOdTrrmwgIWCFbOTa1HqxFdW8645S0FWcVrrW1IGB%2Ffvv0pUuYBCZGXQLSD8H1UKjYkCKO9PQDwS7YZOvw0rA3Z%2F5TNoUJPNrmzNcvrmunZ083Bn3ZzfX%2F5UvjUbjP%2BP%2B%2Fu7MfLhPYwS%2FcOpNHgUvFWjqGSrLd4MsNNPY6mJ0kKzYjzlXYJILhoeBdnJtqxMbqcX87fOKCTaaY4QC%2FjicniTzMCFJQh4JzHwqKOWVpLNulfmcXDrNfVkYCbprDTGW6gXdTpj1C2hh0F4ATAZnDJt6kFqmywt3UkEq8dbnZ3Ut8mZobp9UtAg6FxBnpsriDuHOl6G8g7QXZvCEmec4biEisqxCP%2BjiGg3yFMjGaxEOogWhDHB%2FeAp5UjUxkiKP0h7xQ8EpHSUmGeVAHABuBSk%2FvHM4DPR0%2BAF5ZA2OjLmCTqFbLbyuOnyiWSFJREbsTYNcJeSW1dAGBD%2FRGblKrPFE0Mt0gWRBVdAmDW9ISbdqBBcNr0XqRm4708wUt7REDjmP%2F3jYewxPD0fuwOoXs%2Fk2VviX%2Ba3gTv4X%2BtOWvxE4zJjxLakhyxehiQMaJc%2F2Q0%2FSujb2Nw3%2FDdgB3%2FLGbe%2Ftaw%2BXlymD2jIeBn3tT%2BHI%2Bh70Hu%2Bge0wtw38ZnpZ1pR0vHuVPBviTr038vAc306bsmS3rhweHyA45RPpO6s78dXNOq4yRdPvAgk9TK022kg1U9liJKq340nZmqCWj%2B%2Bg1RAMaNFkXWntUOY7fcMuWW6jrbck8Pih0v1ihuzxLffE9VehSn5yjGpM2BNf2Jy68QceCg%2FnexGRDfqOyRBI42NGcqeBQAuk6taiSlZ%2BVMe9kfbwqXkqU%2BMkiX9IEKt9KFVglaCQrJf8CiQ1l%2BJA6elIsn6WOnlGNvyjrD9YaHKk58JXRL9qW17PbwSPXW8qVGUQkCTmaQbQsjye%2FChh2efsfJVHfrkhKSSNoOT%2BucX%2FwbJdky3B9XLu8SAjrO8N3%2FL3n%2B7B7hIHkd23q2J%2B2W2o7Vte1Bl5pCMt4wTNr4aw1%2Bxb4KdGpeoDG%2BwGdQ4zGTic8ZbcdePS%2F%2BA%2F61tx2PbTC5NDQmsa%2B%2B46PaPfsBryTDNQcQdbA8GSgA4OvYBVlYIsE%2Fwf0I%2FAJXcLDryq8Dl6imaW2a306I8AF79Q7ftySPUm%2F7HimYDW%2BvPvKy72pmVedm1fnRR8PBoJq2TdvJ09Nc3T13DpTdd3yhs7jzbw7u%2B402tfCybhSBa8hC7Xbm%2BnDdd0ZXHLyp%2FZcfnSv6t7r22n5Q7kZyrdvp9c1Xnx%2B5Frv9YvT%2Fvv564d%2F8jF7H3Tv3p77L0%2FPRgfd5eVRGWn%2Bef%2Fq6nXsPlWfZkL16fLmo9bpzWrClf7x2uidS1Nf8bj3Fj%2F026Py%2B1P5Q9ZrZx99UbqeXQ9u%2Br4vQQqT4dKB%2Fzv5fG486crstfIxeR2pn7Mh967cwlNmXZr2z98rZuNtqN3NZmN1UBG5ljF9nU8NdAfzXtAnp%2FWbzoBH93qVb9SPu9kXOlebf9VPLiu987H28MD1Pvsn3PP1RWdyevvxfIqffTG6aEnPref7vnEKOOOzd3uPfnpz7tW4gWV4zsU1OuBcX3INeTZ4li9fZsK7da65xuP13JS6X92GOOnaJy66bmw%2F9mrn4lvjzqhpN%2F3nuiE2Lk%2F7XudENO8U6fzlZt6Teu7Fy0VP6rSeJ9x8fOrdvWtvanuGbjAau9r8Qxx%2FzrxZ%2B3H0wl%2F0Dac7L0%2B01l33%2Fk1xxkJfU84eawPu7eEKvcT5%2FGHiNs8eempj%2BGjdvj30p4I4ejjl3r8aNfH9hZue3H7NxVoLPaBiXs3uT%2BXzeaNuN707uTcwXvS74Xm1czruo%2Ft1at7n2aDaa87OT09eW5Z76%2FlCpd67urpRh58Pr9O%2B1D3l3InzUm54%2FXeholT9jvlRfbnXbsp3F70L4Wo%2BsB30tGfxrvFx12%2BeaRPOPrEfW6Op9mCdvPW7XycnnerN%2BQw90%2Fw46z6%2Fqt3L0yttdnZvjt99GyxSU1IGpzO8tH6jOn2YXMr%2B47hd6fZeepfosHprPD%2BfSbZtXk27p5X258OFdF97xSd77vCk8WWb49MLc%2F4wfpQal8rVzPxwjA%2F18vrx7nN6U8bPl%2BYzVT65q87n80lVGnevn4faw7Mol1uG8jqVFXQ7r2x6audU8b3noXH3rr699XqNM%2FQoszV9f%2BvKdUF2Hqzm7KpzOR%2BcPuJfXcl3V9r9WOqUq%2Bbrhdx%2FMxqnr6Ygf%2BBNcPOk2PPzhuwO5Bu95788a5J55nev7%2BZvnx%2BN3nt5fGf17XHFfZOv77uvTvPy9b4yenq64ztu%2F%2FpkgG5SPX259tSXW925vRw1%2BNfyBd92X%2BqAbZ%2Fjp5RnU39wL4v9k9m0PJjXT67F18Hb46Aj%2BVeXvtA6UevD1%2BqjImoPd%2Fr0TvvUTd2pP4t2Qx5Nns%2BflOG7ZD0NJFEH06I%2BNc%2Bqp1Z3%2FtTvnmuvM2t6P%2FNOn2aW%2FPw%2BuWtJ8oVcaZwP1at6761rtQZv1kP75O0cML9W5XzqOebVDRqUhAjYVG3H0Men3H33ZfT5VdEGTu31pmlflGv1B9FxpuPP62lP%2F%2FrSZ19K7%2FpDql6Xy8%2FP9ufl5KvW8VsXtVO5y3mtOrrZuTZw766lx7On1sXYHr0Lmtj5%2BHi%2Bd16mbyZ3YgqmYStzs8nNpvrZGxrG81ur3HgyGuiLIbRv%2FMfpo2u%2FPDgPt9e1iefcSqbYFe5Pe8ZYOGlWXxuYO02EHv%2FMnwws%2Fv2kPn04HSmSXbutVF%2FwncST0fvL7ePp%2B5lVvahwdv2y7JvOU3N2cvV%2B2XG6yoV21vpyLm6%2F3CdLrF5w3avLO9%2B5epRGUq%2FV%2B2o%2BNar65NHyLzTMz2655vNA8DtijW%2B0B486nsTbhuG9dieti6%2B6dXqHWF%2BNm%2FT4h17l46M9BtQ%2B%2FvLUq8%2Bbp17IdM0bQ1I%2Fbq6kR%2Bf65mVqCdX58NWbNq99271X%2FJZ0MX1ym3fdjn3%2FPHg4nZRPa62HcxO%2F1s3oaoSFwUWjVrbbZmcm9Z%2Fk3q1abZp8xxv0evpo4N52Ze7Mu%2Fo4eT45uTf1rnVRnlXH08br88eDWuYF%2FlTTnsGOO7uZXt1xnZcT3j6zPm4NdVQfozE22qP%2BSeeu8nL9JvPdk1G75z1cCXOjVeabH%2FcXvapqVJyRcOm41ol4OxSuLm4r18Lpw%2Bnbw9lpxb1qq4%2BtB216wonz0cfsDN3TP%2B2c4Gl4cR%2BufPezdz2o3896yqsIxIzD%2Be81U206Tnf6PtG0qXAJqHzkTE4GzYFl8h%2FWq9F6A6RaG2m3L63KyyUQVWXu1RkFrPVEUl11cK58Nowz3jytKKZ7h57GfymS3rPfHkz%2Fo%2FNVexxd3p623p4718a99XHasMr26Yv9aBrNl5fGSXWuv79NzdnEerwY6rzePTNO5mj8NUd6vHq7OEef6x%2BXJ%2Fc9vODOuWOrwntdEYft67H%2B3m6XX40P37XvzS4amz7uf35WJNG9v%2FR7T2WOP%2BspV63H6nWnenJzfaE8%2B3xDRbdq80%2FufFQdOi91v41%2BO32eDOfVG6BpS86p3DIaY336cMO9ifO2WBteDNVO%2F%2FKkfyM%2B3gqVmY1%2B0rzS2vywNuvNuv6nXr26u5eeusKL1OmI7vjpq%2FOCRZf7amu3c%2BHqzp2%2FVdWB3Ze9vt%2B7kJ8E7kV6%2BJp8jJ1pvVVzxYF4MvY5Ra5fSC%2B%2BI508cHZfbJ%2BbL%2BhpboPvz2%2FeP98671gtePnA2oFd%2FZxf3DdGn%2Fc%2BOmCoTzcvptzuX3VeDTSCZs9Whx%2BKd8Z5r9WrT1V8ejuvTy%2Fkt%2BdZ7Z5r6%2BNae3j%2FOlEHZ1%2FK2cPwvmIPT%2B9HrSune%2FZ615nYhm4IsmqUn7EYmSnDZ6H1dVVvvV8MhOFNfVC3JoNG%2FaqlS%2B83D29a%2BeNJ94zX0d1QfLmovgAC7E8vWj3%2Fpnp9f%2F%2FsfgE17KxaRkNDmkfNeqnPv%2B6u6m%2BqPnUxs598IaIyyx2l83Y9f6288%2FfW%2BNq5PZnZ5VrDGV73rfNG5bHdcj74Sf1hLD0OuIfH%2B%2Buh9ea%2FuhfWi%2FDl39tvJ6en5Wvv%2FqJ1bU1H%2FGl13n9znecxJ83kq9r84u39pnz%2B2b95lS8%2By%2BN%2B9XxYf259fs2em%2B8fN8P3u%2FLoenxXk%2FWuo32evfFGwy6%2FcTcPj5pgaGPHmr%2FV7viXgdTW1bng3dofDv85uZHtviqNPl%2BG3blzozoC%2FzRTpo36iO98nZ8L1ZfrM12R%2Bbv78zOlBUR76%2F6aexSFadv2K3zn0Zopqgru9z6anVQG9489IPgHVvXr%2FfSsLTmj7qN5LVtX4qnybN9%2FNBSszPlXb5ihzG5lx64L6PP7401z3p%2BL1lXjpn0iNzqX92rrEesi71%2FV4fBG0p74y8HTO98dc42L1%2FqrU5ncX733nz5vJs%2FeQL68uPdfRlg9vOoNm5hJY6IS7sSLu9mrNsC69407e8Dq4Vur%2Bm6NT7sn7wOvI7dm%2Ffv7d5GTxpqna%2BfdycQYzxylXJcw%2FTpX%2Ffajcv58flJvax8XXs2sy0DXvEOka8rvnHddC2SAVx9d%2BR%2FX1d5d9cIatGZ81bu%2BeKu8TKrV7s0dp1Yfnypv7U7tTWp0W77J1fvtV%2B799r5Tfx13vYeG1W4OpeZUF2aVmlJ17bF%2BfTa4m95%2BWvXHZ8nGLPPVxSrNJd7kt60PoF053Jdz2rDPrt4eT05uRne6WHYuroTx9cR8f5UHzqvUuXv%2FVE5u7pzr%2B7bW6PFvr5%2BPo7nkzZ84LEhvJX6EWei88omeMLp%2Fx3LqXmzXeqejFzyPQKx8iZfPD6%2F3Neseb4%2FbroZF2tVnf%2FrxLnPyk%2F7ofj5Zsl%2B5s%2FkmOqfdGMr5iz9%2FmI3Utgc0wIYpqmZ%2FVD15PKlN396sEeB%2F9ce3mjF965zful%2Bzit91qsKrWD0XvuTbT%2FtxMG%2FcXAD5alTrgwvnrAXsH4v3Hi46xpviNvA6XzQGU0wAzfOGwknX72ODv7v7bAoS2GONid4FUv4ZGA%2Bj2Vn5pX45vvBlp8o%2FDl7uX09kH1FQbXxdbZk2z09NWf%2B8eL27xIzKu6nb9q2K2Uyr6tX1Lxl9OenPWuKzzk%2F7srawquxxZ9LuPE%2F12VRUZdt%2B63QeHa7qzir8V0t4VPzhvTR6mUx611%2BNk8vb6askdodAE3Qe22%2B2bgqtm8rZ%2BMXqnGgVbNlcyrr6OBxMB5PW%2BFQTz56m0%2FIJlm1nyq1yUb780h4fr05Hbu%2Bk9qz1Bnwn4InoIkz%2Fwul8OnBmtmzce3MHG3k3Q%2F3sRVCwisObX2dPX5d3zvjqRb24qIgjt3nVubg%2FqX%2Fevp5Wx6%2Bdp1bPaknm4PnSaM%2B8h0tr9vIgmK%2FPs5enh5rX6bbOurf647X78PD2fH79cv%2F%2BOetU672Z2mrX%2Fdbpa%2BWx%2FIZsk1q3Ntft4blxih7dbfdl8%2BtTa16pTqMHVJyHk25b6ZXHQkN5bQ7mmPV23KvLj5vKs1O%2FHz%2FfXTr9RtOxL8bP9zdvWrf19XzV8AyweE83n7OK1aw13q865vPT5Oada1%2FeVKd3JzePr%2FPRxcODKdbmd%2FPaZIbm0BRbtnE95h4b9bNT58L2h0BV6g8q2u1J88wG2wlopxreEReeU77zlQEWoGgD1U47XWQ91j7dk7eW9IR3y%2FRyoDy9nYy60r1hT2xXUOXP00rv6ux5rPVuTmbPEX3Qtx3%2F0nqq%2BOdSY6hjEe4%2FuZb9%2BiXWW3PuUkTXDj7rQGBylXfHOHP0svV5LZ1%2FcU8NTxwMgLUkTa7nnj55rV3fn1rNJ69cva%2FKz69T56IzeO2dP15JX64hPfDCTPiYnrTuxG73XhA%2F%2FRf1%2FXSqNf2y%2FjKqT5ThZX%2BG%2BerotmnP5blgXVmTk%2Fcb0xvclo3yy6VZN7TZ%2BOTFdG55vAsUbmiMHiWjZ9pD4%2BV93rye9pULNOirLqCi685Z4%2FrlvT9vcu3au8NVXtHPHqVbPIXW%2FfVZpzZSr86mH43%2BXf2hOXYrXUuonzunraeR%2BGyN6jdAYR7e3Fxw%2FlfnVRbfhzWsH70r6kS5fB72zj7Pn%2B%2Frc%2F5jeDat2lPvzuzXHl5dTRbH%2Frh7%2FvWKRXr%2F%2Bfyhcdad3ioj6%2BvFuLr%2FPOuWe27Nv3lqNXz58hkz2eqJj%2FmuezbAK2oECyZE%2FKtMZ2DU9xf4YxmgE84AdU6NOkyTXmsfOlrDowhMsD7yUHE09KqNfH80QP4xcMIM6wIj1cQd9Adcgh5meGPc4RW6TS3ypQM4QptcAr7HnXut9lAsOShXZNi2XdiZDOZfWb4F%2FgOPexB%2B2fJbIyA6ajBuUIN%2Bwv%2B6o9J42GU6dH9Y8fyNthFxn6lEfKhRCBOBdsCTY2v438HXiA%2BV7ZK%2F8aatr%2FrV2eX7zbD730XLFa%2FcPzyrV%2BVGfPQs0NyFgz1vaFHmyzPKdNmTJOTtZc8aRlk27BiwKMoZ16oEdMBUCSxe9UgTIhjRawAYRJBFZJRPa4apHJkwAINsXAKO47G6%2BYaogDT0QTiuJAZCBGguuG9RmAiF413LYb8YElbhaBYBLqN5RB64ckzi2lZV%2Fob5wVIU0pUMIStowmb4QRYowK3gzuklEscMyFtlIs3yJRaFC0ko7vzmS6DmC6J4jccxDK8km9kIilfIcUIULw6GrVeheC0nizVRaTe%2BHDRQdmviwpe7SwKPeiU69wN2wIz0SyBwPhBegJkqggWLjnMXzUCYRWSTCgtHMFBtUPK2RDbp8EZaeHGB%2BDxLZNFPV59AnCaFERPbSd2gLGJAFge4WnYbrpqH2p%2FifZu22gpssKEZRDFKYi%2Blrm38QfFanhCa3UQ6VZgIiQt2UI6kRioqg7qqMBGSphgwhMriyYYU5FoalWWg7wt8ZnQfQ0G5n8KRYQaKnIEzcPkgLRQMQ1P3gSjZsFEbpUpWl7dfpCItXZmVNhPh1quNJmW3lCQGwizccQYqD9RQMXMlMJ1MIdjdWo1u2RAaNmm9GyJteLI3cVhStYvvrNdSwNl1UpeIuwylDjcsvITNlUuubbVR0jmaCpx6zgXwQ5jnRe07eO0x%2FN0%2FgQQNyhmXPGwJTqWIMOGFlFc10ZTh7kaoOhNyRyHgagGnJi2WUpDkM5mnFHZ8YqLgw5fMPM5150m19uLVV4HWp2mRYOptNs%2BN9BuGJQG43LGCEplXtSqOs%2BtOpyO0WlRyKzjTVpqKrBxRzYxhN0PUCSGR5vpDSyLdZZbsAKVqDItBZ2St8nkgTDI5x9ZgAr%2FF7xf9oEoyQgAOe0L94Uoct6otFPpWt10HzB3sEvPDXlHsCeUyipDM4ISbESECbajwTEoouPsOYgjBExMNyQWZ3sPlctCQPMVdHyQ3Z1QUhLTWCd%2Fo6cPxXKAkfDc9Od8mPuefLz3x6eXya%2FTVfzDnFj%2BZARrcVqOFrH3mY53mgsVExyK56plZCfsBBfvhWQwhZTG21%2FGBPR5aq2RTxyZYQkQvYLGImN0WLC1jIZdvgp%2F3ouBC9xLpyMXvEA9YSp8MtNRmsgRpeVtaXWe1pV2nC21Kz%2BjIOFK70A4z6MUeRb07H0QR1bjKqLFiKApDZSzMQ8DowrHDGmPOzJx411drd7nXLv1s0eioAKNWOsMuh62n47s8DWXiMyBGGG5ojvptdoF94K1GHkQYsEXYS4axgicsG6EoIquO8bSI7yLFtg7c7JmN6sBXcONCdwOjYduSUs74a%2F1Ks3lTPE8l%2FrtVPE8riueJGXjeVoKQaqLvgM7yKHCMqQr77uXPaugMDhSAjPuJ6DgkEM9bikKiXfOtKKSYnba3uCAsGy9HBW%2BlT3AN9S7LKJICaIlquLptI7MRStKT3Yz9FoLuL3KOIolADH%2F5tyXACipf7u1YYVyHPpPseyXVest%2FoxAhkNB7ZVoEsFpSSnJRu4jVxC87BITbbR5j2AgI%2BhH5hACzIqAdIdwfL4xnNJnH2ehCk9FhqEWTCRKOsaTHbfb9Ggck%2BZU6yuYJN9EfjtXztqgeUuw3YNj3UHEto9gWHcNnYiFp8VwADUbgjRAJlYsTmYFU%2BjB8Fl4cjTwRwFFDQSmcBDZV4uKdPJZF2ugH4Ngbj%2B4yGANeCJY2cvAMHHN9gmVaDvBONTnjrRot3K8O5h%2FgRIQaiqEuuYsKp03TD3vne0yfZ20eVltMtbDNk7nLvWh2Xavt2LGpDCsFCnIbrW0v8ErCYFAYBoPM0k81vbA5Zvgm1lSHkgrPBhWb7M22tzjDrDqI76jaXMCHFsd4liYeGheroZp5hanlZGwwmW5C%2FFC%2F%2Fr4GnUpQCQoURV1fJ7ssR0JTpZKqCQqnKbqsyGF%2BWf5kR4eUN9RQOHt0MSufWMbc02HRwm7FMQ%2BDsI6HIfuyz8LV5cRIY1k9LlIZ8YOwYfpmUqIlhkK6kQBCVqooMhWRrOfq8q0geWB1uUawwDsSaRDptOZDh%2Bn1CjRzYgSh9ky2PiPlveCG0ksJNloSgRY8XGSc%2Bo7TNuPS%2F3TUh9magUPuSCgTYRIUROQq5TclJoqjAF4oKXyMCARWhrnMlVhN6Ysrw6N5BEUBHmDwx0vqHkgRJyxsUFm2d9JDC0z5IE4XcIeIu1aHtQSmEWBE48RorQqDe%2BGRA2nFSYtTSiS%2FbZ5QI2JhOqCNMAquCvN2SVnqF1jyPZe1i%2BanHkWyUxepqOzE1DWXaaVOIGUtT4iZCgwxEBz7IcCqkKiUFJO6JdaGKGxV6kZSEnQg6fj5NkhrNuqStwUo8KtUV4mB78uezt1KkpHoQCnWQRgRE8v1gB6SEj2Ml2CuUDqTnnSqaIa%2BJsW%2FnfBU047vxRGsGSevuLODtT0Iu4SwU0ucEOc8zDw8trArTo9ixSQP7ChFGK6WmtpOsSOZ9pO0R0eqWSqVjtQK2JJ9%2B%2Fh%2FrYXG7HjVwdifH7NNoT1wovFH303TWXvHa3qJk%2BIbXmc4zljeVUq5yY8gGMEohgBJlzap2ShrZeBI7cx5QEhK%2FjS%2Fewzvcrwg9IOlz7L0ky0xMqaJyzkQK7OqgmfkAVbsju26dhtrGw27b8N021Owsn3bLQVBn1Sjn1VfDBUshbjuaoGec6CNpbTBhGHaMG1sq%2Br0V5Wd%2FUztkRnOguU7dUfqzniGe5Cuxk9JuIxaTdHMpqDlcCXoHxfgCUTATRCQyhq2UgPPPzPpZ9EvOowsVFAVfbzBchJqjmZ6ETSDUn9kJaALgmajSNSy4qYHvhfne4xUl8JKp1Ioe1voKvvJ95azs9WML7ObdEOhUxZ1YJaA2rsxsmmaYQr4n3i%2FOaEJ%2Fx6R3OL4SUtvqi3lKJZ4XGjP8qSpAFPowz5U8EDDd51hd52E6u82ViSduIKnk6Z%2BYd9m9DyO9DOGgGsBcAxguGFzSm%2Fd7pTNZlOGGeRLbaaUEZdymha0WdOeAd4ThlGh82ALPR7zeeQONuYmZEZ2S%2BIr9z9zNOoDob7uGn%2Bz32fNuGykNfcs2R8Tq%2B8FEwUJYl0iVyxNlRlEvjgCTLzZHCoxVzYQYW0vdi2z4%2BihoXgmBv2t3tbIiN5mX2Ckw%2B%2FNfKZBpR3atB%2FatKOndJCs2I85p1qwb7e%2FeHlf5hUTbBRWMex6T5N5iMEY%2BjEkBPVYoyAdtsN8Ti6d5r4sDEZCFGPeZwgegVm%2FgBYG7QWTWUOXjoC5H%2FOzUMY2qyElB7JPKlrowcTQyyqLO4Q7X4byDtJeiGkS9UOaqMcEDhGWI9dokKdANl6LcBAtiB6C%2B8NTFEwMjsTgh4JTOkIONcqBOIC1lXrkzuEw0NMD9FQOAdPiMSNcVx3dauG91eETMWYtxFIxYm8a1DxHykijbtVIqTNrPFGsayH4AN43KHTFN6SkW8yJjNYidSO3nWlmimN7SwKSQu7bPx7238LTw5E7sPrFbL7ifUDrvhXcyf%2BidklL3wj2TaJnfEtqyPJFCLLWS57th56kdW3sbxr%2BG7ADvuWN297b1x4uL1MGtRUXmFpJv%2FaH47D7HvQe76B7TC3DfxmelnWlHS%2BehZIsG0q%2BNvHzHtxMm7JntqwfHhwiO%2BQQ6TupO%2FPXzTmtMkbzt2tB3gFbrTTZSjZQ2XE7F4ioIrEUXyZWC9aS0X30EMufi2jtUeU4fsMtW26hrrcl8%2Fig0P1ihe7yLPXF91ShS31yjmpM2hBc25%2B48AYdCw7mexMDzoxhYkMKRodvz%2BBxqqo6iXYXyUYKDiUaeqTnljMypOh8lHxQTQVOiVfBSSqNaacKjHyksGY3%2F4yTLPD%2Fi3SfYHbblteDzY3RkuRTNzlz%2FOfgLvAzqpnEJZTg26JoEn6JNfNg1FryRyuagKzMr1qPAnJEcsiK%2F7%2Bhqk2JECMBEOCTGcFZ6zYXhZrhrZJVEimVm4D0rHnksqA7QPqgQ9ySEDhSWz605A%2FUAME%2F%2FV0EbdkPwAc86FwrTyVW7YcM1TaD%2BHyDxk1Um%2BMQnzSSabpQThWo95m1WNvH1GpFGSqbJnG06hLLsAg8yUhE36cpKAwTJeKXBQPRyEMM5MAGF2gMecqHebm1wNGAdVr8YtCnvLRZVxJtkLq%2FEN4fgYEIGFpECAxa%2BKCl85VSp5lMKI7XbaYVbv1SrMAN9dYCQjKOu6kumitG2KXEgt4kcjj%2F%2BkwaAGs74jVnkbcrAooj0JqE12vaN%2BUTRT1JKPncxFNCppIhp48s8QMyskKljZwB7z43HPZlVQNFsQtek6kKT14mzCEKkMRSyAsr6JaFDAxjDwq6f6RPE%2B6xGl4iK7vaUD03o6zp9y9uaIahDoxS1BIDhpkUXrLNloyMgpClSLT5EQybqfNKEpqNS2K%2FFgxkQzjYzjU04YUExI%2Bi0kxZZDFlgs2T%2F75NL8tZViYfyLDl2LbRavnjNLCZY9LPeIF2F8l4XFgrlWrNeLi8%2F6%2F6XL58aECzq3Z2eV%2B9ixZUF4uLu0QHzY6LC%2F8wmcBySs4s%2BxkwiCGA%2BGYIKoPXzfLGsExJrHScGTQGcFtE261ObdwdEXHjntVG7JqLmg1cBp8p6h9SH3nYG8Bo03iZuKA58v3RgLGO%2Fmh8xGj3mFhVjuM1rYKHjKzZwQyofeNeaeC1LLuEfjV2Hc8u%2BaNRfw1Cy59KiHeWIhKWJVNYuxEC21i0bkA8r8S9msXzuhl9IvTjRoa0RJFoTdxpaDXnrXFmxd2Tc%2B%2FgmqJAyAkpqWV0p%2BamP7AMlZhMXJnsCNYnhvyeJkXT2j0lkWuqAsxENThGIOo7IDnfAZXfbC%2FcXPhiboobVP81XoyrtUc%2FcvMU3%2FtWoTFqEORCi9LBbK80nvhBmtykjEtpyxEAhnSoWh1lV0C3toyyQFTkIEfdI40KApwmULUbU8aSLpdAK8iqoxXe9ZYXKa8XX9IE2hBguXMJUkD%2BMjkX1JqYoNo1az5vwalmFJzK1iBo2MOhHffspd5C53PWWqPrgpHxWVl%2FGqDKt7qeq2ocZ%2FyPsPO8fwewWJYu6s%2FU5zWzIra28XPvXpGiMYfZNsSvJGxYY6aNfraJ95tZCtlSP2YpkKNoifDMzxhKfDjknkL898VxGzVLptWv4zY5cw3CDFZyDTV3R%2F3P1IX03rBZrWF2t9cU7O9hG7nlrH5Ww9TtjQbNCXjtNTB%2Fl1LL96O7q0yNwkwKiYsLAJnRXJJntRQurKu8SgdhiPWJF7gKz1g%2B7Mkrer3RpN9uvDvjY9rMjNihELjnKqhqOmbHCWIRhnrP8uxS3bhrVP%2BLpVUzse0VmGUWFi4YEDDxZhghyOfn50jtbgReMchGC6uLMXRBOVIerMPbheUSGo96Gmso20xBuWUyRda%2FPDWqMFLnEn1UWWjA4mZJPUNCybcyodbkUkx391HE2Q2nJeLulsm3ZIh6oWev56bOWWISFpKfnr2Z1C1eSgOsXjd1i5eU%2BJ2kjKlbeWl2egY7cjuhdDHBBv4w8pvCcHssqlVYP2WiuOXT63dnVJTlhLFWx9ZNLwjtAW%2BP6mkpCiRLW4soHEDFwHuVfAPTDPlkcCnd%2FLyw9f2hV3vdjrxrrC9pvqeXoo1ZdS3bdpTFkqoXtf6MFOX1wmX7rpPltPZ0PgFzrQWlVJiZqjLMVMZaU4jm0TKG72%2Fmn2GMh5tz%2B8ya9FlOqB0MHZtnaVCiUBKLWmESIlt%2FhQHLH4NXnze22wBs55dZZKQjMpdZWOSX57%2FMf3MbQrKEq22jrN5EsmtW2kZEj5YKKwDQWK0v1mPRzCKyw%2F4l%2B5dV48Fk00Vl9mk7EHfc%2Fc1L9uTqzZu1h0Pxm5foc%2Btv3i03rtr5XSuwfPXMXcuX5KKkrp7Fh3nYuFnRDshu2YWN%2B221eUf65u78BuYZvZdSN3BRdRf6QW3OsIHJvly9gXdHbdazebEYGxhhMRy2bdq2zawtFyl397JuNvdtm1VhJntlF7YtKylqLxuebQqvcO%2FAY1dx8K3CQ1Jel%2F2Y9rBXxWYJ6W%2BZXrpjrA67PECgKwlCvQadrTX4bwEHuwvdpJqWZ9cBA7a6ewPbi7t1ke7isIdEooGwtshe2%2BbUO8NWf9K2ayi2ntbF8dfNfqIrzlZm1p7t48yqsJ4QZlxSQHvLAI03M%2BNrIT037EWz1n6mMaaqiLIgc6JFj4fV4DV9gpJ9YyMSykNTAYbCLW6Jk2gefKfvrW7ymXUGrXCctZF7Z49tC2eFpXQ5YE02l%2FgXyeFJphDvHGp0ejfd%2BGIwn7Vuq9UV7XQ3%2FFabeandQdE%2B2E3f60UKuL0QafilQNRSg49k4stHmhFBSzho%2BIVq%2BLgJgwKPQNRXeTcaNEaLifZ37jXYrs0UA4UeYhWHNScRzGGTg4pStEAF2GHwAzYDzAiAQ9iXjxTBbNUwgF2diuyd8a1u6%2F%2BL60Ulx6sOxv78%2BJ%2FoIqc0RV%2Btq%2Fwvp1eA1VY5CVTSyIISqIxaLvYDIwVeW9XFGNVh35yLNSn5rnpy1riv3v1nVo3rNB0k9z5daXPUgSuVSt9skyFuDaAJMCgbIcsbfO9VNA7%2BZao36B9337PRcIJWb4Gyx8FNwFn4jez2EYz2%2BD14S0o8c3%2BOkgbQ2HbBVA3AJx%2Fd3cMXOoOB3XbA%2FQBrL4gxpb9u2jwelMtClEu662rYMICuGyAuzq3rPX%2BF3hlvqhDoLKRBmGGS7rkVpB%2Bh5hEG7uXAb9stN7Zczz4ulUr%2F7MvqhIokmd5gwtHCabVYz7htznyq9gG%2FocMQgvZ4b9Yl1P0V6O2HXVSWdEAJTQdcwF4JmpOYWxczu90%2Bb7kgpny8Zqxbzemoj%2BCPE5oH1DSGdjt%2BbeiCzaJd%2FVDf2qpZERFfdcgqU%2B0KzEhbLHlXpBmRlYv8Aq9i%2BvsXo2iu1OPLPbv1vtC44e7hRp3FlgCf2rEdgY0ZawjTejoTF%2FwOfo8bAja2AuCPEckcwSL%2F1sT1nClS4nH%2F6KFtt%2BEDDir9pgdRqN5oiKRrGO5Ui3xdQaMvEzkuIzgtqcIxFKBIOBoKo%2F3zIsWBVn5wO1qDBOX1uH8u0XhMhqYH1HV15NHm0LMUhBsTDpUeD2qOpuPWaRX0gcoxOsjxTe2%2B77le2LoB1yMf8O3ZysFavpfgX%2FwW4ECzXcZsEod68YOhVItfiSXdjet0naHlO8Nu8vR%2BCb7g31KvcGzm0OTlNKAh6v6XFrVce8nDf5mXei%2FXMu3B7M7GRWvVSymLhirJOeOiBVUu%2BimQPByg16amXhAKylHh3oB5MQi09TvUeKZmtfyRO095ZiaXfF7EsVI1zlcPLTbx0AicQEY5CM2neYOg%2FmLCYD1Wf8APoYJWQ6qNRsD2VKiCaVKgsplKXC%2FDQX%2Bg7AjwEcUq66Sq5pesBN3CNqpAKlDzxJ5VXY73zaUi%2BssXwMA5pQZaY6Ti6rWck0uXLEkBDu%2BNrE2qR5vW%2B8OQfRiQSN9bBRuwxU3JGjw18SrYEYQFEtFhGO7cIp1CcQVqLx1A%2BehOyy9jnl0cBM8cw%2FIp8rNErZxvz9BarGgRFq1VDA4lejmnliey6ie%2F37gmH1BUMVHa%2BIeFKaCTNkox8L1kb6X86t9YuNHJysZN9IcmqKhh46%2BwZUBqE7DvAqDm3Yt6dWGklrEwMjOSyGYgUnUhTrDidxFS9SSYxoYBUnnuL6m7%2FxGZ8oTLrKRTnhMyEupm0O%2FDka%2FZIJXjdD1Ta7cyCw89IuyaDGkfhcOHmXU4sY6Jab4CYp%2Fp1U5mlKboqUDBTxJ6Zij%2BlegBul4uF9uFS5ETnENRSoJMSU1BlmkuCKi0VBSEFs%2F9JVA8P%2BIomZF4wg28MwyFAeeRXN7tQGrrYrzDoaDwzB3B6ifM80XuCIGaMhhGWeA1r05MTUdsJpi%2Bk0G%2F5gKjbTXzyg0iJRWk%2ByjssL3MECE3Rqj%2B4WIIa%2FSXXhDjejDem6cAVnfChCT9iViOOZAW%2Bc9U8km8EQ1LSIu0FEa%2BCRfK5wTpbYrOQmGapLOcoHjWIaPgbEL%2Fl0LaiZKZwDJYtcJoLIvB%2BrfLXZ7LLni13RK8%2FEGvynV9%2BV1TrGgoLZwo4R6RGDdyQ3PIL1y3%2FF480N3AF7PtqBCqBBhMFZRFREe0cNSED2IkRhkt4hg8hzjto%2FGY0KgiOUMS17DdqQNWp4rylTQ%2Bhk0fOXhne%2BOR56CwZezaIaCOfh%2B%2B73qCZnW3iahCsmlLbeF0InqpKpdIT92ouGD1S9bEklqcVvKXoB3%2FkKMImSVGViflpjgKA8INZ9Sj%2FRqPOi4CqxJ0nASBOR45V9ARvRLpio5KVkyOMKhgGws060kguJD9noDMIYcbrdHYbtfd0Wx%2BNWovWMmlNT8DXA68S6lU%2Bjl7yKpfRtnGxthDGNJYxRsKg%2F7j%2BYNTOANj4DM7hUkr211hDHy6Uzgfc3SphvJTe7Q9gjda3x7dcT4gi0k1QSlpjC5UTDWhQN8FId649%2Bo4hjcX%2BKwixzx6eX6%2Fp4qPearEIkPigpZowsgKiYuskLhYoFzYS7RfDzBwn%2F4ZOhz5Ye7iQ8osPrKiAucuPurnny898enl8mv01X8w5xY%2FmTE9TTyTDi6tpt2PryRJU2mBWYQNW9N3nWt7zlfg%2FIdrO4YxcPQusnkkV9agCnrlVpD3j2MRXEngRSm2f4MbfTfxgFwy6nRQTVliDddLBWAv6847mGIbNfD9RnfpWhwgY%2FZNmEmzSJ7BuTQctzKbBn5L9ibeBBdJWV4xby7CTmkR9GTTX1mI3yO%2FnJaUN6U1FjYl7yx%2FWrFBf8yf%2FnBhZHQnGNJy2o75L5AHEqd9a7hqUYYpx5ocKftHvk2zGropEBBAGaWH4GtCRygfywhHDpBkTVnS%2FABn2mFpSehD8aIK8V6EyvLSY0mztjDDTaVtGlaqnlRUqxmeZ7U22FlBl66R7oYXRM6sxqrbUmOXj7yw1DjiBUF%2BD2fYpblG3R1NnXbMJbIqYY7pEknjSQX6SIpiGCJPhUs0RnCdafoqfHFuEIHlM9tZpvFT7bhQjqFm5hj6jnEMRsAM1phVYc4pLvvTlYjWEWomYfxUR1qHEKgoAawDrv8L1I8SRv7D5W0w0kr0E2rTw%2BBL3orIDux%2FOZkSrwphDDSqM0gMBqAWyADEDM6vrSQ%2BilqCY4qqyJoxiTVjorhIGy5gw9CeIug7dsOejIHjmBzYR68xr8fzG9ksdQXNrZXfuIWFFmjfkePRzAktOKvAE%2FNMg5T1GpUA5kbDqf8oaL2w%2BOisf9q%2BkxGajB7AymAGm6wBDqtTFVgMrNH7OXNBwC4acD8mKXJWSFhw7LRqlkKWrGbKkeBoH0%2ByWUxiLX9eWrnaJ5RvcWVuCxgXD8D%2BZS2gzlg%2Fobj1kzajPYflk0eL4slFKSW7fHIHNe7lpLBa5yb8ebXOTTbWrujcAp2Lkuy3ddjoRBOUdnGny5vd6fxhp2fc6bkHhH5IKLSB9TMd0qwcVMXtqoq8xC5K3bCuuOt5zvvJXnYsG1pgZUMrqNSBR9XiqKSBRRc7GyZeQe75hInVXcpcSXljRukb9BZUCV5uDbWjPuiJoY81xqUFQWZxaZYXqTg1UWSnkO2EQZiaBXS0PANoH%2Fl%2F5vo6YceCNyIjgAeZhIEQGjWo1hk0Df7FTELZRS6xIc3tO8bkgUt8g0uQXbkzXIJR%2BhT2Y120mQxDvDpEf9UW1iTqKQjtVY%2B03KrEgEkDXExsYGqk8ZAUwMjqVYq8CwzY5mf1qaVkkhfT7uN1BhiRKBcYlxJZwBsH06%2FoTb1jniWRkem1l6ZfSO65mH4S%2BS2B5dx9S1BkZegE7UiG9udK6IQYvLSKPH%2BhdzDszhdiH2BQY4R3DDuxaAFMNXRBBvdJhirK8fYtWhDpXjQ4xk%2BIpzQbC3yfIDsoSaokSWI48m22UIgQmgSvwJ8RFvIqf2VcnnQ6HaHVovRgcKatNBVZoalYAX8QFW88%2BVgStXhARJL5EvHdRpMJmTWVhSmx0q6X0f2aVEIxK34sL0k7JpJYOeg4pIHwoRm4102r9Q4TzIbtP3EIbKEJ%2Fx4RYPP4SUtvqi0lPLka9RyQUNO1HNSbbDAajhjA59F7YU4C76SXtLGfnhe9kbZfu9abab86kdFNwYBchIIwNHCwOaNF%2BjXg1NdK5IgMS3N0ddEmbJtrhCGVFpB5uI2MMR6Dq8kB6APan5aqWTQcZNvC3DuCG7XNJVq9OId9vymCqZI2gxzyhyzpwRL2AMzyq1AVDrPhwzYhOHojb3VBYVen0rfA2OAv%2F4mM80ChBXWJrhzpYoSloZwPU4oQL5ZMhLIMI5UMoazSYeVFILRw2kdCwunkmnLEfEMP1Uizai3aUDPaLFOD%2FzAYuSbFoPmSuyHyK9h9s4rcjXqkosRgNIZnyOlIY2y4mYyYLRvkx9DvRX61TUL1KMigX06okCz1SLhpq2yhuDfdMG%2F5UaPWVWhVXJLzr%2FkOqY0xkQD51qCOcxrCBtoVunbX8fzUDoU5vQjqbLX9BlPM58WQ3FF%2FrdGoD1Z13UVULE2VddZAyJGJZwNSsSZ9P3Q4Ri5O6cD6u7pf2sOp446GA5QIWjhFbeKNSO3b5chqp0q6AhqxpUzb0aFBWQZHcgjWF%2FEiq%2BRYrK1AcbkQUhaUzk10KCN5D38gKpJ4FE19KClceMk6MEnfyb%2FI27lM8uMzxDuzIltspjuZJApxalWSRJi1PZmU7MwXFmdvqj%2BZxArgb9VPHjwl1U0ectwiveRp%2FH08aQaafS7CsdNpKUqbfkxmgNdYv%2B34xXehYsgldcRcRHcTa1npc8HSlvZdF61G1SeOoUwV2WF2zWc0m01ZYOm7Enc96fdRJkPqs%2B4SWhUXV7OW9EVPbe1qeB5QGPJrWz8c%2BfA90nZLIZsin5VZbYmkbvXBxIOUB94dblG4gEM8BxuyU4pzxa7cmxs1tlNXGnkw8qatbczqllbR6aRP7jElUpbwmSTHxmtiu%2FEb5Nf7e4tzlvaYpZ20PduPSKvjiKza4ykBLx2XXMeU3Nr8q6%2FbvTynAtjCjHkpUf%2BkEOM%2BYp6FJlO8rqE4Y17bTArYr8TD%2BG4%2FcypFsVbTvkNbq30FUmYUTCl3FEz0UzCp1jxyQZBrnO4jkBKoMFoAh5nqCkj%2BQA8qfxZkj8eQs%2F2fod1sYQX36xbWM7yeDBIsnL0l4OA0jlGJoTDZW2HcjVWBf%2FDibDEsl0xMZz%2FMarfzCjUujXYuUrzu5%2BNgUOs%2BOM1dEAEOyWVG014wyMxnm6%2B7Fr%2FZeRUtwcN0nlbRJJYLvbjmNxINMkBU9aCeJ4JjeURyBboLhb5u%2BYCsh%2FBrfwqrTUqRk95xhBRI481%2FAT20RgMw3ufnIMG59i8pASFX%2F8Na5kNBSArwQSIywutiiTTGiAZnmP328unFyeztkEHL2Z%2BKkGzK1%2FdVdHb3DFpBZ163tTqRZaOO0AUY%2FRkQaK7vHeN3RrGYH3ecoFZGaWl2s8NcmUz6L9z%2Flq11Wgw9GpxTbUuxixQhfBIVmWeE7HkWFF4eIoS5mBva0z%2FDLljPwt5L%2FsGU%2F4RSVjda2ikGwsgRkTjMQKCOkky4x9h3PCxnXWQfh7n4KspZjqDqhbeCR3SEzYyy%2FGFm8Rr3CceDPzTsvt3ywRIz6oroAoG0myW9m%2Fg4KzC1iFhH0QTphGgdJoMHAP8IAGKRRh2%2BNfqVpqZx6UX%2FdVbbgCCLXUa9AXAauow%2BqPAUnN1wUkn%2B92IFcG5xOQJSEaZ9Rz7gn%2B%2BZuphILStOpCRcYKyWnCy%2FcR6lxMzd%2FVcBG67bsS8uyaQNt%2BtbplyulCFbg05cNurC%2BiShqr6Jiyv6cGaR6%2F28KdLYHQG72iN8%2BKAiU73Z%2BKQ1vHUVmUZGgP1CWgQEGLlVUE4NWtQQHHg%2F%2B4boRxvrNi0nkMP%2FqAxKkDQGKYTtunKnBX2z5tLCRApB23YrIrqu%2FIuj0PErxF%2FOko4BzJHS1DRvUccOXwqojCxK4XwymF9wW1oW%2FvDfrqxtieiErXWiZA%2BHjizYfQ8KO5hsxiCRnUUlW074uYCSxRUW%2FG0nAMmWUWRkZRMuDqjQ1KhF%2FnYzgZW6SWh%2BM3WTtq4oy2gn3WYvTDNREm7cPwwdVSgKv4stsrLUXf1ljHyz9VpLNYnVKoewU9yf2eU8BHxQkZuQi0BJyKQlSQh2QSPd097M5K%2BSbOjXS5lwV%2F5YynAlUSAVfb9FzjD6L%2F71PGk9%2FrJaaeQ2ZKkoSkLiUSZ2SvlmbsQkMDiScmQKCC43jMDQPCoLI2IFilB0Yu84kpCm7HyDI8k6nytHig8ndP%2FFf18cu%2BJpduUtNGJnCDjDsGWPYKlNxe7Yrmu3k%2BQR5GkOm9446lSOU1qi9VcGisUhRz13lZylMxesrBenkiuLDrAhj9IZDkMtxIXfjGL%2BV%2BHqbieLSsiqZMu7pWQzRFqeMSzEpZJM6tQagp24Zhyrh3503EJBsTJO9SwfM%2B8Piwu9xef1oltFs6XCuI9KOQQYucHMHqeFRSr4g2t3V%2BMQPKMwi31h7u2qUtR7TU%2BITkncbCCCp5ONEcBpm8VjPFQD0hv1cfHp38JjtCSPYag3AgvvqTgew%2BpxGGkYEaDtIlhRQwxgd3UuUHoDXFAtOAJbFVVpmOcgY4IpbGACBX33JEH8vnZpeVGMKiR6IP2ROQbNSAyFuDCaEf6q7kdbUYiJV2i1%2B2hrPZGWjpthgZfwh0XeFNu8pjqXMTNQg3TVKAKxjBgVQjIO%2BVMsYRjzJ9QYx6igTgFhz26U9moid5SOcJfDVt1%2Fi2iS5ERTJpb6C3OHNshm5M1wlV%2BDXfAzDXmhE29EQ2bBHG6mMipFQRaEpP87mW5YdKYOw4%2BEu5YYRuA7hG5F7MAWSOI%2BjtpJJOGeg8E6BttUIbc0pUgLSepX5BRKAoHcEDNBAgsvcOWoc%2BD3%2B8mJPZJHfggnkGyanJrWsT3lRBvfQGSPzjawvMaipsROl9DJopS1pS9sH0D60%2BEeCnTNCqJUNin%2BNSJYYmj6mxXBIh1QOWj6OctJNaOc3F5LY3Zp%2BaFIaGdIQ96twh6Z9lvjxNNfr1OERJ%2BHTsELREXZ4QQgepenF7y6FtASNpx42pZtrS2xRbautjlVXUZA1ObWhKZYqJQXw2KonUk8ZbWxPnDyXDm5mNWdJ%2B4WTohIu%2FPYrcqC%2Fl9hbowCi8g1YzmvWCTOSNAK1pAZCyMPIvHRociDKSPjICxxJymrP7ULwr2eD5MpjmPwajIGwDOgRQWREQMorKKS1RH9wDTyZRpZy7rF3VL%2FRDo8FEk7gYHfpWyBINRDZYLR8aA1ceH8RlwVEO%2FsyvattuVbx%2F%2F8PJr8W%2FgCp1N8QWDEk0VeYKXLFccZGBHlA2fIlzMoWTmDtlOcQWKpE6xkg6SCsTJB4PeZkuE2yaV8MckHjnbcrhRZObWFgn8sxaVflUCJEpkwOITdDrE1S%2BOJf5w8CoSWa0NM%2Fe8B6O2TNJIYIWRR3Kw0ygL0DfGgxz%2BcmLV3rcgp1ISpDIe%2FqDMnLHQR5C%2B%2FM2Sd7h4RL137zFSshJw0ugIsfJLi5l%2BiYy6dkVu1Wj1qGX4tGE1hCygqiT0lM3YUx1hPXipsPYVUUUeJnWWyr9NBaxM5lNokLMST57XxjCEtI1CNf44IPGKqRzelpIAlPBP0%2BQvTNn9IhqsZd3F0Rkf0ly4sHVj%2F%2B5aLnOWTWbYKI%2FKussRAYatJO1FIJ6%2F4etJ6bTN2%2FsoaIz0VHr2GMkIoxy9gp3nEr4E%2FxCn75DZMePgfB3c2LzCk%2BLrzrKIfbbMqq5whvZpIfmdgQcs%2BOsvJOfSh%2ByQ8iozk%2BsjDtCNWmiPfHw3ABX14wgy7o7DEOXqY4Y2BlnuErWSLfOk4M9j92QzGU%2Bn5%2FthDMqgG%2FrXaQ6HkICfgEFhGJdx8APrrwH%2FgcQ%2F%2Bd%2BT9Uf%2BQb1Bu1yD5eb3%2FOn2r%2B4cXtNJ42F1bh%2FmWdqPr5TJTuwn4XWHkKGhJo0CjFVKJwYgKEytyBliarRhQYR0EsZ40BrhgiLgR0%2FWIhzr%2FyWI4uDbHJCkVPb0r2dKVXkvN2fAMSxmKsQ%2FM8TcwxzXILTgbz8AlxRnbYoys5mPQmW0iR7UGQU0MLa5GIbgTEfm4ZRjBxrHzRB3daq08T682DKMEqOvpCn%2FOSVRrL7ysrlr5whrPsZc%2Bg4vs1zEhbiUT6lh%2Ba%2FQJPsAWYrX2qDWBbXP%2Fg94F%2B69jPxJNhKJA0yA5lj8NphTuxtgPCpgBnqMHnEdHkDQw3iaH1bkZGM6vdAP8mM0wXIdMT3Bhmne64zDwE672%2FylM%2Fx%2FlfqyirC1YPoQyuGARdy0Iy66DMnIgpIByYnTEcCkorIhOYXSUIQR2kFa7I63yicdKFPS%2BwAiFbFJiKSx%2BlqDDQ2LQjxKD5KyJQcputROTU0pjszeuIpnHlCM7VtTKFQbEt4QF2Eqba9sMFoDC3aqot5cJOIqadF3hNblI1qEkQCG3X6KgHBBHimYdhCOsZh27hTii0OkSQAHA%2FXtKlhfZ%2FlHwu5%2FnZYXbMJ%2F9X%2BBmFuObmWfENgUCNbcRz5myZ4CawRWLrbyuzti2vB5Ud9Eg897XWXE4iE2yK%2Fua5V5dkiIcphHvYa5wuGFyKTtVSWuAgCMEm293k4XVPeMXuyj9s3IJdce4BB2dHtrA6OfoBPDjMD%2BbpGyb8zSIEwnaF4DDLHykm0rYk1kOu8WA18nGAwzQ4BA%2BiwZtJYxLHtRnIkexhsDVgIUFSzcxDJCxujuwUYl0B8Z82IxUZxJItr9Fv9KptgqsNASW47iwBCI1g7W0lZQNSUqCLLMmi52fWxjGjZLBPbp7xLt03ddL4GBhWhc33SoDUoiZj4zZ3X6GFL63UjwrvyGJ8pzfQtHu2kMGap4rG5xNJvwxur8LKiNeVFz39wwZf78uXvRXplitT4xCQpthxC43mmSlZsi02U75nk71i8hcalRYpFdlqTLfsFw4DtoutB1CG1V1y%2FVirUhW1whlMZzQhmfkLTBafwXg8gx7L97rxJ61%2BhMPnAQGt4%2BaDmRLYihO9QvZAUP1U9CfNXZ6WjNcmoDTK1yY1FqclcJ28MG0yAqyXcuoL1wYBVxil9LdCVCUL0ivBDcUyKlyYMTiRwTG8PKwYhnCnQZ44FoMrmARnuTRkWQPOqipRKBQJZiHpemMJNA06Toc%2BTabkiIiSIJX4M8QfG1l%2BDIF8jQdNjUh3yBhIrL9saqUnWa3R6QZwEwoJQT5g223OrWxWxjxiZ7VRs4%2FLurv5zLYMv2ExkQZMKkqFVsTowwhii3xmlbBQ0ZUOJgBBjXulQZey7JL6Fdj1%2FHskj8a9X9mG%2BXkgklWgrBgcGSW2iIXRDbaoZdz0R5rYv6s9FhrwdTviMeajJtGgdfVGHr7GskvWKQhcaUh2bPophr6gEOhQ%2BDzJM5E8insoUGlCjNN8isbEGUb5dLAwYNZ813HntpmeC7E4vIWGF3fMdZXKlBKW1MViUWGoiFLIk%2FTf2hKFsWLeCXJi2SGPS9u1IbSDiDeOTKjG2%2Fa%2BqpfnV2%2B3wy7%2F120XPHK%2FUN6r61mRrsF4k14Yxxr5HgQ28doq8PgVGT70%2FkzvxaLhOxLAWnP4Y4Ui1RZBI5PsAmFlZ3LUnUFrig%2BodNBu2L77ZRU0mQn7E%2FzGxvuFJm9o2VlLHruWXnop2CerHnkgiDVZXFnqstOMu1cDmyzWuZfKEHBQuov%2BBW%2FAB%2FwuHPNQtEZzrVlCUmozkrDvVDUQDtLFn8GNZ8pjgLWbvxdiUt6mgP6O73qVSWYku9mKs2ZPygub0mjKSYBhLtQmo8XH78b2GJJvXTNOLt2XZwQTOMVsdgXy3AvLDqtZWm5TGV%2BxiTAtzWcbNKGSE8iSXG3OmF5u7rvdk1eLf%2B3Je80NaO8W%2BECIsd%2B2l1OTIaD5CSN4nenustluZWeuFVKo7q1hbWc7DglB6AGqWOjfqEEc1Ws6M1gwW4lCiiIUDDFZ0RlYPNLLHgCXSuKibGw%2BbEvZ%2BzasWkjIbZmGHj%2FE4TkoMEHOJHQhH%2BRCWgehfG64KSlN9WWEp5EuYwda%2BD05%2BQSxRpASRU8BdgFTddyYICdG4yGo%2BT5%2BJ0WWZF6SRv76XXM3hioT6y3io%2B21VI1WNyYvM140uwDEwDM1whMKxo1iQziO3%2FraZ1OS1Ha9NNiUj%2FlUcfRK7hBoBWA26qsbFX4OC4y7h9OB8Q6ThlXac1H6ECDsCz6ETE%2F4jeflEqxMuDpIuOhYOLTpjuc4VwmMEIrTLDpGFGplcgZtDuXF9Pn5FPJqr9nV%2BqIcq1lY36FZS8RWXlgftmYn%2BtMLR%2FOS8cBql06%2B2tAGykYcT%2FTANbeoSv5YjiABePLnx%2Bl8n9437yYLC5SSHnSpTN8t9unwKhgTXpkBo4LYFkpUu%2BXc6dV7KiwBAKd9rCv6KCFGmflHcoLAF7MeI9dFf5%2BUbqhwD5bwTUGfBgJR0b3B%2BzxawbtpGFHX21RFhLNugEPNxV0SwGl8YRvQefqBE6wZFJxSnxhf3JiinKisCBsWaavWhjN09kPHTBTexMxKmoteV1PrCUL0nTDOaU6XXwZdWLi3luQMxzTMcFfWK2R06ZMunA0FqA4KwuguHWknQJZyzmy5eyKIitnlyoFScm7XVUhUuCgUGlJ2rC2WHGSlEoy%2FMuSSmGycILO8Z9C6ZzCYGZBxWy0%2BJHn9hHubO%2FLV%2FKhRyqWrDGKMjaafMVz%2BwhYfUDfW6XJKVqCEIkhuC30PZ5bE1AltERxOoIZSUWlDcXA8ox4cBjZDshONA0zW7bDweBLCTklG8jrDB4X6pEbkrm%2FNGxeUNQcfqvbrgNmFxov2wmlE4V%2FZSg95Ay7EkuXhKQUT%2BY8Zo6lS2qaQrAilp5X6Jrnmc6Q45YVYNRh32z4dR8zayHIRySzVkipa8yHPWoJ4hFVsaTSPXTYUN78ogFk%2FkySZycQmlXk%2BFUhHA%2BsRpRR8aAeVBFCl2kgXJvLHaR%2FrbNFl5MQCqLMXPPNNongeXYGZ4H51NF0anJmPdG2EGZs0bbDadg5i0%2Bezyw%2F%2Bd3qsh6OPBFzSsRdJO7S%2BpofVUXEZnjwvQ40FsuNHarYY7Ai3s0wevBuBEg1dpHXcp3xcufhmgAE7D7fxhBYA7jEH%2FmgH3ynn%2Ba6Y6MPLEMQGAxGEQa7eJa3kNZr48bmJopXmbKbN0S0RJ8DVrtvgdU0kwDM5E%2F5LLOjSJb7PWsixnAX%2FHcda%2BJvRLIN%2Bexqjkx4685wZNo%2B%2Fk3Bl2UJbb8s%2FrLH%2FFfm5BJpxrhFFszKv%2Fvt%2Fu5D%2BCULRYpcopuypPMlPfpnyy0bQ7kQIc4G0O2GdvvEHgIR20pwY2a%2FRpQSZVKsNYKOC1TJMZhqsNAt7OpeViTIQRQHug1kmNx18ItnIz5ej4dcZE4oaXQ2siAxoi5qUaUYYN%2BvZocH8IWf6YVC1qIxXsjq6d6QXijQLsG23bFd125jEFyv5IH%2FP%2F4H8QVgtmOPoQFzOH%2BoCK2UIh2tZaPNn701UVOTIcJzkQH%2BRPCL5xjVVrysb1SoHNoT0OG2bxq7ubOGrH0Nwq24K6xB3JT3%2BJsrtcPEtx4RZSANPW%2FSSKv8JWkQhLvxyRztlMBnbtFKiVaQweRgWXSyqLD91aAU4dbKp52OzCcWDX%2F7IS0kbvpHit%2BgONAKnrSL3Y4PNTOQQZxbqTvJrqJMqTVxp6FnNOYmZbA2FUfdc5eGmUNasrRb0lBmlbTvrY5VqLGUnQaU3aIBlfYsJo2lzsitWq3ecc8aAuHiQheeaBBPOx27%2B4WyK9wIecguSeLEn0mrDcgjgd76ldiyN%2Bw%2BeO2RW6KDFHHd5XhJGUmWAlq32zzmOTiWIwG8DBf9zCF8Blb9Ni%2BxWnoFFZm47BKofYaOLHseFWvS5ZthZSd2IUrIqWjCSD7OFzLLgYvSFOOptUakVLMawJgblfgN5QBxFlwDS2pT6oAP7gaokDNybTfsbpA2JPnCtKKYfqYu18922CoMVcfQ6s2oOuYugfXMhmfu7sq0NFmKzpP4HEWnyUp0mqxr%2BxOXznP8hUKbbNl8DE6RBIVCuPtcLE5AbvHb8gkSKFDGS%2BzUWIiJQJpVBr0ly6QSBWMXyPAUBhrQVfQhEGykQaUMfeYwrqYeGSb5bQWISXJBRBDSwATBPRF4QQCVEPbPxE1EsGQtR%2B4TBUHAY8Myu0aeGOkgEsYFk4%2BmwoFSvKNpRKQvbX4SwDCg4WKtAcYoFUY4YTFTtD6CMpFxoxWIU88fo1ksQ0B6eDVYnHJj7DrDrjka%2BekJ7IeIZVy74PVkMINjZNCxKnkKQ08K9Zu9tKvXKxX6Zj41x4XaBlYwJF1ZoWEwU%2FzyVjuUzFFSKXfnD1viiFyy25ycJOyshT6iLCU1mGRif16gmWIi7SocdOrYBDnlNbP%2Fguf0xN4uAGaTV%2F6qSGaRXjYpc6qqsmNxR1lYTQPbwVpVeS1R58NzrOYqKsMcL65NbmjO%2FaB%2FNNtZElVSWprd7DApN6EAtS1b6yx1o2Q1WkJCWK8924ZnX6SdwonMZNqll3DQgclgOeiSdSsLDZdWiNm1JtkaTP7Cur2f0ktwVtdLjCI9ZmFmcfRDB7wNIJ5ixlbczQxvORj37QHq7rcAcfxOPRNFZGzP9oG8vkNeohYWgZK60IxoagWyqwzStUBhkRVrKswgL251EmXaLKA7kSFK%2BOIc6yLtgqRYQZADUyAHCJ5w2PDrk5SsJ%2FRDRm6osNkacFGiaOqn%2Bz2PgpGsfECtGkp1w4vGs5xgrBqm8MIClo32RwdVwvuBcpnT2gHbJ8Pi8SwPZoFbjnZiABOc4uRV6HODifUa9ISbaqQJKw29rMF4g2EQwCvssheR%2FzvalhV1Y92B7Z22i3MoXcyJcjSKcBj9DwWeQTgFyn9GqU7uZRd%2F6%2FIy9Dvm8hbHF%2BRNi%2BLokq27NAxhQVFIrZbO4PMJUEkJ%2F7ym8tQqykyFSihsFTPU0x1WMe43VYXEbtQZzJYXQxSlzaykkmE%2FbsfRLJGO2aFsYnAvheWnKtA6VVg90A59bVb3tUlJaCSW%2FJrPS2vr1XJt8Lik8R7rMrXmk5rNpgxjC9QESdz1pN9H1Jz6dgicP9E6Rqyt%2F7pp0wtMHogLtXJ6E%2F16%2FPnYXt3IbEcHb3c6gIs4U%2FsevAWiavBk7tjH3%2F6Hv%2BY0xOGkv6QXE54NnwwD3qtid6xJ32f7j9H7rNu8LW1orWB1WAPbSgu1nB5JqI%2BkHaZNft1yPdtt%2BMCMtLtzhEC2emox78OH4UAc30I9B5OjAGzUt4a%2BA%2B5dXjLPxwlazGkGyiu2RM4kVN7aGrP%2Bsflo1GWAVgQvf14zsYFmi%2FZw6rijIXRWFz27hwXdxIK6Ns4%2FuRxZbds9rOl%2BrCmsUYN2wu7I1d1uTbqwH9fKT1GYkYQCzTaBYbbtq7%2Fip%2BsUhhWSeM4CbX4rm3ZX0CGhoMq0FISGkIoUVKIywkR%2FRcEcldIusWKwrD1Y4BbMkKC3HUcTNVusDBUmUn34ywKmK38P66ZpeTkZrCUvNj37Ej37q037v219FlnxW%2Bct3OrN8tdkzC9d1tU58wRvIkOByo4B7suMHqkLf%2FAxEi7FNI%2Fc7X0anE2gwrKCT5stoVfEv2STLscZEkVdR1meMWyib0MsLermNEk4ioIGcPyK6jnwpejytzUqcoS8uUta1X0iB5YXk4nHKeVva9esSaQlSPgkPlZPxmqcJS39RUEVaIQP%2FCrwsZ3HHouxgdhmZ%2FQSNoVCsMeyS3c5d%2Bn%2BvU0jc0nrLND2UjdN8hd6UF1S7J5RMzQ83op9KyqJotywv32sYGzDBhaddgL78aEJcobdIxJQhU7fEjnqldDl3vE%2Fe9ieDzodou351lEGQ9pbs0hws2uu0k5YtLKlEB8MrCwBj9vDBebjCywXs8BE24%2FveZEu8WPWXPHFNV5U6cIeJKCpld6XTP71F01I9Ell1FWzOnUUl62rsrIDcyyzSosZRkJeqyuvxMDzn5vTv4Ds8JBNFJUdvj6xJcAtskYIkp178yM27a9Cl91Okw5Nyqr%2FqzuGO6v9ClZEx%2FXzZk5FFBqHcBUMBUe1LcUuMlopinIy0syLGgOSQGdwI6U4bpQBhWc79pycjFeKDD1hEfKNqXfFcW%2BVnq94h3Vi0jloJ5T3utW6rkdVfXEdrTGku7Vsuc0vNx3OpwA6UIJ0Ym3d3mjQnHjrL2kWFQuDDjKXrq0ryrKlS0cqLGDhyFl%2BpbrPrM4rDndQo010vKrxRnt3OE%2FO2vwit2Vba0vsRdbVNqeqay2yJjRFpdhFTnLr7S%2ByetCzvx1HDztBrtS0CYNcrWmTTbcrmrZKJ7%2FYfQ8KcKfDJJRfhgOt5tm8QYirYvjbDvdx0GgvHKqqrxzpqGcBxFyoxPEUKhAFOQRWCNGXKUsHW1BBwQwBQNY3KR1spc21bbZ0aMuqqLfXkg66rvDaOm7ab6gAnBqPCW9fPJA7H8RDkeKBMP0M4kHcLfFAyrIp8fD7JUNI%2Brl0CBBILGWXxYG2mb29yEoSssN57zBDiOVyMMjrR05aNbOTljhFd4Y3MJL8MaIThG1SIYqPgZocGBLq0qCi9glKNrCndJ1kH1gPUbp%2FzHq4kiLyYlyp%2BBkfmjN%2FUCBX0jOoID91m%2BuKKlpKJq2Sb8v2Ur%2FCegxgHe0wmZsoM5LtZZZjnC%2FQ96fz1GpssPdV1uzARULgS%2FTcLmUHbicGKGXOASSEtSviRafdk4kY4Now4%2ByoYaeDVmN11PCoKkDgcYNHFi8WVRwCJK%2BAf3Gv6VqRxN8v0fTcIl5cidOJBAjbYu28aq2z3KyFYOL%2FJA5Oh72Trv4EvEGcTFkULfZHVjt%2BFy8rnR%2Bk%2BlKpXly4W6edvih8G%2FfpIapsRUnmatS2%2B3sYwk2k46aFcHMiCC1BEAqjOivsDhnLxlKLogiBYyjhuBUuNMZQm1vYp26Jp1iGXfNM0kfPRL3sdB39HLXCMyqpdHNoUreCQmRGvp7ESg4trH5P4BihhIOjOFddXeD4jLq6wO1WFFHgGPl6i9jRr1dvF9Sfh69YlDh11xXakBaT7WE16M3D3dKNbKHDRePW8Ajy%2FsF2rKhNq6YeSdyieaxRI63VZdKBFnV5pUKQEXWl5AQ5l3b7GHeFzz0S%2Bdv0Tj7RiIdXCCpQNNrIUjMKKwoSuAywMAch8kMhkjXWKHC7BekQjjzWjxzmntku27dC46ktM4rT3DzN2L2vADdgm6%2Bl8cQ%2FhhdfQxNHKMd%2F90%2FUVi9gXPChaYZ1yWq3w5F9B%2FQiDw5XHCNLtpnVGAY0s76tMANa4Fj1v99w1KS6HkOBKHB%2FwP%2BIcDPnazlnElTwC2vtciIhgSo6UBl10bzMgrcrjogYRQdB43od6Ugq6Q1vwH9Qj9Jh5%2FdY4tbaehTtA2QZ%2BkhnMw3IdwOLXg9HQONFHAx5Nt1JagbWJWyYdWVICCbr6QwsqBpElyM5iT7UwMKjyKyrjzwspsVKc%2BT7owG4oA9PmGFzBJaXDj3M8MbAmAo0LYt86TgzmH9hBuOp9Hx%2F7CH%2FJFDza632UCg5yBoYtm231AJPFGpty7fAf%2BBxD%2F535P1R%2F5BvMFxag6LV6%2F3X6VvdP7yglcbD7tquyW85LcNWjyn1oYXRo5gsJmJxwc36lXgGOULPYTlo%2BbUGN1RgS7HAFYkjcwHLg1zsygZGQxvlp5RR7glgair6%2FdrMD0nkVaGUoyBEWIF3lzh0rwPbzMg2E9XKvC5n1PiK608Y2j07VyLI0m40FuoLz4bvLc7c5zfdOGonq%2FUXlJMdGkKJLSerkRtJBowtJV%2Bc1sCOGDYXnDUeMMReua7tL3jvniL5aJlChzkRxmILpwM7MhmjUFzokBBdgbYwlp5I7kbo6S8zhX9KQtszdHlWLEGD%2BpchoqhAFWYGS1CnaiPlyepTC%2FZrvPc57XQ1udOZbX5ZmC3FmY78wUG7Xw7avNQVSiplRQkvkFYP%2BQrfLWwLKWB1sIlw9tXBJsI7VgabCiCFPU9O4HNNThDEeDnJ7iffCjwdVmZkpdZG7kJ5jFgutFHyFyqHROvQEpycYXryOs%2F0IxTnecnQtfjgsd41j3VurhBKEd6%2Bz5oO3MXcwfWeBUukxbvqyVnjvnr3n1k1rlNJ9uD9jS24ngj3CxzD8AmBKTcCVikIGRyZB2XyZ3lLZEpXq5KCmlGV3FDeEhn5CvXDHQ1IGsdd0E40f%2FjaUDZRSylUVCUbs1c4S%2Be3lLSYiPywIVJY6HfFcXshiyXJ2lsFhzEWKAuSJh5FYBZKHEfOZ%2B%2F98t1S2pzZQFialIENZLUoo3VWS8TGD1vL8LyWpN1kZC2ltQx9qzAtl9oG5FZ4eqhb5WZSCRkaXBx07l3TuXMKv3NJ6mO48zarcQusVLlFdgWWq0SqHjTtrAudVLVZ0paJxFzgSmdIT%2FvV2cwJGFigmDFCuApjzgt0lgvZHGhAgw3BYFmq6y%2F0mxWktrIWlRkAKc5rRlSIeMZGQd12cgilpu%2Fa4pYtyf9EhruTnU5RXJ6ZyMoz%2B0Y6BUSAyF5awIJ8XhMJ4sAM0qiKkb242dY%2BgB9RRHWI3G8kcv%2BTjh5pjTu24ZdJppgKEouqVUZgSC2qyZgg0oGhFQD2jJYt7H1wUG%2Biq0%2FQncK1ZxiEIQZ6dO2TzXVzXPuDg%2BKvdVCISU9biJazNQeFmMVBERakrOBSB%2FdFJjKg3BeSEkqpVQ6M4mKFEq1qUStadKxQ4OiFqtW2FyvckeACsO%2BOMgYXpNxx2NmufrrhddIIKNrTL9IOt9bEhTMecKR5HTe1G7leqdUHPGv9oGX2WoyimIWYqMTVWXFFltetQEahUNO4e8C6fGy7LnbvamBdFg%2Fap3wFwiEy8BI5b17yQ8LbgWyWA3WEV%2B5YNovESndYD8mWF5Yh2ebSwBUYZ34ol4jqDNXoit23u6gD5c86uTrDKSARpoo%2Bjz28ALRbYV3DbN3K1Y1LX1krJboU8MwaEY0vkcbQmykTkb7baDjpWPz2rqgi1FRNRMahBIEIljvdvTGqhaQfFwwUPsrtNo8FWOMHhggmBo6UfMLoeHDAmYcXtuZIAiGE48RjWmeb5zd9BB4wGF816DwCkWjBQMEppWbBFqVz5u5FgBJVhI8DrPUaKkiUj3QB4UCk3vHGhTDZjJ8msApXsYSDZc9mF0mYEl6kzXqmg6dARpGO%2BDV2bSYBN0M%2F4Z%2FI3oSpmE34N9yI8ZOW3lRbSnyXdqyB05%2BTSxRrANc6eApQuZqu5UB%2FIDcYDUfJ82n7XS9pYz9d0mZhM5BIBF3FjCbyDPwb1P7Zt%2FpAM2M8pfbvv%2BkxnRSWUvSYuH%2Fx%2FG5uDFkXuQUUTgfGY7mh%2FUmvMM0VEWvScT8mA3Inug3Tdme%2FqDff8AImn%2F8v8uXnNbNZnwoEmZ%2BqlEafeJzq2llzelotVYNBZXr%2By%2BlLAOOogTD%2BJ6%2FnLQsNb4mNHFhboaxNRvwL4XUBPdRUtjqzK%2FfT755rBCEJVWEaiC0ASUMfTISohu0ChNpmAPnDR34VnpLhcR1ZE7CTkrBoHAyPmAi1jdx5m%2Bvq7umChhDsGrRXNDnsXrXV2c7gZtmP6U%2FFst%2BL19u%2B7rUnIg53TOBYaJWhuwPsZBVKP8hSOcRkCbPe5hp4Y9cZdvdjFbBXB0u4MhJaqHEtWAjIPfltT%2FVfxDQB4RvlSLvg6CZQUK8pBOKqyzGNBWyLUFGB%2BLC%2FfhkP1kQhxKUhNhr2rclCXCSza9uEE1jTe7fhV69A2EMcmR%2BGvBQrmm5BHvamQ4jRei0icxUYhjGrERRqHVomwa%2Bw6Uk62kUpAp6qBkwK3pB15wTfYVAf9coHVXHbbjraFoRVAUa%2Fn%2B5NO7i3DgLp28wPqDpGOcY24BF%2BaaR485PeRJi8%2BzDjVGB7wczDrnbpEmS7hL9Z3bWwJYg6CjVkc9GiX4F%2BK0D38OIq2gZY0FciDsdQHOvIVOAipxQoanWeKAxY%2BAroEfjp2OKrIimMfGSGEghxDX0wOPR08AF5nRf7E3%2FYNqPeX0m9J4wduxNqEY015CUhFnboVN8pE5XudbKXXoZk6s7mJ3ocnVa2Y%2BD4n%2F2Y7oOdsynuuU8uWRXKfQP1egLMVEc4zkDyYrkcOA0kqLPpYiRrL26kw2LWAzMtWtaBeTd5tComlGnwCF4VnEJZTepPUOfDypYUSEioYx1CGrmvSzWIwwN7Rjfi28YI%2BqFpODIcLmK0k7eB%2Bn9j31aYAnxg2geVl82ukxs6tLBUaFYbfEQJDikxwq6h7SaQFjHRWA4iUjPiCmGYkOnsJGBLUiyFGwwDKtx0O0D6PuFQdTi8UHEPnDUVkhNeDTy64AP2KgT7ibIEDtvosI2W6soJktyqz2mBH7UPc6vC%2FarpkUmOGuM6CuCE8o%2FuS7rEXxXGiNLctoftvrWQzsohZX3qt8oEdycjm4S2DvGqQ7zq2ybFDqXt7nk6dtQQS9jOePYTeYE1eH0QJqktTZ5gxUvgI%2FApHRl9RJE9iK9ti6%2FlAC3ucQHsPGVSwOExLH8kRxMFrgFk3pql72m4EEXVm%2F6hUJl5joFuqPE6q%2FFViEaWf9GpLO4uRMzfBOaRGTZKFnYLzIP0%2BT1AvewEdUi7RR1k5AeolwPUS35QL3qJU%2BPCVGI2cdo41Avd5CAbnR6gXlYogQeol9Us4QD1wmYXGlfi4ujSfNj9ZHtoL0SPO6C9HHxwu%2B%2B6OKC9%2FAanzcohHdBeDuGFA2ujwwu7g%2FYypjbQTi35oaTtsId3cQ%2FTda90MU667bkTmfm%2FtUr%2FkBJxSIk48LvN5%2Bvh0DmuFcwWnT8YaNs20LYQVc%2B82vsRZ9eERJidFRmQSSw%2B1hqzwCC7trtB9kUflhLHJ3uxKMLR8m4s6Fvddh0wU7Dt4N8Wtyfx1gyR2R1rwkE825uiSf47NMkdrdUb6LdRY9vyerBdI%2FrhFklT3zHSZIVGDiklW6IOhd8t6pBX9lP5y1JKCELbIY%2FkG3kkWlxbVHeiZZDMaPV6yCOJD%2B%2FvyiOJwHZEtnw6xsUhVySftkAKo%2B3zphNF0lMoD4kiB8%2FkjnnjaMGBK%2BExwh2sCaqwoO4ieKxB3VCIxLwOUl6U74KHQr4bjkeGIsNEhf06qpM%2FuEOLcYdy%2B9rZImxoEUUPRtVyh7jhX8vvcJ2kgYoYK6jdTBTvxgwSeQ0uqHgMqivpeLUMC%2FkBO4uihH8PlD6JUU0XXmKQh0oEvnotjPIIakHyLShE2QOT3XbMaeWQ1o%2B6r%2FI4xELt6dLg96YG7nUITZUTRpDKMIIklhHEi8VZQYzSGiYef8Aq6fJ1pPNpBDUfY6JC7hc2CDMYW6oadvRI6rWrQPYIA6UANzFV%2BizjPRijgl4INYBYKL0hY5ZRYhNGWjOPTKN8cnlmxoRNWjr2ot1MME21CZj5Zc9SiMYeTsP3n0646rDpjQMeCiYVrJ6JHg1EDZQ%2FdNpWiIiDcInAOi98PktGTqloAfxWiKpcYSMSQEEdgeiSuNg6R2QfjbW7BPsgfKQMSc7gWFhAEdMF3MQkc21EsQ5pdKBoszwDkY6IutIIGVcgCi8W9s8zCNoGuiM1B%2FTYwyIn%2BkUxzrXM%2BlV0syb6%2B6FTOGnPlAgwFTUrif5%2Bmd6YNQkhcmSkH0cqZYWgSxSLkTi4vwN4ULMWN4HTlCnUf0uXIxdjyqLgvw0D3z0Ldt0SMgtpKdzSIcY5tqvji4c69%2BEHr0VY7GlODpiiNXrAFPVFO%2BRoBCGLMKfU7ZGVb0VvHxAF5dEg68wCkA9yr6KLVEXXhC6KKCuVA2I3xEBpNuUAIDPJtLB5oEXeMVyO%2FXLtWsGBvt1ZKFH5azmKllByZI1WckSOlSek6oUFvllxnw0HvnmBXrV9CnyTcHaGwLe8W4FvMnJGIGCFbbciXLXCsFuCB%2F9rgsmKUqsBHl1k5EhKBpMFTqdZisCzg8lSYZaTIjIsp9SwZN11Rq7jz1FRut1eWpaeInjAcvRHkwyW7jiSqRX8KJK8RTElhiRLZgzoOsoYADYXcoYKAUsKJJzIRc7BU3DFwNme1Ubsav0srDXkTQL%2BSeAEBnGwjGq9OMpgwVUcxE2%2B4kbOLG60HRM3LGCng7jJJG7K5VqtXN6wuBFYuUubFzeMdIUV2CcHMVOcmOFZwEgbFjPagZF8PwmyqmyckYispKeNMxKVYzAS5cgUUE%2BHSHoIg7WYxFNXIQHLcuA8CVwuKmozoh74TlF8R8iKsFQc31EZ3hTsBzQ5VlZSpDOegSP5uYGARbt5iCjgQadJoYfh8AHsQhkPKASBCjxEMxKxiEQNTJXEGirIuYqdoBqVpRKNCNHDCD2xOElADl3gKwNeOBvADDpnabXwXqiPK6PqPto0SyDJC2nDWV29v2pR4h0uTPag0na95wy7fTuwNFbtfAteRnYyV5J4JfpHJVcEux%2FuU02UdJmXZEXkOSW2azkGq0i3lzbqUCk0O%2F8P4AwEC5n4aDWGQ%2BX%2FM4R3pCksVYDconxQ%2BwIu5w6M2Azf%2FJRUkAoA">参考这里流程图阅读会更加容易理解</a></p>
<blockquote>
<p><code>BeanFactoryPostProcessor</code>接口是Spring初始化<code>BeanFactory</code>时对外暴露的扩展点，<code>Spring-IOC</code>容器与允许<code>BeanFactoryPostProcessor</code>在实例化任何<code>bean</code>之前读取<code>bean</code>定义，并且可以修改它。</p>
<p>而<code>BeanDefinitionRegistryPostProcessor</code>继承自<code>BeanFactoryPostProcessor</code>,比<code>BeanFactoryPostProcessor</code>具有更高级的优先级，主要用来常规的<code>BeanFactoryPostProcessor</code>检测开始之前注册其他的<code>bean</code>定义。特别是，可以通过<code>BeanDefinitionRegistryPostProcessor</code>来注册一些常规的<code>BeanFactoryPostProcessor</code>，因为此时所有的常规<code>BeanFactoryPostProcessor</code>都还没有开始被处理。</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1.getBeanFactoryPostProcessors(): 拿到当前应用上下文beanFactoryPostProcessors变量中的值</span></span><br><span class="line"><span class="comment">	 * 2.invokeBeanFactoryPostProcessors: 实例化并调用所有已注册的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>invokeBeanFactoryPostProcessors()</code>方法中首先会调用方法<code>getBeanFactoryPostProcessors()</code>来拿到当前应用上下文<code>beanFactoryPostProcessors</code>变量中的值。然后再执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br></pre></td></tr></table></figure>

<p>来实例化并且调用所有已经注册的<code>BeanFactoryPostProcessor</code>。进入方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">	Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 判断beanFactory 是不是BeanDefinitionRegistry 如果是则直接调用invokeBeanFactoryPostProcessors,</span></span><br><span class="line"><span class="comment">	 * 否则将 beanDefinitionRegistry转化为BeanFactoryPostProcessor 然后在执行如果是则直接调用invokeBeanFactoryPostProcessors</span></span><br><span class="line"><span class="comment">	 * beanFactory是DefaultListableBeanFactory，是BeanDefinitionRegistry的实现类，所以肯定满足if条件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * regularPostProcessors用来存放BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * registryProcessors用来存放BeanDefinitionRegistryProcessors</span></span><br><span class="line"><span class="comment">		 * BeanDefinitionRegistryProcessors扩展了BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 循环进来的beanFactoryPostProcessors,正常情况下，beanFactoryPostProcessors肯定是没有数据的</span></span><br><span class="line"><span class="comment">		 * 因为beanFactoryPostProcessors是获得手动添加的，而不是spring扫描的，</span></span><br><span class="line"><span class="comment">		 * 只有手动调用annotationConfigApplicationContext.addBeanFactoryPostProcessor(...)才会有数据</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 判断postProcessor是不是BeanDefinitionRegistryPostProcessor,因为BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">			 * 扩展了BeanFactoryPostProcessor，所以这里首先判断是不是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">			 * 如果是的话，直接就执行postProcessBeanDefinitionRegistry(...)方法，然后把对象装到registryProcessors中</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">				BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">						(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">				<span class="comment">/** 注册bean定义后置处理器 */</span></span><br><span class="line">				registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">				registryProcessors.add(registryProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 如果不是就装到regularPostProcessors中</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				regularPostProcessors.add(postProcessor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** 这里不会初始化FactoryBeans，会让bean工厂后置处理器去初始化这些常规bean</span></span><br><span class="line"><span class="comment">		 * 并且将这些bean分离出来按照 BeanDefinitionRegistryPostProcessors实现的接口*/</span></span><br><span class="line">		List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 1、调用 实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessors后置处理器</span></span><br><span class="line"><span class="comment">		 * 获得实现BeanDefinitionRegistryPostProcessors接口类的BeanName： org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span></span><br><span class="line"><span class="comment">		 * 并且装入数组postProcessorNames中，如果自定义了实现了BeanDefinitionRegistryPostProcessor接口的类，并且也在自定义的类上打上了<span class="doctag">@Component</span>注解</span></span><br><span class="line"><span class="comment">		 * 在这一步还是拿不到自定义的这个类，因为spring还没有进行扫描。</span></span><br><span class="line"><span class="comment">		 * 扫描是在ConfigurationPostProcessor类中完成的也就是下面的invokeBeanDefinitionRegistryPostProcessors(...)方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 获得ConfigurationClassPostProcessor并且放到currentRegistryProcessors</span></span><br><span class="line"><span class="comment">				 * ConfigurationClassPostProcessor是很重要的一个类，他实现了BeanDefinitionRegistryPostProcessor接口</span></span><br><span class="line"><span class="comment">				 * BeanDefinitionRegistryPostProcessor又实现了BeanFactoryPostProcessor接口</span></span><br><span class="line"><span class="comment">				 * ConfigurationClassPostProcessor里面执行了扫描Bean，Import，ImportResource等各种操作</span></span><br><span class="line"><span class="comment">				 * 用来处理配置类的各种逻辑</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * 把name放到processedBeans,后续会根据这个集合来判断处理器是否已经被执行过了</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 排序处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 合并currentRegistryProcessors，这里为什么要这么做呢？因为registryProcessors是装载BeanDefinitionRegistryPostProcessor的</span></span><br><span class="line"><span class="comment">		 * 一开始的时候，spring只会执行BeanDefinitionRegistryPostProcessor独有的方法，而不会执行BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 * 父类的方法，即BeanFactoryProcessor的方法，所以这里把处理器统一放在集合中，后期统一执行父类方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 第一次调用bean定义后置处理器,这个方法比较重要，需要我们点进去详细研究一下</span></span><br><span class="line"><span class="comment">		 * 可以理解为执行ConfigurationClassPostProcessor的postProcessorBeanDefinitionRegistry()方法</span></span><br><span class="line"><span class="comment">		 * spring热插拔的体现，向ConfigurationClassPostProcessor就相当于一个组件，spring很多的事情就是交给</span></span><br><span class="line"><span class="comment">		 * 组件去管理的，如果不想用这个组件，直接吧注册组件的那一步去掉就可以</span></span><br><span class="line"><span class="comment">		 * 注册<span class="doctag">@Import</span>等注解也是在这个方法中调用</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 因为currentRegistryProcessors是一个临时变量，所以需要清除掉</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 2、调用实现Ordered接口的BeanDefinitionRegistryPostProcessors后置处理器</span></span><br><span class="line"><span class="comment">		 * 再次根据BeanDefinitionRegistryPostProcessor获取BeanName，看这个BeanName是否已经被执行过了，有没有实现Ordered接口</span></span><br><span class="line"><span class="comment">		 * 如果没有执行过，也实现了Ordered接口的话，把对象推送到currentRegistryProcessors，名称推送到processedBeans</span></span><br><span class="line"><span class="comment">		 * 如果没有实现Order接口的话，这里不把数据加到currentRegistryProcessors、processedBeans中，后续再做处理</span></span><br><span class="line"><span class="comment">		 * 这里才可以获取我们自定义的实现了BeanDefinitionRegistryPostProcessor的Bean</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">				processedBeans.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 排序处理</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 合并processors</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 执行我们自定义的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 清空临时变量</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 3、调用其他所有的BeanDefinitionRegistryPostProcessors后置处理器</span></span><br><span class="line"><span class="comment">		 * 上面的代码是执行了实现了Ordered接口的BeanDefinitionRegistryPostProcessor，</span></span><br><span class="line"><span class="comment">		 * 下面的代码是执行没有实现Ordered接口的BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">			reiterate = <span class="keyword">false</span>;</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">					reiterate = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">			registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">			<span class="comment">/** 第三次调用bean定义后置处理器 */</span></span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">			currentRegistryProcessors.clear();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 调用目前处理的所有后置处理器的回调函数</span></span><br><span class="line"><span class="comment">		 * registryProcessors装的是BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">		 * 上面的代码是执行子类独有的方法，这里需要再把父类的方法也执行一次</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * regularPostProcessors装的是BeanFactoryPostProcessor，执行BeanFactoryPostProcessor的方法</span></span><br><span class="line"><span class="comment">		 * 但是regularPostProcessors一般情况下，是不会有数据的，只有在外面手动添加BeanFactoryPostProcessor，才会有数据</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">		<span class="comment">/** 调用在上下文实例中注册的工厂处理器。 */</span></span><br><span class="line">		invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">	<span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">	<span class="comment">/** 这里不进行初始化FactoryBeans，而是让bean工厂后置处理器去初始化这些常规的bean */</span></span><br><span class="line">	String[] postProcessorNames =</span><br><span class="line">			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,Ordered, and the rest.</span></span><br><span class="line">	<span class="comment">/** 分离出 orderedPostProcessorNames 和nonOrderedPostProcessorNames */</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 循环BeanNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果这个bean被执行过了，则跳过不执行</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">			<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果bean实现了PriorityOrdered接口，则加入到priorityOrderedPostProcessors</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">			priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 如果bean实现了Ordered接口，则加入到orderedPostProcessorNames</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">			orderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 既没有实现PriorityOrdered接口，也没有实现Ordered接口，则加入到nonOrderedPostProcessorNames</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1、调用实现PriorityOrdered接口的bean工厂后置处理器</span></span><br><span class="line"><span class="comment">	 * 排序处理priorityOrderedPostProcessors,即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 执行priorityOrderedPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2、调用实现Ordered接口实现的bean后置处理器</span></span><br><span class="line"><span class="comment">	 * 执行实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">		orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">	invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 3、调用其他所有的bean后置处理器</span></span><br><span class="line"><span class="comment">	 * 执行既没有实现PriorityOrdered接口也没有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">	<span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">		nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/** 这里会调用EventListenerMethodProcessor.postProcessBeanFactory(),注册事件监听器后置处理器 */</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">	<span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">	beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，判断了<code>beanFactory</code>是不是<code>BeanDefinitionRegistry</code>的实例,这里毋庸置疑肯定是的，然后会执行以下操作：</p>
<ol>
<li><p>定义了一个Set集合，用来装载<code>beanName</code>用的，后面会根据这个集合判断后置处理器是不是被执行过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p>定义了两个List，一个是<code>regularPostProcessors</code>，用来保存<code>BeanFactoryPostProcessor</code>；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>另一个是<code>registryProcessors</code>用来保存<code>BeanDefinitionRegistryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>BeanDefinitionRegistryPostProcessor</code>扩展了<code>BeanFactoryPostProcessor</code>。</p>
<p><code>BeanDefinitionRegistryPostProcessor</code>有两个方法，一个是自己的<code>postProcessBeanDefinitionRegistry</code>方法，另一个是父类的<code>postProcessBeanFactory</code>方法。</p>
</blockquote>
</li>
<li><p>循环传进来的<code>beanFactoryPostProcessors</code>，正常情况下<code>beanFactoryPostProcessors</code>肯定是为空的，没有数据的；因为<code>beanFactoryPostProcessors</code>是获得手动添加的，而不是获取spring自动扫描的。只有通过手动调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">annotationConfigApplicationContext.addBeanFactoryPostProcessor(args);</span><br></pre></td></tr></table></figure>

<p>才会不为空，获取到数据。</p>
<blockquote>
<p>如果<code>beanFactoryPostProcessors</code>不为空，依次遍历；判断是不是<code>BeanDefinitionRegistryPostProcessor</code>类型，</p>
<ol>
<li><p>如果不是则将遍历出的<code>postProcessor</code>加入到<code>regularPostProcessors</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">regularPostProcessors.add(postProcessor);</span><br></pre></td></tr></table></figure></li>
<li><p>不是，现将<code>postProcessor</code>强转为<code>BeanDefinitionRegistryPostProcessor</code>类型，然后注册为bean定义，最后加入到<code>registryProcessors</code>集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"><span class="comment">/** 注册bean定义后置处理器 */</span></span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
</li>
<li><p>定义了一个临时变量<code>currentRegistryProcessors</code>，用来保存<code>BeanDefinitionRegistryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p>拿到所有<code>BeanDefinitioinRegistryPostProcessor</code>类型的bean的名字，将其保存在<code>postProcessornames</code>数组中；然后遍历<code>postProcessorNames</code>数组。判断是不是实现了<code>PriorityOrderd</code>接口，如果实现了进行一下两个操作，否则跳过</p>
<ul>
<li>从bean工厂获取到<code>BeanDefinitionRegistryPostProcessor</code>实例，将该实例保存到<code>currentRegistryProcessors</code>。</li>
<li>将上述步骤获取到的实例名字保存到<code>processedBeans</code></li>
</ul>
<blockquote>
<p><strong><code>ConfigurationClassPostProcessor</code></strong> 是一个很重要的类，这个类实现了<code>BeanDefinitionRegistryPostProcessor</code>接口，而<code>BeanDefinitioinRegistryPostProcessor</code>又实现了<code>BeanFactoryPostProcessor</code>接口。</p>
<p>在<code>ConfigurationClassPostProcessor</code>中会执行扫描<code>@Bean</code>、<code>@Import</code>、<code>@ImportResource</code>等各种注解</p>
</blockquote>
</li>
<li><p>进行排序，<code>PriorityOrdered</code>是一个排序接口，如果实现了这个排序接口，就说明此后置处理器是有顺序的，需要进行排序操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br></pre></td></tr></table></figure></li>
<li><p>把<code>currentRegistryProcessors</code>合并到<code>registryProcessors</code>，这里合并的原因是因为spring只会执行<code>BeanDefinitionRegistryPostProcessor</code>独有的方法，而不会执行<code>BeanDefinitionRegistryPostProcessor</code>父类的方法，即<code>BeanFactoryProcessor</code>接口中的方法，所以需要把这些后置处理器放入到一个集合中，到后面统一执行<code>BeanFactoryProcessor</code>接口中的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br></pre></td></tr></table></figure></li>
<li><p>这里可以是一个扩展点，在这里可以自定义我们的注册逻辑;同时这里也是第一次调用bean定义的后置处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br></pre></td></tr></table></figure>

<p>我们进入到这个方法内部看一看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">		<span class="comment">/** 这里调用ConfigutationClassPostProcessor处理beanDefinitionMap中的bean定义 */</span></span><br><span class="line">		postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出来，通过循环依次调用<code>ConfigurationClassPostProcessor</code>处理传进来的<code>registry</code>。不妨在进入到<code>postProcessBeanDefinitionRegistry()</code>方法中看一看。**注意：<code>BeanDefinitionRegistryPostProcessor</code>实现了<code>ConfigurationClassPostProcessor</code>**接口，所以我们这里应该找<code>ConfigurationClassPostProcessor</code>类中的<code>postProcessBeanDefinitionRegistry()</code>方法。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">	<span class="comment">/** 这里会解析配置类的一些注解，例如<span class="doctag">@Configutation</span>、<span class="doctag">@Component</span>、<span class="doctag">@Import</span>等配置注解 */</span></span><br><span class="line">	processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要调用了<code>processConfigBeanDefinitions()</code>来解析配置类的一些注解，例如：<code>@Configuration</code>、<code>@Component</code>、<code>@Import</code>等配置注解。<a href="/archives/8d05e930">详细解析参考<code>invokeBeanDefinitionRegistryPostProcessors</code></a></p>
</li>
<li><p>清空了临时变量<code>currentRegistryProcessors</code>，因为后面还会使用这个集合变量，所以这里使用完毕之后需要清空，一遍后续使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">currentRegistryProcessors.clear();</span><br></pre></td></tr></table></figure></li>
<li><p>再次根据<code>BeanDefinitionRegistryPostProcessor</code>获取<code>BeanName</code>，然后进行循环，判断这个后置处理器有没有被执行过，如果没有被执行过，并且也实现了<code>Ordered</code>接口的话，就把此后置处理器保存在<code>currentRegistryProcessors</code>和<code>processedBeans</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">		currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">		processedBeans.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以获得我们自己标注了<code>@Component</code>注解的后置处理器了，因为Spring已经完成了扫描，但是这里需要注意的是，由于<code>ConfigurationClassPostProcess</code>在上面已经被执行过了，所以虽然这里可以通过<code>getBeanNamesForType</code>获得，但是并不会加入到<code>currentRegistryProcessors</code>和<code>processedBeans</code>中。</p>
</blockquote>
</li>
<li><p>进行排序操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br></pre></td></tr></table></figure></li>
<li><p>合并<code>Processors</code>，合并理由同7</p>
</li>
<li><p>执行我们自定义的<code>BeanDefinitionRegistryPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br></pre></td></tr></table></figure></li>
<li><p>清空临时变量，同9一样</p>
</li>
<li><p>在上面的方法中，仅仅是执行了实现<code>Ordered</code>接口的<code>BeanDefinitionRegistryPostProcessor</code>，在这里是执行没有实现<code>Ordered</code>接口的<code>BeanDefinitionRegistryPostProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">	reiterate = <span class="keyword">false</span>;</span><br><span class="line">	postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">			currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">			processedBeans.add(ppName);</span><br><span class="line">			reiterate = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">	registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">	<span class="comment">/** 第三次调用bean定义后置处理器 */</span></span><br><span class="line">	invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">	currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上面是调用子类独有的方法，这里需要把父类的方法在执行一遍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br></pre></td></tr></table></figure>

<p>这个方法的调用链很深，其实他最终会去执行<code>ConfigurationClassPostProcessor</code>类中的<code>postProcessBeanFactory()</code>方法。</p>
<p><img src="/archives/e74be873/image-20210828130627960.png" alt="ConfigurationClassPostProcessor#postPRocessBeanFactory"></p>
<blockquote>
<ul>
<li>在<code>postProcessBeanFactory()</code>方法中回调了<code>processConfigurationBeanDefinitions((BeanDefinitionRegistry) beanFactory)</code>方法来解析了<code>@Component</code>、<code>@Configuration</code>等注解</li>
<li>调用<code>enhanceConfigurationClasses(beanFactory)</code>来进行<code>CGLIB</code>代理，这里只会代理配置类为<code>Full</code>的类</li>
<li>然后向<code>beanFactory</code>中添加一个<code>ImportAwareBeanPostProcessor</code>后置处理器</li>
</ul>
</blockquote>
</li>
<li><p>再一次调用<code>invokeBeanFactoryPostProcessors</code>，执行<code>BeanFactoryPostProcessor</code>的方法，但是这里<code>regularPostProcessors</code>一般情况下是不会有数据的，只有在外部通过手动添加<code>BeanFactoryPostProcessor</code>，才会有数据。</p>
</li>
<li><p>查找实现了<code>BeanFactoryPostProcessor</code>的后置处理器，并且执行后置处理器方法。下面的逻辑和上面的步骤类似，这里就不在列举了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 这里不进行初始化FactoryBeans，而是让bean工厂后置处理器去初始化这些常规的bean */</span></span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">		beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,Ordered, and the rest.</span></span><br><span class="line"><span class="comment">/** 分离出 orderedPostProcessorNames 和nonOrderedPostProcessorNames */</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 循环BeanNames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果这个bean被执行过了，则跳过不执行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">		<span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果bean实现了PriorityOrdered接口，则加入到priorityOrderedPostProcessors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">		priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 如果bean实现了Ordered接口，则加入到orderedPostProcessorNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">		orderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 既没有实现PriorityOrdered接口，也没有实现Ordered接口，则加入到nonOrderedPostProcessorNames</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、调用实现PriorityOrdered接口的bean工厂后置处理器</span></span><br><span class="line"><span class="comment"> * 排序处理priorityOrderedPostProcessors,即实现了PriorityOrdered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行priorityOrderedPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、调用实现Ordered接口实现的bean后置处理器</span></span><br><span class="line"><span class="comment"> * 执行实现了Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">	orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、调用其他所有的bean后置处理器</span></span><br><span class="line"><span class="comment"> * 执行既没有实现PriorityOrdered接口也没有实现Ordered接口的BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">	nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 这里会调用EventListenerMethodProcessor.postProcessBeanFactory(),注册事件监听器后置处理器 */</span></span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"><span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">beanFactory.clearMetadataCache();</span><br></pre></td></tr></table></figure>

<p>最后附上<code>invokeBeanFactoryPostProcessor</code>方法中执行流程图，结合历程图更容易理解整个流程</p>
<p><img src="/archives/e74be873/IOC%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B-invokeBeanFactoryPostProcessor.png" alt="IOC加载流程-invokeBeanFactoryPostProcessor"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring源码</tag>
      </tags>
  </entry>
</search>
